(function(){const pages=[{"idx":0,"href":"/python100days/posts/PEP8%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/","title":"PEP 8风格指南","content":"PEP 8风格指南 PEP是Python Enhancement Proposal的缩写，通常翻译为“Python增强提案”。每个PEP都是一份为Python社区提供的指导Python往更好的方向发展的技术文档，其中的第8号增强提案（PEP 8）是针对Python语言编订的代码风格指南。尽管我们可以在保证语法没有问题的前提下随意书写Python代码，但是在实际开发中，采用一致的风格书写出可读性强的代码是每个专业的程序员应该做到的事情，也是每个公司的编程规范中会提出的要求，这些在多人协作开发一个项目（团队开发）的时候显得尤为重要。我们可以从Python官方网站的PEP 8链接中找到该文档，下面我们对该文档的关键部分做一个简单的总结。\n空格的使用  使用空格来表示缩进而不要用制表符（Tab）。这一点对习惯了其他编程语言的人来说简直觉得不可理喻，因为绝大多数的程序员都会用Tab来表示缩进，但是要知道Python并没有像C/C++或Java那样的用花括号来构造一个代码块的语法，在Python中分支和循环结构都使用缩进来表示哪些代码属于同一个级别，鉴于此Python代码对缩进以及缩进宽度的依赖比其他很多语言都强得多。在不同的编辑器中，Tab的宽度可能是2、4或8个字符，甚至是其他更离谱的值，用Tab来表示缩进对Python代码来说可能是一场灾难。 和语法相关的每一层缩进都用4个空格来表示。 每行的字符数不要超过79个字符，如果表达式因太长而占据了多行，除了首行之外的其余各行都应该在正常的缩进宽度上再加上4个空格。 函数和类的定义，代码前后都要用两个空行进行分隔。 在同一个类中，各个方法之间应该用一个空行进行分隔。 二元运算符的左右两侧应该保留一个空格，而且只要一个空格就好。  标识符命名 PEP 8倡导用不同的命名风格来命名Python中不同的标识符，以便在阅读代码时能够通过标识符的名称来确定该标识符在Python中扮演了怎样的角色（在这一点上，Python自己的内置模块以及某些第三方模块都做得并不是很好）。\n 变量、函数和属性应该使用小写字母来拼写，如果有多个单词就使用下划线进行连接。 类中受保护的实例属性，应该以一个下划线开头。 类中私有的实例属性，应该以两个下划线开头。 类和异常的命名，应该每个单词首字母大写。 模块级别的常量，应该采用全大写字母，如果有多个单词就用下划线进行连接。 类的实例方法，应该把第一个参数命名为self以表示对象自身。 类的类方法，应该把第一个参数命名为cls以表示该类自身。  表达式和语句 在Python之禅（可以使用import this查看）中有这么一句名言：“There should be one\u0026ndash; and preferably only one \u0026ndash;obvious way to do it.”，翻译成中文是“做一件事应该有而且最好只有一种确切的做法”，这句话传达的思想在PEP 8中也是无处不在的。\n 采用内联形式的否定词，而不要把否定词放在整个表达式的前面。例如if a is not b就比if not a is b更容易让人理解。 不要用检查长度的方式来判断字符串、列表等是否为None或者没有元素，应该用if not x这样的写法来检查它。 就算if分支、for循环、except异常捕获等中只有一行代码，也不要将代码和if、for、except等写在一起，分开写才会让代码更清晰。 import语句总是放在文件开头的地方。 引入模块的时候，from math import sqrt比import math更好。 如果有多个import语句，应该将其分为三部分，从上到下分别是Python标准模块、第三方模块和自定义模块，每个部分内部应该按照模块名称的字母表顺序来排列。 "},{"idx":1,"href":"/python100days/posts/","title":"Posts","content":""},{"idx":2,"href":"/python100days/posts/Python%E4%B9%8B%E7%A6%85/","title":"Python之禅","content":"Python之禅 Beautiful is better than ugly. （优美比丑陋好）\nExplicit is better than implicit.（清晰比晦涩好）\nSimple is better than complex.（简单比复杂好）\nComplex is better than complicated.（复杂比错综复杂好）\nFlat is better than nested.（扁平比嵌套好）\nSparse is better than dense.（稀疏比密集好）\nReadability counts.（可读性很重要）\nSpecial cases aren\u0026rsquo;t special enough to break the rules.（特殊情况也不应该违反这些规则）\nAlthough practicality beats purity.（但现实往往并不那么完美）\nErrors should never pass silently.（异常不应该被静默处理）\nUnless explicitly silenced.（除非你希望如此）\nIn the face of ambiguity, refuse the temptation to guess.（遇到模棱两可的地方，不要胡乱猜测）\nThere should be one\u0026ndash; and preferably only one \u0026ndash;obvious way to do it.（肯定有一种通常也是唯一一种最佳的解决方案）\nAlthough that way may not be obvious at first unless you\u0026rsquo;re Dutch.（虽然这种方案并不是显而易见的，因为你不是那个荷兰人^这里指的是Python之父Guido^）\nNow is better than never.（现在开始做比不做好）\nAlthough never is often better than *right* now.（不做比盲目去做好^极限编程中的YAGNI原则^）\nIf the implementation is hard to explain, it\u0026rsquo;s a bad idea.（如果一个实现方案难于理解，它就不是一个好的方案）\nIf the implementation is easy to explain, it may be a good idea.（如果一个实现方案易于理解，它很有可能是一个好的方案）\nNamespaces are one honking great idea \u0026ndash; let\u0026rsquo;s do more of those!（命名空间非常有用，我们应当多加利用）\n"},{"idx":3,"href":"/python100days/posts/Python%E5%8F%82%E8%80%83%E4%B9%A6%E7%B1%8D/","title":"Python参考书籍","content":"Python参考书籍 入门读物  《Python基础教程》（*Beginning Python From Novice to Professional*） 《Python学习手册》（*Learning Python*） 《Python编程》（*Programming Python*） 《Python Cookbook》 《Python程序设计》（*Python Programming: An Introduction to Computer Science*） 《Modern Python Cookbook》  进阶读物  《Python核心编程》（*Core Python Applications Programming*） 《流畅的Python》（*Fluent Python*） 《Effective Python：编写高质量Python代码的59个有效方法》（*Effective Python 59 Specific Ways to Write Better Python*） 《Python设计模式》（*Learning Python Design Patterns*） 《Python高级编程》（*Expert Python Programming*） 《Python性能分析与优化》（*Mastering Python High Performance*）  Web框架  《Django基础教程》（*Tango with Django*） 《轻量级Django》（*Lightweight Django*） 《Python Web开发：测试驱动方法》（*Test-Driven Development with Python*） 《Web Development with Django Cookbook》 《Test-Driven Development with Django》 《Django Project Blueprints 》 《Flask Web开发：基于Python的Web应用开发实战》（*Flask Web Development: Developing Web Applications with Python*） 《深入理解Flask》（*Mastering Flask*）  爬虫开发  《用Python写网络爬虫》（*Web Scraping with Python*） 《精通Python爬虫框架Scrapy》（*Learning Scrapy*） 《Python网络数据采集》（*Web Scraping with Python*） 《Python爬虫开发与项目实战》 《Python 3网络爬虫开发实战》  数据分析  《利用Python进行数据分析》（*Python for Data Analysis*） 《Python数据科学手册》（*Python Data Science Handbook*） 《Python金融大数据分析》（*Python for Finance*） 《Python数据可视化编程实战》（*Python Data Visualization Cookbook*） 《Python数据处理》（*Data Wrangling with Python*）  机器学习  《Python机器学习基础教程》（*Introduction to Machine Learning with Python*） 《Python机器学习实践指南》（*Python Machine Learning Blueprints*） 《Python Machine Learning Case Studies》 《Python机器学习实践：测试驱动的开发方法》（*Thoughtful Machine Learning with Python A Test Driven Approach*） 《Python机器学习经典实例》（*Python Machine Learning Cookbook*） 《TensorFlow：实战Google深度学习框架》 "},{"idx":4,"href":"/python100days/posts/Python%E6%83%AF%E4%BE%8B/","title":"Python惯例","content":"Python惯例 “惯例”这个词指的是“习惯的做法，常规的办法，一贯的做法”，与这个词对应的英文单词叫“idiom”。由于Python跟其他很多编程语言在语法和使用上还是有比较显著的差别，因此作为一个Python开发者如果不能掌握这些惯例，就无法写出“Pythonic”的代码。下面我们总结了一些在Python开发中的惯用的代码。\n 让代码既可以被导入又可以被执行。\nif __name__ == \u0026#39;__main__\u0026#39;:   用下面的方式判断逻辑“真”或“假”。\nif x: if not x:  好的代码：\nname = \u0026#39;jackfrued\u0026#39; fruits = [\u0026#39;apple\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;grape\u0026#39;] owners = {\u0026#39;1001\u0026#39;: \u0026#39;骆昊\u0026#39;, \u0026#39;1002\u0026#39;: \u0026#39;王大锤\u0026#39;} if name and fruits and owners: print(\u0026#39;I love fruits!\u0026#39;) 不好的代码：\nname = \u0026#39;jackfrued\u0026#39; fruits = [\u0026#39;apple\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;grape\u0026#39;] owners = {\u0026#39;1001\u0026#39;: \u0026#39;骆昊\u0026#39;, \u0026#39;1002\u0026#39;: \u0026#39;王大锤\u0026#39;} if name != \u0026#39;\u0026#39; and len(fruits) \u0026gt; 0 and owners != {}: print(\u0026#39;I love fruits!\u0026#39;)  善于使用in运算符。\nif x in items: # 包含 for x in items: # 迭代  好的代码：\nname = \u0026#39;Hao LUO\u0026#39; if \u0026#39;L\u0026#39; in name: print(\u0026#39;The name has an L in it.\u0026#39;) 不好的代码：\nname = \u0026#39;Hao LUO\u0026#39; if name.find(\u0026#39;L\u0026#39;) != -1: print(\u0026#39;This name has an L in it!\u0026#39;)  不使用临时变量交换两个值。\na, b = b, a 用序列构建字符串。\n  好的代码：\nchars = [\u0026#39;j\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;k\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;d\u0026#39;] name = \u0026#39;\u0026#39;.join(chars) print(name) # jackfrued 不好的代码：\nchars = [\u0026#39;j\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;k\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;d\u0026#39;] name = \u0026#39;\u0026#39; for char in chars: name += char print(name) # jackfrued  EAFP优于LBYL。  EAFP - Easier to Ask Forgiveness than Permission.\nLBYL - Look Before You Leap.\n好的代码：\nd = {\u0026#39;x\u0026#39;: \u0026#39;5\u0026#39;} try: value = int(d[\u0026#39;x\u0026#39;]) print(value) except (KeyError, TypeError, ValueError): value = None 不好的代码：\nd = {\u0026#39;x\u0026#39;: \u0026#39;5\u0026#39;} if \u0026#39;x\u0026#39; in d and isinstance(d[\u0026#39;x\u0026#39;], str) \\ and d[\u0026#39;x\u0026#39;].isdigit(): value = int(d[\u0026#39;x\u0026#39;]) print(value) else: value = None  使用enumerate进行迭代。  好的代码：\nfruits = [\u0026#39;orange\u0026#39;, \u0026#39;grape\u0026#39;, \u0026#39;pitaya\u0026#39;, \u0026#39;blueberry\u0026#39;] for index, fruit in enumerate(fruits): print(index, \u0026#39;:\u0026#39;, fruit) 不好的代码：\nfruits = [\u0026#39;orange\u0026#39;, \u0026#39;grape\u0026#39;, \u0026#39;pitaya\u0026#39;, \u0026#39;blueberry\u0026#39;] index = 0 for fruit in fruits: print(index, \u0026#39;:\u0026#39;, fruit) index += 1  用生成式生成列表。  好的代码：\ndata = [7, 20, 3, 15, 11] result = [num * 3 for num in data if num \u0026gt; 10] print(result) # [60, 45, 33] 不好的代码：\ndata = [7, 20, 3, 15, 11] result = [] for i in data: if i \u0026gt; 10: result.append(i * 3) print(result) # [60, 45, 33]  用zip组合键和值来创建字典。  好的代码：\nkeys = [\u0026#39;1001\u0026#39;, \u0026#39;1002\u0026#39;, \u0026#39;1003\u0026#39;] values = [\u0026#39;骆昊\u0026#39;, \u0026#39;王大锤\u0026#39;, \u0026#39;白元芳\u0026#39;] d = dict(zip(keys, values)) print(d) 不好的代码：\nkeys = [\u0026#39;1001\u0026#39;, \u0026#39;1002\u0026#39;, \u0026#39;1003\u0026#39;] values = [\u0026#39;骆昊\u0026#39;, \u0026#39;王大锤\u0026#39;, \u0026#39;白元芳\u0026#39;] d = {} for i, key in enumerate(keys): d[key] = values[i] print(d)  说明：这篇文章的内容来自于网络，有兴趣的读者可以阅读原文。\n"},{"idx":5,"href":"/python100days/posts/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/","title":"使用Hexo搭建自己的博客","content":"使用Hexo搭建自己的博客 对于一个程序员来说，搭建一个属于自己的博客平台是非常有意义的事情。首先，博客可以记录自己的成长历程，也是对自己一段时间学习和工作的总结和沉淀；其他，通过博客可以营销自己，增强自己在互联网或行业内的影响力，为将来更好的职业生涯打一个坚实的基础。前几年有一本名为《软技能 - 代码之外的生存指南》的畅销书，我记得书中有这么一段话：“流行乐队的音乐才华可能并不比夜店驻场乐队高多少，他们为什么就可以在全世界巡回演出，创造一个又一个白金记录？……你的营销做得越好，你的才华才能表现得淋漓尽致。”\n这里顺便啰嗦两句，在互联网如此发达的今天，我们应该如何营销自己呢？自我营销首先要从打造个人品牌做起，对于程序员来说，最容易去做好的一件事情还是搭建自己的博客。博客相当于是你在互联网上的一个基地，尤其是当你拥有了属于自己的独立博客后，你可以做很多自己想做的事情，既可以传达自己的思想，又可以提升自己的影响力，当然如果你的博客经营得非常好，你可以从中获利。当然，除了博客，直播、视频网站、投稿、写书、技术活动都是可选的自我营销方式。当然，做自我营销也需要持之以恒，三天打鱼两天晒网是很难有什么收获的。\nHexo概述 Hexo是一个快速、简洁且高效的博客框架，它能够将Markdown格式的文档渲染成漂亮的网页，这样我们就可以在很短的时间内迅速的创建出网站的静态内容，而Markdown格式对程序员来说相信并不陌生。要想使用Hexo来搭建自己的博客，我实在想不出有什么教程比官方文档更好，强烈建议大家阅读官方文档来了解Hexo，下面我只做一个简要的使用说明。\n 说明：Markdown是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，同时也对图片、图表、数学公式提供了支持，可以用来书写电子书、软件文档等，同时也可以非常方便的转换为HTML页面或者是PDF文档。\n 要使用Hexo，首先得确保计算机上已经安装了node.js环境和git环境，前者是一个能够在服务器端运行JavaScript代码的环境，后者是版本控制工具。安装node.js主要是为了使用它的包管理工具npm，所以不需要先系统的学习node.js的知识；而安装git是为了利用版本控制系统克隆代码已经将博客项目托管到三方平台，如果想学习git，最好的资料是官方网站上的Git Pro和《Git权威指南》。安装完成后，我们可以通过下面的命令来确认node.js环境以及它的包管理工具是否安装成功。\nnode --version npm --version 可以通过下面的命令来检查是否安装了git环境。\ngit --version 我们可以使用npm来安装Hexo，npm是node.js的包管理工具，跟Python的pip工具作用一样，可以用它来安装依赖库和三方工具。在第一次使用npm的时候，我们可以先将npm的下载源更换为国内的淘宝镜像，这样下载的速度会有非常显著的提升。\nnpm config set registry https://registry.npm.taobao.org 接下来我们就通过npm来安装Hexo，命令如下所示。\nnpm install -g hexo-cli 安装成功后，就可以使用Hexo来创建属于自己的博客啦。\n搭建博客  说明：以下内容基本上来自于Hexo的官方文档，推荐大家阅读官方文档。\n 我们先通过下面的命令来创建一个专门保存博客项目的文件夹，该命令会从github上克隆博客项目和默认的主题。\nhexo init blog 接下来我们进入这个文件夹并查看目录结构。\ncd blog ls -lR total 232 -rw-r--r-- 1 Hao staff 1768 8 8 01:15 _config.yml drwxr-xr-x 274 Hao staff 8768 8 8 01:19 node_modules -rw-r--r-- 1 Hao staff 109972 8 8 01:19 package-lock.json -rw-r--r-- 1 Hao staff 443 8 8 01:15 package.json drwxr-xr-x 5 Hao staff 160 8 8 01:15 scaffolds drwxr-xr-x 3 Hao staff 96 8 8 01:15 source drwxr-xr-x 3 Hao staff 96 8 8 01:15 themes   说明：Windows环境命令行提示符中可以使用dir命令查看目录结构。需要说明的是：_config.yml是博客项目的配置文件；package.json是项目的依赖项文件；scaffolds保存了Markdown文件的模板，也就是向新添加的Markdown文件中默认填充的内容；source目录下有一个名为_post的目录，我们稍后可以将编写好的Markdown文件放到该目录，这样就可以利用Hexo将Markdown文件处理成博客的静态页面，生成的静态页面将置于public目录下；themes文件夹保存了博客使用的主题。\n 然后我们通过下面的命令来安装项目所需的依赖项（package.json文件指明了这些依赖项）。\nnpm install 做完上述的操作以后，我们已经可以直接通过下面的命令来生成博客。\nhexo generate 该命令也可以缩写为：\nhexo g 之前我们在安装依赖项的时候包括了一个名为hexo-server的依赖项，该依赖项可以帮助我们启动一个基于node.js的服务器来运行我们的博客项目，使用下面的命令即可启动服务器。\nhexo server 该命令也可以缩写为：\nhexo s INFO Start processing INFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.  从运行命令的提示信息可以看到，服务器已经运转起并使用了4000端口，可以通过Ctrl+C来终止服务器的运行。如果要修改服务器使用的端口，可以在启动服务器的时候加上-p参数；如果希望服务器启动后，自动打开默认的浏览器访问服务器，可以使用-o参数，如下所示。\nhexo s -p 8000 -o 至此，我们已经可以看到Hexo在没有配置也没有加入自己的Markdown文件下生成的首页，如下图所示。\n接下来我们修改博客的配置文件。\nvim _config.yml# Hexo Configuration # Docs: https://hexo.io/docs/configuration.html # Source: https://github.com/hexojs/hexo/ # Site title: 骆昊的技术专栏 subtitle: 传道、授业、解惑，分享知识带来的快乐 description: keywords: author: 骆昊 language: zh timezone: # URL # If your site is put in a subdirectory, set url as \u0026#39;http://yoursite.com/child\u0026#39; and root as \u0026#39;/child/\u0026#39; url: http://jackfrued.top root: / permalink: :year/:month/:day/:title/ permalink_defaults: # Directory source_dir: source public_dir: public tag_dir: tags archive_dir: archives category_dir: categories code_dir: downloads/code i18n_dir: :lang skip_render: # Writing new_post_name: :title.md # File name of new posts default_layout: post titlecase: false # Transform title into titlecase external_link: true # Open external links in new tab filename_case: 0 render_drafts: false post_asset_folder: false relative_link: false future: true highlight: enable: true line_number: true auto_detect: false tab_replace: # Home page setting # path: Root path for your blogs index page. (default = \u0026#39;\u0026#39;) # per_page: Posts displayed per page. (0 = disable pagination) # order_by: Posts order. (Order by date descending by default) index_generator: path: \u0026#39;\u0026#39; per_page: 10 order_by: -date # Category \u0026amp; Tag default_category: uncategorized category_map: tag_map: # Date / Time format # Hexo uses Moment.js to parse and display date # You can customize the date format as defined in # http://momentjs.com/docs/#/displaying/format/ date_format: YYYY-MM-DD time_format: HH:mm:ss # Pagination # Set per_page to 0 to disable pagination per_page: 10 pagination_dir: page # Extensions # Plugins: https://hexo.io/plugins/ # Themes: https://hexo.io/themes/ theme: landscape # Deployment # Docs: https://hexo.io/docs/deployment.html deploy: type: 下面是YAML文件中相关选项的说明。\n   参数 描述     title 网站的标题   subtitle 网站的副标题   description 网站的描述   keywords 网站的关键词，可以用逗号分隔多个关键词   author 自己的名字   language 网站使用的语言   timezone 网站使用时区，默认使用电脑上设置的时区   url 网址   root 网站根目录   source_dir 资源文件夹，这个文件夹用来存放内容，默认source目录   public_dir 公共文件夹，这个文件夹用于存放生成的站点文件，默认public目录   tag_dir 标签文件夹，默认tags目录   archive_dir 归档文件夹，默认archives目录   category_dir 分类文件夹，默认categories目录   auto_spacing 在中文和英文之间加入空格，默认false   titlecase 把标题转换为首字母大写，默认false   external_link 在新标签中打开链接，默认true   relative_link 把链接改为与根目录的相对位址，默认false   default_category 默认分类   date_format 日期格式，默认YYYY-MM-DD   time_format 时间格式，默认HH:mm:ss   per_page 每页显示的文章数量 ，默认值10，0表示不使用分页   pagination_dir 分页目录，默认为page目录   theme 当前主题名称   deploy 部署部分的设置    我们将编写好的Markdown文件可以拷贝到source/_posts目录，我们可以在每个Markdown文件的上方添加Front-matter来对文件的布局、标题、分类、标签、发布日期等信息加以说明。所谓Front-matter，就是每个Markdown文件最上方以---分隔的区域，可以在Front-matter中设置以下内容。\n   参数 描述 默认值     layout 布局    title 标题    date 建立日期 文件建立日期   updated 更新日期 文件更新日期   comments 开启文章的评论功能 true   tags 标签（不适用于分页）    categories 分类（不适用于分页）    permalink 覆盖文章网址     例如：\n--- title: Python编程惯例 category: Python基础 date: 2019-8-1 --- # Python惯例 “惯例”这个词指的是“习惯的做法，常规的办法，一贯的做法”，与这个词对应的英文单词叫“idiom”。由于Python跟其他很多编程语言在语法和使用上还是有比较显著的差别，因此作为一个Python开发者如果不能掌握这些惯例，就无法写出“Pythonic”的代码。下面我们总结了一些在Python开发中的惯用的代码。 1. 让代码既可以被导入又可以被执行。 if __name__ == \u0026#39;__main__\u0026#39;: 2. 用下面的方式判断逻辑“真”或“假”。 if x: if not x: 在完成上述工作后，我们可以通过下面的命令先清理之前生成的内容。\nhexo clean 接下来我们就可以用之前讲过的命令重新生成并运行博客项目。\nhexo generate hexo server -p 8000 -o 将博客托管到GitHub 我们可以利用GitHub网站提供的Pages服务来托管我们的博客。在GitHub Pages的首页上就有一个教程指导我们如何托管自己的网站，当然第一步得在GitHub上注册一个属于自己的账号，登录成功之后才能进行后续的操作。\n 根据自己的用户名创建一个仓库，仓库一定要取名为“用户名.github.io”。例如：我在GitHub上的用户名是jackfrued，那么我的托管博客项目的仓库一定要命名为jackfrued.github.io。   修改博客项目的配置文件_config.yml，配置使用GitHub来部署该博客项目。\nvim _config.yml# 省略上面的内容 # Deployment # Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: https://github.com/jackfrued/jackfrued.github.io.git branch: master  上面的配置中，type指定了使用git进行项目部署，repo指定了部署项目的git仓库的URL，我们这里使用的是HTTPS的地址，如果之前配置过密钥对也可以使用SSH的地址，branch指定了将代码同步到仓库中的哪一个分支，通常master分支就是发布项目最终工作成果的分支，也称为项目的主分支。\n 安装名为hexo-deployer-git的部署器插件，通过该插件就能实现一键部署。\nnpm install hexo-deployer-git --save 可以使用下面的命令来实现一键部署到GitHub。\nhexo deploy -g  或者\nhexo generate -d  接下来在浏览器中输入jackfrued.github.io就能够看到自己的博客，现在全世界的人都可以通过这个URL来访问你的博客。大家是否注意到，访问你博客的这个URL就是刚才我们给仓库起的名字，因为你在GitHub上注册的用户名是独一无二的，所以这个域名也是全世界独一无二的。  将博客绑定到自己的域名 虽然我们已经通过GitHub提供的域名访问到了自己的博客，但是如果我们不愿意“寄人篱下”，我们在利用GitHub Pages提供的托管服务同时，也可以将博客绑定到自己专属的域名。如果暂时还没有购买域名，我们可以在提供域名购买服务的网站（如：万网、GoDaddy）上进行购买。\n 说明：目前国内对域名的管理日趋严格，在购买域名时需要填写一大堆的个人信息，进行实名认证后才能获得域名，这一点相信大家能够理解。\n 比如说，我现在已经购买了一个名为“jackfrued.top”的域名，如何让它跟“jackfrued.github.io”这个域名做一个绑定呢，我们可以利用阿里云控制台或者DNSPod来做一个域名解析服务。在域名解析平台登录成功后，可以添加或选择自己的域名来配置域名解析。点击“添加记录”按钮，创建一个类型为CNAME的域名解析，CNAME类型的解析代表将一个域名解析到另一个域名，如下图所示。\n完成这一步后，还不能马上通过自己的域名访问到博客项目，最后需要在博客项目的source目录下添加一个名为CNAME的文件（请注意这个文件的名字是全大写字母的）。\nvim CNAME 编辑该文件的内容，如下所示。\njackfrued.top  可以清理一下之前生成的内容，然后将项目重新生成并发布到GitHub就大功告成了！现在我们已经拥有了独立域名的博客，希望大家可以利用它做些有意义的事情（记录自己的成长历程、分享自己的工作经验、提升个人的影响力）。加油吧，程序员！\n"},{"idx":6,"href":"/python100days/posts/%E5%B8%B8%E8%A7%81%E5%8F%8D%E7%88%AC%E7%AD%96%E7%95%A5%E5%8F%8A%E5%BA%94%E5%AF%B9%E6%96%B9%E6%A1%88/","title":"常见反爬策略及应对方案","content":"常见反爬策略及应对方案  构造合理的HTTP请求头。\n Accept\n User-Agent - 三方库fake-useragent\nfrom fake_useragent import UserAgent ua = UserAgent() ua.ie # Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US); ua.msie # Mozilla/5.0 (compatible; MSIE 10.0; Macintosh; Intel Mac OS X 10_7_3; Trident/6.0)\u0026#39; ua[\u0026#39;Internet Explorer\u0026#39;] # Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0; GTB7.4; InfoPath.2; SV1; .NET CLR 3.3.69573; WOW64; en-US) ua.opera # Opera/9.80 (X11; Linux i686; U; ru) Presto/2.8.131 Version/11.11 ua.chrome # Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.2 (KHTML, like Gecko) Chrome/22.0.1216.0 Safari/537.2\u0026#39; ua.google # Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_4) AppleWebKit/537.13 (KHTML, like Gecko) Chrome/24.0.1290.1 Safari/537.13 ua[\u0026#39;google chrome\u0026#39;] # Mozilla/5.0 (X11; CrOS i686 2268.111.0) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11 ua.firefox # Mozilla/5.0 (Windows NT 6.2; Win64; x64; rv:16.0.1) Gecko/20121011 Firefox/16.0.1 ua.ff # Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:15.0) Gecko/20100101 Firefox/15.0.1 ua.safari # Mozilla/5.0 (iPad; CPU OS 6_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/6.0 Mobile/10A5355d Safari/8536.25 # and the best one, random via real world browser usage statistic ua.random    Referer\n Accept-Encoding\n Accept-Language\n    检查网站生成的Cookie。  有用的插件：EditThisCookie 如何处理脚本动态生成的Cookie  抓取动态内容。  Selenium + WebDriver Chrome / Firefox - Driver  限制爬取的速度。 处理表单中的隐藏域。  在读取到隐藏域之前不要提交表单 用RoboBrowser这样的工具辅助提交表单  处理表单中的验证码。\n OCR（Tesseract） - 商业项目一般不考虑\n 专业识别平台 - 超级鹰 / 云打码\nfrom hashlib import md5 class ChaoClient(object): def __init__(self, username, password, soft_id): self.username = username password = password.encode(\u0026#39;utf-8\u0026#39;) self.password = md5(password).hexdigest() self.soft_id = soft_id self.base_params = { \u0026#39;user\u0026#39;: self.username, \u0026#39;pass2\u0026#39;: self.password, \u0026#39;softid\u0026#39;: self.soft_id, } self.headers = { \u0026#39;Connection\u0026#39;: \u0026#39;Keep-Alive\u0026#39;, \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)\u0026#39;, } def post_pic(self, im, codetype): params = { \u0026#39;codetype\u0026#39;: codetype, } params.update(self.base_params) files = {\u0026#39;userfile\u0026#39;: (\u0026#39;captcha.jpg\u0026#39;, im)} r = requests.post(\u0026#39;http://upload.chaojiying.net/Upload/Processing.php\u0026#39;, data=params, files=files, headers=self.headers) return r.json() if __name__ == \u0026#39;__main__\u0026#39;: client = ChaoClient(\u0026#39;用户名\u0026#39;, \u0026#39;密码\u0026#39;, \u0026#39;软件ID\u0026#39;) with open(\u0026#39;captcha.jpg\u0026#39;, \u0026#39;rb\u0026#39;) as file: print(client.post_pic(file, 1902))   绕开“陷阱”。\n 网页上有诱使爬虫爬取的爬取的隐藏链接（陷阱或蜜罐） 通过Selenium+WebDriver+Chrome判断链接是否可见或在可视区域  隐藏身份。\n 代理服务 - 快代理 / 讯代理 / 芝麻代理 / 蘑菇代理 / 云代理  《爬虫代理哪家强？十大付费代理详细对比评测出炉！》\n 洋葱路由 - 国内需要翻墙才能使用\nyum -y install tor useradd admin -d /home/admin passwd admin chown -R admin:admin /home/admin chown -R admin:admin /var/run/tor tor  "},{"idx":7,"href":"/python100days/posts/%E7%8E%A9%E8%BD%ACPyCharm/","title":"玩转PyCharm","content":"玩转PyCharm PyCharm是由JetBrains公司开发的提供给Python专业的开发者的一个集成开发环境，它最大的优点是能够大大提升Python开发者的工作效率，为开发者集成了很多用起来非常顺手的功能，包括代码调试、高亮语法、代码跳转、智能提示、自动补全、单元测试、版本控制等等。此外，PyCharm还提供了对一些高级功能的支持，包括支持基于Django框架的Web开发。\nPyCharm的安装 可以在[JetBrains公司的官方网站]()找到PyCharm的下载链接，有两个可供下载的版本一个是社区版一个是专业版，社区版在Apache许可证下发布，专业版在专用许可证下发布（需要购买授权下载后可试用30天），其拥有许多额外功能。安装PyCharm需要有JRE（Java运行时环境）的支持，如果没有可以在安装过程中选择在线下载安装。\n 说明：如果你是一名学生，希望购买PyCharm来使用，可以看看教育优惠官方申请指南。\n 首次使用的设置 第一次使用PyCharm时，会有一个导入设置的向导，如果之前没有使用PyCharm或者没有保存过设置的就直接选择“Do not import settings”进入下一步即可。\n专业版的PyCharm是需要激活的，强烈建议为优秀的软件支付费用，如果不用做商业用途，我们可以暂时选择试用30天或者使用社区版的PyCharm。\n接下来是选择UI主题，这个可以根据个人喜好进行选择。\n再接下来是创建可以在终端（命令行）中使用PyCharm项目的启动脚本，当然也可以直接跳过这一步。\n然后可以选择需要安装哪些插件，我们可以暂时什么都不安装等需要的时候再来决定。\n用PyCharm创建项目 点击上图中的“Start using PyCharm”按钮就可以开始使用PyCharm啦，首先来到的是一个欢迎页，在欢迎页上我们可以选择“创建新项目”、“打开已有项目”和“从版本控制系统中检出项目”。\n如果选择了“Create New Project”来创建新项目就会打一个创建项目的向导页。\n在如上图所示的界面中，我们可以选择创建项目的模板，包括了纯Python项目、基于各种不同框架的Web项目、Web前端项目、跨平台项目等各种不同的项目模板。如果选择Python的项目，那么有一个非常重要的设定是选择“New environment…”（创建新的虚拟环境）还是使用“Existing Interpreter”（已经存在的解释器）。前者肯定是更好的选择，因为新的虚拟环境不会对系统环境变量中配置的Python环境造成影响，简单举个例子就是你在虚拟环境下安装或者更新了任何三方库，它并不会对系统原有的Python解释器造成任何的影响，但代价是需要额外的存储空间来建立这个虚拟环境。\n项目创建完成后就可以开始新建各种文件来书写Python代码了。\n在工作窗口的右键菜单中可以找到“Run \u0026hellip;”和“Debug \u0026hellip;”菜单项，通过这两个菜单项我们就可以运行和调试我们的代码啦。建议关注一下菜单栏中的“Code”、“Refactor”和“Tools”菜单，这里面为编写Python代码提供了很多有用的帮助。\n创建Django项目 专业版 PyCharm专业版提供了对Django、Flask、Google App Engine、web2py等Python Web框架以及SQL、UML、前端语言和框架、远程调试、虚拟化部署等功能的支持，如果使用PyCharm专业版，在创建项目时可以直接选择创建Django项目并设置模板语言以及放置模板页的文件夹。\n创建好项目之后，打开终端输入pip list命令，可以看到项目所需的依赖项已经安装好了，而且可以直接点击屏幕右上方的运行或调试按钮来直接运行Django项目。\n社区版 PyCharm社区版只能创建Python项目，如果项目中需要Django的支持，可以自行安装依赖库并创建Django项目。\n创建好Python项目之后，可以打开屏幕下方的终端（Terminal），并通过pip install安装Django项目的依赖项，可以通过-i https://pypi.doubanio.com/simple来指定下载依赖库的镜像仓库。\n当然也可以在项目的设置菜单中找到解释器配置，并选择要添加的依赖项。\n下面是搜索依赖项的界面，可以通过点击“Install Package”按钮来安装指定的依赖项；也可以通过点击“Manage Repositories”按钮来指定下载依赖项的仓库，国内用户推荐使用豆瓣镜像http://pypi.doubanio.com/simple。\n接下来可以在终端中输入django-amdin startproject指令来创建项目。\n如果要运行项目，可以在终端中输入python manage.py runserver启动测试服务器。当然，也可以点击屏幕右上方的“Add Configuration”按钮，进入如下所示的配置界面，并点击窗口左上角的“+”来添加一个运行配置。\n在配置窗口的右侧，指定要执行的脚本路径（Django项目的manage.py文件的位置）和运行参数（runserver），运行参数的后面还可以跟IP地址和端口。\n注意到窗口的右上角了吗？现在可以点击运行或调试按钮来启动测试服务器运行项目了。\n"},{"idx":8,"href":"/python100days/posts/%E7%94%A8%E5%87%BD%E6%95%B0%E8%BF%98%E6%98%AF%E7%94%A8%E5%A4%8D%E6%9D%82%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F/","title":"用函数还是用复杂的表达式","content":"用函数还是用复杂的表达式 要不要使用复杂表达式 Perl语言的原作者*Larry Wall*曾经说过，伟大的程序员都有三个优点：懒惰、暴躁和自负。乍一看这三个词语没有一个是褒义词，但在程序员的世界里，这三个词有不同的意义。首先，懒惰会促使程序员去写一些省事儿的程序来辅助自己或别人更好的完成工作，这样我们就无需做那些重复和繁琐的劳动；同理能够用3行代码解决的事情，我们也绝不会写出10行代码来。其次，暴躁会让程序员主动的去完成一些你还没有提出的工作，去优化自己的代码让它更有效率，能够3秒钟完成的任务，我们绝不能容忍1分钟的等待。最后，自负会促使程序员写出可靠无误的代码，我们写代码不是为了接受批评和指责，而是为了让其他人来膜拜。\n那么接下来就有一个很有意思的问题值得探讨一下，我们需要一个程序从输入的三个数中找出最大的那个数。这个程序对任何会编程的人来说都是小菜一碟，甚至不会编程的人经过10分钟的学习也能搞定。下面是用来解决这个问题的Python代码。\na = int(input(\u0026#39;a = \u0026#39;)) b = int(input(\u0026#39;b = \u0026#39;)) c = int(input(\u0026#39;c = \u0026#39;)) if a \u0026gt; b: the_max = a else: the_max = b if c \u0026gt; the_max: the_max = c print(\u0026#39;The max is:\u0026#39;, the_max) 但是我们刚才说了，程序员都是懒惰的，很多程序员都会使用三元条件运算符来改写上面的代码。\na = int(input(\u0026#39;a = \u0026#39;)) b = int(input(\u0026#39;b = \u0026#39;)) c = int(input(\u0026#39;c = \u0026#39;)) the_max = a if a \u0026gt; b else b the_max = c if c \u0026gt; the_max else the_max print(\u0026#39;The max is:\u0026#39;, the_max) 需要说明的是，Python在2.5版本以前是没有上面代码第4行和第5行中使用的三元条件运算符的，究其原因是Guido van Rossum（Python之父）认为三元条件运算符并不能帮助 Python变得更加简洁，于是那些习惯了在C/C++或Java中使用三元条件运算符（在这些语言中，三元条件运算符也称为“Elvis运算符”，因为?:放在一起很像著名摇滚歌手猫王Elvis的大背头）的程序员试着用and和or运算符的短路特性来模拟出三元操作符，于是在那个年代，上面的代码是这样写的。\na = int(input(\u0026#39;a = \u0026#39;)) b = int(input(\u0026#39;b = \u0026#39;)) c = int(input(\u0026#39;c = \u0026#39;)) the_max = a \u0026gt; b and a or b the_max = c \u0026gt; the_max and c or the_max print(\u0026#39;The max is:\u0026#39;, the_max) 但是这种做法在某些场景下是不能成立的，且看下面的代码。\na = 0 b = -100 # 下面的代码本来预期输出a的值，结果却得到了b的值 # 因为a的值0在进行逻辑运算时会被视为False来处理 print(True and a or b) # print(a if True else b) 所以在Python 2.5以后引入了三元条件运算符来避免上面的风险（上面代码被注释掉的最后一句话）。那么，问题又来了，上面的代码还可以写得更简短吗？答案是肯定的。\na = int(input(\u0026#39;a = \u0026#39;)) b = int(input(\u0026#39;b = \u0026#39;)) c = int(input(\u0026#39;c = \u0026#39;)) print(\u0026#39;The max is:\u0026#39;, (a if a \u0026gt; b else b) if (a if a \u0026gt; b else b) \u0026gt; c else c) 但是，这样做真的好吗？如此复杂的表达式是不是让代码变得晦涩了很多呢？我们发现，在实际开发中很多开发者都喜欢过度的使用某种语言的特性或语法糖，于是简单的多行代码变成了复杂的单行表达式，这样做真的好吗？这个问题我也不止一次的问过自己，现在我能给出的答案是下面的代码，使用辅助函数。\ndef the_max(x, y): return x if x \u0026gt; y else y a = int(input(\u0026#39;a = \u0026#39;)) b = int(input(\u0026#39;b = \u0026#39;)) c = int(input(\u0026#39;c = \u0026#39;)) print(\u0026#39;The max is:\u0026#39;, the_max(the_max(a, b), c)) 上面的代码中，我定义了一个辅助函数the_max用来找出参数传入的两个值中较大的那一个，于是下面的输出语句可以通过两次调用the_max函数来找出三个数中的最大值，现在代码的可读性是不是好了很多。用辅助函数来替代复杂的表达式真的是一个不错的选择，关键是比较大小的逻辑转移到这个辅助函数后不仅可以反复调用它，而且还可以进行级联操作。\n当然，很多语言中比较大小的函数根本没有必要自己来实现（通常都是内置函数），Python也是如此。Python内置的max函数利用了Python对可变参数的支持，允许一次性传入多个值或者一个迭代器并找出那个最大值，所以上面讨论的问题在Python中也就是一句话的事，但是从复杂表达式到使用辅助函数简化复杂表达式这个思想是非常值得玩味的，所以分享出来跟大家做一个交流。\na = int(input(\u0026#39;a = \u0026#39;)) b = int(input(\u0026#39;b = \u0026#39;)) c = int(input(\u0026#39;c = \u0026#39;)) print(\u0026#39;The max is:\u0026#39;, max(a, b, c))"},{"idx":9,"href":"/python100days/posts/%E7%9F%A5%E4%B9%8E%E9%97%AE%E9%A2%98%E5%9B%9E%E7%AD%94/","title":"知乎问题回答","content":"知乎问题回答 Python学习完基础语法知识后，如何进一步提高？ 如果你已经完成了Python基础语法的学习，想要知道接下来如何提高，那么你得先问问自己你要用Python来做什么？目前学习Python后可能的就业方向包括以下几个领域，我把每个领域需要的技术作为了一个简单的关键词摘要。\n 说明：以下数据参考了主要的招聘门户网站以及职友集。\n    职位 所需技能 招聘需求量     Python后端开发工程师 Python基础\nDjango / Flask / Tornado / Sanic\nRESTful / 接口文档撰写\nMySQL / Redis / MongoDB / ElasticSearch\nLinux / Git / Scrum / PyCharm 大   Python爬虫开发工程师 Python基础\n常用标准库和三方库\nScrapy / PySpider\nSelenium / Appnium\nRedis / MongoDB / MySQL\n前端 / HTTP(S) / 抓包工具 较少   Python量化交易开发工程师 Python基础\n数据结构 / 算法 / 设计模式\nNoSQL（KV数据库）\n金融学（两融、期权、期货、股票） / 数字货币 较大（一线城市）   Python数据分析工程师 /\nPython机器学习工程师 统计学专业 / 数学专业 / 计算机专业\nPython基础 / 算法设计\nSQL / NoSQL / Hive / Hadoop / Spark\nNumPy / Scikit-Learn / Pandas / Seaborn\nPyTorch / Tensorflow / OpenCV 较大（一线城市）   Python自动化测试工程师 Python基础 / 单元测试 / 软件测试基础\nLinux / Shell / JIRA / 禅道 / Jenkins / CI / CD\nSelenium / Robot Framework / Appnium\nab / sysbench / JMeter / LoadRunner / QTP 大   Python自动化运维工程师 Python基础 / Linux / Shell Fabric / Ansible / Playbook\nZabbix / Saltstack / Puppet\nDocker / paramiko 较大（一线城市）   Python云平台开发工程师 Python基础\nOpenStack / CloudStack\nOvirt / KVM\nDocker / K8S 较少（一线城市）    如果弄清了自己将来要做的方向，就可以开始有针对性的学习了，下面给大家一个推荐书籍的清单。\n 入门读物  《Python基础教程》（*Beginning Python From Novice to Professional*） 《Python学习手册》（*Learning Python*） 《Python编程》（*Programming Python*） 《Python编程从入门到实践》（*Python Crash Course*） 《Python Cookbook》  进阶读物  《软件架构 - Python语言实现》（*Software Architecture with Python*） 《流畅的Python》（*Fluent Python*） 《Python设计模式》（*Learning Python Design Patterns*） 《Python高级编程》（*Expert Python Programming*） 《Python性能分析与优化》（*Mastering Python High Performance*）  数据库相关  《MySQL必知必会》（*MySQL Crash Course*） 《深入浅出MySQL - 数据库开发、优化与管理维护》 《MongoDB权威指南》（*MongoDB: The Definitive Guide*） 《Redis实战》（*Redis in Action*） 《Redis开发与运维》  Linux / Shell / Docker / 运维  《鸟哥的Linux私房菜》 《Linux命令行与shell脚本编程大全》（*Linux Command Line and Shell Scripting Bible*） 《Python自动化运维:技术与最佳实践》 《第一本Docker书》（*The Docker Book*） 《Docker经典实例》（Docker Cookbook）  Django / Flask / Tornado\n 《Django基础教程》（*Tango with Django*）\n 《轻量级Django》（*Lightweight Django*）\n 《精通Django》（*Mastering Django: Core*）\n 《Python Web开发：测试驱动方法》（*Test-Driven Development with Python*）\n 《Two Scoops of Django: Best Practice of Django 1.8》\n 《Flask Web开发：基于Python的Web应用开发实战》（*Flask Web Development: Developing Web Applications with Python*）\n 《深入理解Flask》（*Mastering Flask*）\n 《Introduction to Tornado》\n  爬虫开发\n 《用Python写网络爬虫》（*Web Scraping with Python*）\n 《精通Python爬虫框架Scrapy》（*Learning Scrapy*）\n 《Python网络数据采集》（*Web Scraping with Python*）\n 《Python爬虫开发与项目实战》\n 《Python 3网络爬虫开发实战》\n  数据分析\n 《利用Python进行数据分析》（*Python for Data Analysis*） 《Python数据科学手册》（*Python Data Science Handbook*） 《Python金融大数据分析》（*Python for Finance*） 《Python数据可视化编程实战》（*Python Data Visualization Cookbook*） 《Python数据处理》（*Data Wrangling with Python*）  机器学习\n 《Python机器学习基础教程》（*Introduction to Machine Learning with Python*）\n 《Python机器学习实践指南》（*Python Machine Learning Blueprints*）\n 《Python机器学习实践：测试驱动的开发方法》（*Thoughtful Machine Learning with Python A Test Driven Approach*）\n 《Python机器学习经典实例》（*Python Machine Learning Cookbook*）\n 《TensorFlow：实战Google深度学习框架》\n  其他书籍\n 《Pro Git》 《Selenium自动化测试 - 基于Python语言》（*Learning Selenium Testing Tools with Python*） 《Selenium自动化测试之道》 《Scrum敏捷软件开发》（*Software Development using Scrum*） 《高效团队开发 - 工具与方法》   当然学习编程，最重要的通过项目实战来提升自己的综合能力，Github上有大量的优质开源项目，其中不乏优质的Python项目。有一个名为“awesome-python-applications”的项目对这些优质的资源进行了归类并提供了传送门，大家可以了解下。如果自学能力不是那么强，可以通过网络上免费或者付费的视频课程来学习对应的知识；如果自律性没有那么强，那就只能建议花钱参加培训班了，因为花钱在有人监督的环境下学习对很多人来说确实是一个捷径，但是要记得：“师傅领进门，修行靠各人”。选择自己热爱的东西并全力以赴，不要盲目的跟风学习，这一点算是过来人的忠告吧。记得我自己刚开始进入软件开发这个行业时，有人跟我说过这么一句话，现在也分享出来与诸君共勉：“浮躁的人有两种：只观望而不学习的人，只学习而不坚持的人；浮躁的人都不是高手。”\n"},{"idx":10,"href":"/python100days/posts/%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E8%B8%A9%E8%BF%87%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/","title":"那些年我们踩过的那些坑","content":"那些年我们踩过的那些坑 坑1 - 整数比较的坑 在 Python 中一切都是对象，整数也是对象，在比较两个整数时有两个运算符==和is，它们的区别是：\n is比较的是两个整数对象的id值是否相等，也就是比较两个引用是否代表了内存中同一个地址。 ==比较的是两个整数对象的内容是否相等，使用==时其实是调用了对象的__eq__()方法。  知道了is和==的区别之后，我们可以来看看下面的代码，了解Python中整数比较有哪些坑：\ndef main(): x = y = -1 while True: x += 1 y += 1 if x is y: print(\u0026#39;%dis %d\u0026#39; % (x, y)) else: print(\u0026#39;Attention! %dis not %d\u0026#39; % (x, y)) break x = y = 0 while True: x -= 1 y -= 1 if x is y: print(\u0026#39;%dis %d\u0026#39; % (x, y)) else: print(\u0026#39;Attention! %dis not %d\u0026#39; % (x, y)) break if __name__ == \u0026#39;__main__\u0026#39;: main() 上面代码的部分运行结果如下图所示，出现这个结果的原因是Python出于对性能的考虑所做的一项优化。对于整数对象，Python把一些频繁使用的整数对象缓存起来，保存到一个叫small_ints的链表中，在Python的整个生命周期内，任何需要引用这些整数对象的地方，都不再重新创建新的对象，而是直接引用缓存中的对象。Python把频繁使用的整数对象的值定在[-5, 256]这个区间，如果需要这个范围的整数，就直接从small_ints中获取引用而不是临时创建新的对象。因为大于256或小于-5的整数不在该范围之内，所以就算两个整数的值是一样，但它们是不同的对象。\n当然仅仅如此这个坑就不值一提了，如果你理解了上面的规则，我们就再看看下面的代码。\na = 257 def main(): b = 257 # 第6行 c = 257 # 第7行 print(b is c) # True print(a is b) # False print(a is c) # False if __name__ == \u0026#34;__main__\u0026#34;: main() 程序的执行结果已经用注释写在代码上了。够坑吧！看上去a、b和c的值都是一样的，但是is运算的结果却不一样。为什么会出现这样的结果，首先我们来说说Python程序中的代码块。所谓代码块是程序的一个最小的基本执行单位，一个模块文件、一个函数体、一个类、交互式命令中的单行代码都叫做一个代码块。上面的代码由两个代码块构成，a = 257是一个代码块，main函数是另外一个代码块。Python内部为了进一步提高性能，凡是在一个代码块中创建的整数对象，如果值不在small_ints缓存范围之内，但在同一个代码块中已经存在一个值与其相同的整数对象了，那么就直接引用该对象，否则创建一个新的对象出来，这条规则对不在small_ints范围的负数并不适用，对负数值浮点数也不适用，但对非负浮点数和字符串都是适用的，这一点读者可以自行证明。所以 b is c返回了True，而a和b不在同一个代码块中，虽然值都是257，但却是两个不同的对象，is运算的结果自然是False了。 为了验证刚刚的结论，我们可以借用dis模块（听名字就知道是进行反汇编的模块）从字节码的角度来看看这段代码。如果不理解什么是字节码，可以先看看《谈谈 Python 程序的运行原理》这篇文章。可以先用import dis导入dis模块并按照如下所示的方式修改代码。\nimport dis dis.dis(main) 代码的执行结果如下图所示。可以看出代码第6行和第7行，也就是main函数中的257是从同一个位置加载的，因此是同一个对象；而代码第9行的a明显是从不同的地方加载的，因此引用的是不同的对象。\n如果还想对这个问题进行进一步深挖，推荐大家阅读《Python整数对象实现原理》这篇文章。\n坑2 - 嵌套列表的坑 Python中有一种内置的数据类型叫列表，它是一种容器，可以用来承载其他的对象（准确的说是其他对象的引用），列表中的对象可以称为列表的元素，很明显我们可以把列表作为列表中的元素，这就是所谓的嵌套列表。嵌套列表可以模拟出现实中的表格、矩阵、2D游戏的地图（如植物大战僵尸的花园）、棋盘（如国际象棋、黑白棋）等。但是在使用嵌套的列表时要小心，否则很可能遭遇非常尴尬的情况，下面是一个小例子。\nnames = [\u0026#39;关羽\u0026#39;, \u0026#39;张飞\u0026#39;, \u0026#39;赵云\u0026#39;, \u0026#39;马超\u0026#39;, \u0026#39;黄忠\u0026#39;] subjs = [\u0026#39;语文\u0026#39;, \u0026#39;数学\u0026#39;, \u0026#39;英语\u0026#39;] scores = [[0] * 3] * 5 for row, name in enumerate(names): print(\u0026#39;请输入%s的成绩\u0026#39; % name) for col, subj in enumerate(subjs): scores[row][col] = float(input(subj + \u0026#39;: \u0026#39;)) print(scores) 我们希望录入5个学生3门课程的成绩，于是定义了一个有5个元素的列表，而列表中的每个元素又是一个由3个元素构成的列表，这样一个列表的列表刚好跟一个表格是一致的，相当于有5行3列，接下来我们通过嵌套的for-in循环输入每个学生3门课程的成绩。程序执行完成后我们发现，每个学生3门课程的成绩是一模一样的，而且就是最后录入的那个学生的成绩。\n要想把这个坑填平，我们首先要区分对象和对象的引用这两个概念，而要区分这两个概念，还得先说说内存中的栈和堆。我们经常会听人说起“堆栈”这个词，但实际上“堆”和“栈”是两个不同的概念。众所周知，一个程序运行时需要占用一些内存空间来存储数据和代码，那么这些内存从逻辑上又可以做进一步的划分。对底层语言（如C语言）有所了解的程序员大都知道，程序中可以使用的内存从逻辑上可以为五个部分，按照地址从高到低依次是：栈（stack）、堆（heap）、数据段（data segment）、只读数据段（static area）和代码段（code segment）。其中，栈用来存储局部、临时变量，以及函数调用时保存现场和恢复现场需要用到的数据，这部分内存在代码块开始执行时自动分配，代码块执行结束时自动释放，通常由编译器自动管理；堆的大小不固定，可以动态的分配和回收，因此如果程序中有大量的数据需要处理，这些数据通常都放在堆上，如果堆空间没有正确的被释放会引发内存泄露的问题，而像Python、Java等编程语言都使用了垃圾回收机制来实现自动化的内存管理（自动回收不再使用的堆空间）。所以下面的代码中，变量a并不是真正的对象，它是对象的引用，相当于记录了对象在堆空间的地址，通过这个地址我们可以访问到对应的对象；同理，变量b是列表容器的引用，它引用了堆空间上的列表容器，而列表容器中并没有保存真正的对象，它保存的也仅仅是对象的引用。\na = object() b = [\u0026#39;apple\u0026#39;, \u0026#39;pitaya\u0026#39;, \u0026#39;grape\u0026#39;] 知道了这一点，我们可以回过头看看刚才的程序，我们对列表进行[[0] * 3] * 5操作时，仅仅是将[0, 0, 0]这个列表的地址进行了复制，并没有创建新的列表对象，所以容器中虽然有5个元素，但是这5个元素引用了同一个列表对象，这一点可以通过id函数检查scores[0]和scores[1]的地址得到证实。所以正确的代码应该按照如下的方式进行修改。\nnames = [\u0026#39;关羽\u0026#39;, \u0026#39;张飞\u0026#39;, \u0026#39;赵云\u0026#39;, \u0026#39;马超\u0026#39;, \u0026#39;黄忠\u0026#39;] subjs = [\u0026#39;语文\u0026#39;, \u0026#39;数学\u0026#39;, \u0026#39;英语\u0026#39;] scores = [[]] * 5 for row, name in enumerate(names): print(\u0026#39;请输入%s的成绩\u0026#39; % name) scores[row] = [0] * 3 for col, subj in enumerate(subjs): scores[row][col] = float(input(subj + \u0026#39;: \u0026#39;)) print(scores) 或者\nnames = [\u0026#39;关羽\u0026#39;, \u0026#39;张飞\u0026#39;, \u0026#39;赵云\u0026#39;, \u0026#39;马超\u0026#39;, \u0026#39;黄忠\u0026#39;] subjs = [\u0026#39;语文\u0026#39;, \u0026#39;数学\u0026#39;, \u0026#39;英语\u0026#39;] scores = [[0] * 3 for _ in range(5)] for row, name in enumerate(names): print(\u0026#39;请输入%s的成绩\u0026#39; % name) scores[row] = [0] * 3 for col, subj in enumerate(subjs): scores[row][col] = float(input(subj + \u0026#39;: \u0026#39;)) print(scores) 如果对内存的使用不是很理解，可以看看PythonTutor网站上提供的代码可视化执行功能，通过可视化执行，我们可以看到内存是如何分配的，从而避免在使用嵌套列表或者复制对象时可能遇到的坑。\n坑3 - 访问修饰符的坑 用Python做过面向对象编程的人都知道，Python的类提供了两种访问控制权限，一种是公开，一种是私有（在属性或方法前加上双下划线）。而用惯了Java或C#这类编程语言的人都知道，类中的属性（数据抽象）通常都是私有的，其目的是为了将数据保护起来；而类中的方法（行为抽象）通常都是公开的，因为方法是对象向外界提供的服务。但是Python并没有从语法层面确保私有成员的私密性，因为它只是对类中所谓的私有成员进行了命名的变换，如果知道命名的规则照样可以直接访问私有成员，请看下面的代码。\nclass Student(object): def __init__(self, name, age): self.__name = name self.__age = age def __str__(self): return self.__name + \u0026#39;: \u0026#39; + str(self.__age) stu = Student(\u0026#39;骆昊\u0026#39;, 38) print(stu._Student__name) print(stu._Student__age) Python为什么要做出这样的设定呢？用一句广为流传的格言来解释这个问题：“We are all consenting adults here”（我们都是成年人）。这句话表达了很多Python程序员的一个共同观点，那就是开放比封闭要好，我们应该自己对自己的行为负责而不是从语言层面来限制对数据或方法的访问。\n所以在Python中我们实在没有必要将类中的属性或方法用双下划线开头的命名处理成私有的成员，因为这并没有任何实际的意义。如果想对属性或方法进行保护，我们建议用单下划线开头的受保护成员，虽然它也不能真正保护这些属性或方法，但是它相当于给调用者一个暗示，让调用者知道这是不应该直接访问的属性或方法，而且这样做并不影响子类去继承这些东西。\n需要提醒大家注意的是，Python类中的那些魔法方法，如__str__、__repr__等，这些方法并不是私有成员哦，虽然它们以双下划线开头，但是他们也是以双下划线结尾的，这种命名并不是私有成员的命名，这一点对初学者来说真的很坑。\n"},{"idx":11,"href":"/python100days/docs/Day01-15/01-%E5%88%9D%E8%AF%86Python/","title":"01 初识 Python","content":" 初识Python Python简介 Python的历史  1989年圣诞节：Guido von Rossum开始写Python语言的编译器。 1991年2月：第一个Python编译器（同时也是解释器）诞生，它是用C语言实现的（后面又出现了Java和C#实现的版本Jython和IronPython，以及PyPy、Brython、Pyston等其他实现），可以调用C语言的库函数。在最早的版本中，Python已经提供了对“类”，“函数”，“异常处理”等构造块的支持，同时提供了“列表”和“字典”等核心数据类型，同时支持以模块为基础来构造应用程序。 1994年1月：Python 1.0正式发布。 2000年10月16日：Python 2.0发布，增加了实现完整的垃圾回收，提供了对Unicode的支持。与此同时，Python的整个开发过程更加透明，社区对开发进度的影响逐渐扩大，生态圈开始慢慢形成。 2008年12月3日：Python 3.0发布，它并不完全兼容之前的Python代码，不过因为目前还有不少公司在项目和运维中使用Python 2.x版本，所以Python 3.x的很多新特性后来也被移植到Python 2.6\u0026frasl;2.7版本中。  目前我们使用的Python 3.7.x的版本是在2018年发布的，Python的版本号分为三段，形如A.B.C。其中A表示大版本号，一般当整体重写，或出现不向后兼容的改变时，增加A；B表示功能更新，出现新功能时增加B；C表示小的改动（例如：修复了某个Bug），只要有修改就增加C。如果对Python的历史感兴趣，可以阅读名为《Python简史》的博文。\nPython的优缺点 Python的优点很多，简单的可以总结为以下几点。\n 简单和明确，做一件事只有一种方法。 学习曲线低，跟其他很多语言相比，Python更容易上手。 开放源代码，拥有强大的社区和生态圈。 解释型语言，天生具有平台可移植性。 支持两种主流的编程范式（面向对象编程和函数式编程）都提供了支持。 可扩展性和可嵌入性，可以调用C/C++代码，也可以在C/C++中调用Python。 代码规范程度高，可读性强，适合有代码洁癖和强迫症的人群。  Python的缺点主要集中在以下几点。\n 执行效率稍低，因此计算密集型任务可以由C/C++编写。 代码无法加密，但是现在很多公司都不销售卖软件而是销售服务，这个问题会被淡化。 在开发时可以选择的框架太多（如Web框架就有100多个），有选择的地方就有错误。  Python的应用领域 目前Python在Web应用开发、云基础设施、DevOps、网络爬虫开发、数据分析挖掘、机器学习等领域都有着广泛的应用，因此也产生了Web后端开发、数据接口开发、自动化运维、自动化测试、科学计算和可视化、数据分析、量化交易、机器人开发、图像识别和处理等一系列的职位。\n搭建编程环境 Windows环境 可以在Python官方网站下载到Python的Windows安装程序（exe文件），需要注意的是如果在Windows 7环境下安装Python 3.x，需要先安装Service Pack 1补丁包（可以通过一些工具软件自动安装系统补丁的功能来安装），安装过程建议勾选“Add Python 3.x to PATH”（将Python 3.x添加到PATH环境变量）并选择自定义安装，在设置“Optional Features”界面最好将“pip”、“tcl/tk”、“Python test suite”等项全部勾选上。强烈建议选择自定义的安装路径并保证路径中没有中文。安装完成会看到“Setup was successful”的提示。如果稍后运行Python程序时，出现因为缺失一些动态链接库文件而导致Python解释器无法工作的问题，可以按照下面的方法加以解决。\n如果系统显示api-ms-win-crt*.dll文件缺失，可以参照《api-ms-win-crt*.dll缺失原因分析和解决方法》一文讲解的方法进行处理或者直接在微软官网下载Visual C++ Redistributable for Visual Studio 2015文件进行修复；如果是因为更新Windows的DirectX之后导致某些动态链接库文件缺失问题，可以下载一个DirectX修复工具进行修复。\nLinux环境 Linux环境自带了Python 2.x版本，但是如果要更新到3.x的版本，可以在Python的官方网站下载Python的源代码并通过源代码构建安装的方式进行安装，具体的步骤如下所示。\n安装依赖库（因为没有这些依赖库可能在源代码构件安装时因为缺失底层依赖库而失败）。\nyum -y install wget gcc zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel 下载Python源代码并解压缩到指定目录。\nwget https://www.python.org/ftp/python/3.7.3/Python-3.7.3.tgz xz -d Python-3.7.3.tar.xz tar -xvf Python-3.7.3.tar 切换至Python源代码目录并执行下面的命令进行配置和安装。\ncd Python-3.7.3 ./configure --prefix=/usr/local/python37 --enable-optimizations make \u0026amp;\u0026amp; make install 修改用户主目录下名为.bash_profile的文件，配置PATH环境变量并使其生效。\ncd ~ vim .bash_profile# ... 此处省略上面的代码 ... export PATH=$PATH:/usr/local/python37/bin # ... 此处省略下面的代码 ... 激活环境变量。\nsource .bash_profile macOS环境 macOS也自带了Python 2.x版本，可以通过Python的官方网站提供的安装文件（pkg文件）安装Python 3.x的版本。默认安装完成后，可以通过在终端执行python命令来启动2.x版本的Python解释器，可以通过执行python3命令来启动3.x版本的Python解释器。\n从终端运行Python程序 确认Python的版本 可以Windows的命令行提示符中键入下面的命令。\npython --version 或者是在Linux或macOS系统的终端中键入下面的命令。\npython3 --version 当然也可以先输入python或python3进入交互式环境，再执行以下的代码检查Python的版本。\nimport sys print(sys.version_info) print(sys.version) 编写Python源代码 可以用文本编辑工具（推荐使用Sublime、Atom、Visual Studio Code等高级文本编辑工具）编写Python源代码并用py作为后缀名保存该文件，代码内容如下所示。\nprint(\u0026#39;hello, world!\u0026#39;) 运行程序 切换到源代码所在的目录并执行下面的命令，看看屏幕上是否输出了\u0026rdquo;hello, world!\u0026ldquo;。\npython hello.py 或\npython3 hello.py 代码中的注释 注释是编程语言的一个重要组成部分，用于在源代码中解释代码的作用从而增强程序的可读性和可维护性，当然也可以将源代码中不需要参与运行的代码段通过注释来去掉，这一点在调试程序的时候经常用到。注释在随源代码进入预处理器或编译时会被移除，不会在目标代码中保留也不会影响程序的执行结果。\n 单行注释 - 以#和空格开头的部分 多行注释 - 三个引号开头，三个引号结尾\n\u0026#34;\u0026#34;\u0026#34; 第一个Python程序 - hello, world! 向伟大的Dennis M. Ritchie先生致敬 Version: 0.1 Author: 骆昊 \u0026#34;\u0026#34;\u0026#34; print(\u0026#39;hello, world!\u0026#39;) # print(\u0026#34;你好,世界！\u0026#34;) print(\u0026#39;你好\u0026#39;, \u0026#39;世界\u0026#39;) print(\u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;, sep=\u0026#39;, \u0026#39;, end=\u0026#39;!\u0026#39;) print(\u0026#39;goodbye, world\u0026#39;, end=\u0026#39;!\\n\u0026#39;)  其他工具介绍 IDLE - 自带的集成开发工具 IDLE是安装Python环境时自带的集成开发工具，如下图所示。但是由于IDLE的用户体验并不是那么好所以很少在实际开发中被采用。\nIPython - 更好的交互式编程工具 IPython是一种基于Python的交互式解释器。相较于原生的Python交互式环境，IPython提供了更为强大的编辑和交互功能。可以通过Python的包管理工具pip安装IPython和Jupyter，具体的操作如下所示。\npip install ipython 或\npip3 install ipython 安装成功后，可以通过下面的ipython命令启动IPython，如下图所示。\n当然，我们也可以通过安装Jupyter工具并运行名为notebook的程序在浏览器窗口中进行交互式代码编写操作。\npip install jupyter 或\npip3 intall jupyter 然后执行下面的命令：\njupyter notebook Sublime / Visual Studio Code - 高级文本编辑器  首先可以通过官方网站下载安装程序安装Sublime 3或Sublime 2。\n 安装包管理工具。\n 通过快捷键Ctrl+`或者在View菜单中选择Show Console打开控制台，输入下面的代码。   Sublime 3\nimport urllib.request,os;pf=\u0026#39;Package Control.sublime-package\u0026#39;;ipp=sublime.installed_packages_path();urllib.request.install_opener(urllib.request.build_opener(urllib.request.ProxyHandler()));open(os.path.join(ipp,pf),\u0026#39;wb\u0026#39;).write(urllib.request.urlopen(\u0026#39;http://sublime.wbond.net/\u0026#39;+pf.replace(\u0026#39; \u0026#39;,\u0026#39;%20\u0026#39;)).read()) Sublime 2\nimport urllib2,os;pf=\u0026#39;Package Control.sublime-package\u0026#39;;ipp=sublime.installed_packages_path();os.makedirs(ipp)ifnotos.path.exists(ipp)elseNone;urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler()));open(os.path.join(ipp,pf),\u0026#39;wb\u0026#39;).write(urllib2.urlopen(\u0026#39;http://sublime.wbond.net/\u0026#39;+pf.replace(\u0026#39; \u0026#39;,\u0026#39;%20\u0026#39;)).read());print(\u0026#39;Please restart Sublime Text to finish installation\u0026#39;)   手动安装浏览器输入 https://sublime.wbond.net/Package%20Control.sublime-package 下载这个文件 下载好以后，打开sublime text，选择菜单Preferences-\u0026gt;Browse Packages\u0026hellip; 打开安装目录 此时会进入到一个叫做Packages的目录下，点击进入上一层目录Sublime Text3，在此目录下有一个文件夹叫做Installed Packages，把刚才下载的文件放到这里就可以了。然后重启sublime text3，观察Preferences菜单最下边是否有Package Settings 和Package Control两个选项，如果有，则代表安装成功了。  安装插件。通过Preference菜单的Package Control或快捷键Ctrl+Shift+P打开命令面板，在面板中输入Install Package就可以找到安装插件的工具，然后再查找需要的插件。我们推荐大家安装以下几个插件：\n SublimeCodeIntel - 代码自动补全工具插件。 Emmet - 前端开发代码模板插件。 Git - 版本控制工具插件。 Python PEP8 Autoformat - PEP8规范自动格式化插件。 ConvertToUTF8 - 将本地编码转换为UTF-8。    说明：事实上Visual Studio Code可能是更好的选择，它不用花钱并提供了更为完整和强大的功能，有兴趣的读者可以自行研究。\n PyCharm - Python开发神器 PyCharm的安装、配置和使用在《玩转PyCharm》进行了介绍，有兴趣的读者可以选择阅读。\n练习  在Python交互环境中查看下面的代码结果，并试着将这些内容翻译成中文。\nimport this  说明：当前键入上面的命令后会在交互式环境中看到如下所示的输出，这段内容被称为“Python之禅”，里面讲述的道理不仅仅适用于Python，也适用于其他编程语言。\n 学习使用turtle在屏幕上绘制图形。\n 说明：turtle是Python内置的一个非常有趣的模块，特别适用于让小朋友体会什么是编程，它最早是Logo语言的一部分，Logo语言是Wally Feurzig和Seymour Papert在1966发明的编程语言.\n import turtle turtle.pensize(4) turtle.pencolor(\u0026#39;red\u0026#39;) turtle.forward(100) turtle.right(90) turtle.forward(100) turtle.right(90) turtle.forward(100) turtle.right(90) turtle.forward(100) turtle.mainloop()  "},{"idx":12,"href":"/python100days/docs/Day01-15/02-%E8%AF%AD%E8%A8%80%E5%85%83%E7%B4%A0/","title":"02 语言元素","content":" 语言元素 指令和程序 计算机的硬件系统通常由五大部件构成，包括：运算器、控制器、存储器、输入设备和输出设备。其中，运算器和控制器放在一起就是我们通常所说的中央处理器，它的功能是执行各种运算和控制指令以及处理计算机软件中的数据。我们通常所说的程序实际上就是指令的集合，我们程序就是将一系列的指令按照某种方式组织到一起，然后通过这些指令去控制计算机做我们想让它做的事情。今天我们大多数时候使用的计算机，虽然它们的元器件做工越来越精密，处理能力越来越强大，但究其本质来说仍然属于“冯·诺依曼结构”的计算机。“冯·诺依曼结构”有两个关键点，一是指出要将存储设备与中央处理器分开，二是提出了将数据以二进制方式编码。二进制是一种“逢二进一”的计数法，跟我们人类使用的“逢十进一”的计数法没有实质性的区别，人类因为有十根手指所以使用了十进制（因为在数数时十根手指用完之后就只能进位了，当然凡事都有例外，玛雅人可能是因为长年光着脚的原因把脚趾头也算上了，于是他们使用了二十进制的计数法，在这种计数法的指导下玛雅人的历法就与我们平常使用的历法不一样，而按照玛雅人的历法，2012年是上一个所谓的“太阳纪”的最后一年，而2013年则是新的“太阳纪”的开始，后来这件事情被以讹传讹的方式误传为”2012年是玛雅人预言的世界末日“这种荒诞的说法，今天我们可以大胆的猜测，玛雅文明之所以发展缓慢估计也与使用了二十进制有关）。对于计算机来说，二进制在物理器件上来说是最容易实现的（高电压表示1，低电压表示0），于是在“冯·诺依曼结构”的计算机都使用了二进制。虽然我们并不需要每个程序员都能够使用二进制的思维方式来工作，但是了解二进制以及它与我们生活中的十进制之间的转换关系，以及二进制与八进制和十六进制的转换关系还是有必要的。如果你对这一点不熟悉，可以自行使用维基百科或者百度百科科普一下。\n 提示：近期关于量子计算机的研究已经被推倒了风口浪尖，量子计算机基于量子力学进行运算，使用量子瞬移的方式来传递信息。2018年6月，Intel宣布开发出新款量子芯片并通过了在接近绝对零度环境下的测试；2019年1月，IBM向全世界发布了首款商业化量子计算机。\n 变量和类型 在程序设计中，变量是一种存储数据的载体。计算机中的变量是实际存在的数据或者说是存储器中存储数据的一块内存空间，变量的值可以被读取和修改，这是所有计算和控制的基础。计算机能处理的数据有很多种类型，除了数值之外还可以处理文本、图形、音频、视频等各种各样的数据，那么不同的数据就需要定义不同的存储类型。Python中的数据类型很多，而且也允许我们自定义新的数据类型（这一点在后面会讲到），我们先介绍几种常用的数据类型。\n 整型：Python中可以处理任意大小的整数（Python 2.x中有int和long两种类型的整数，但这种区分对Python来说意义不大，因此在Python 3.x中整数只有int这一种了），而且支持二进制（如0b100，换算成十进制是4）、八进制（如0o100，换算成十进制是64）、十进制（100）和十六进制（0x100，换算成十进制是256）的表示法。 浮点型：浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，浮点数除了数学写法（如123.456）之外还支持科学计数法（如1.23456e2）。 字符串型：字符串是以单引号或双引号括起来的任意文本，比如'hello'和\u0026quot;hello\u0026quot;,字符串还有原始字符串表示法、字节字符串表示法、Unicode字符串表示法，而且可以书写成多行的形式（用三个单引号或三个双引号开头，三个单引号或三个双引号结尾）。 布尔型：布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来（例如3 \u0026lt; 5会产生布尔值True，而2 == 1会产生布尔值False）。 复数型：形如3+5j，跟数学上的复数表示一样，唯一不同的是虚部的i换成了j。  变量命名 对于每个变量我们需要给它取一个名字，就如同我们每个人都有属于自己的响亮的名字一样。在Python中，变量命名需要遵循以下这些必须遵守硬性规则和强烈建议遵守的非硬性规则。\n 硬性规则：  变量名由字母（广义的Unicode字符，不包括特殊字符）、数字和下划线构成，数字不能开头。 大小写敏感（大写的a和小写的A是两个不同的变量）。 不要跟关键字（有特殊含义的单词，后面会讲到）和系统保留字（如函数、模块等的名字）冲突。  PEP 8要求：  用小写字母拼写，多个单词用下划线连接。 受保护的实例属性用单个下划线开头（后面会讲到）。 私有的实例属性用两个下划线开头（后面会讲到）。   当然，作为一个专业的程序员，给变量（事实上应该是所有的标识符）命名时做到见名知意也是非常重要的。\n变量的使用 下面通过几个例子来说明变量的类型和变量使用。\n\u0026#34;\u0026#34;\u0026#34; 使用变量保存数据并进行算术运算 Version: 0.1 Author: 骆昊 \u0026#34;\u0026#34;\u0026#34; a = 321 b = 123 print(a + b) print(a - b) print(a * b) print(a / b) print(a // b) print(a % b) print(a ** b)\u0026#34;\u0026#34;\u0026#34; 使用input()函数获取键盘输入 使用int()进行类型转换 用占位符格式化输出的字符串 Version: 0.1 Author: 骆昊 \u0026#34;\u0026#34;\u0026#34; a = int(input(\u0026#39;a = \u0026#39;)) b = int(input(\u0026#39;b = \u0026#39;)) print(\u0026#39;%d+ %d= %d\u0026#39; % (a, b, a + b)) print(\u0026#39;%d- %d= %d\u0026#39; % (a, b, a - b)) print(\u0026#39;%d* %d= %d\u0026#39; % (a, b, a * b)) print(\u0026#39;%d/ %d= %f\u0026#39; % (a, b, a / b)) print(\u0026#39;%d// %d= %d\u0026#39; % (a, b, a // b)) print(\u0026#39;%d%%%d= %d\u0026#39; % (a, b, a % b)) print(\u0026#39;%d** %d= %d\u0026#39; % (a, b, a ** b))\u0026#34;\u0026#34;\u0026#34; 使用type()检查变量的类型 Version: 0.1 Author: 骆昊 Date: 2018-02-27 \u0026#34;\u0026#34;\u0026#34; a = 100 b = 12.345 c = 1 + 5j d = \u0026#39;hello, world\u0026#39; e = True print(type(a)) print(type(b)) print(type(c)) print(type(d)) print(type(e)) 在对变量类型进行转换时可以使用Python的内置函数（准确的说下面列出的并不是真正意义上的函数，而是后面我们要讲到的创建对象的构造方法）。\n int()：将一个数值或字符串转换成整数，可以指定进制。 float()：将一个字符串转换成浮点数。 str()：将指定的对象转换成字符串形式，可以指定编码。 chr()：将整数转换成该编码对应的字符串（一个字符）。 ord()：将字符串（一个字符）转换成对应的编码（整数）。  运算符 Python支持多种运算符，下表大致按照优先级从高到低的顺序列出了所有的运算符，我们会陆续使用到它们。\n   运算符 描述     [] [:] 下标，切片   ** 指数   ~ + - 按位取反, 正负号   * / % // 乘，除，模，整除   + - 加，减   \u0026gt;\u0026gt; \u0026lt;\u0026lt; 右移，左移   \u0026amp; 按位与   ^ \\| 按位异或，按位或   \u0026lt;= \u0026lt; \u0026gt; \u0026gt;= 小于等于，小于，大于，大于等于   == != 等于，不等于   is is not 身份运算符   in not in 成员运算符   not or and 逻辑运算符   = += -= *= /= %= //= **= \u0026amp;= ` =^=\u0026gt;\u0026gt;=\u0026lt;\u0026lt;=`     说明： 在实际开发中，如果搞不清楚运算符的优先级，可以使用括号来确保运算的执行顺序。\n 下面的例子演示了运算符的使用。\n\u0026#34;\u0026#34;\u0026#34; 运算符的使用 Version: 0.1 Author: 骆昊 \u0026#34;\u0026#34;\u0026#34; a = 5 b = 10 c = 3 d = 4 e = 5 a += b a -= c a *= d a /= e print(\u0026#34;a = \u0026#34;, a) flag1 = 3 \u0026gt; 2 flag2 = 2 \u0026lt; 1 flag3 = flag1 and flag2 flag4 = flag1 or flag2 flag5 = not flag1 print(\u0026#34;flag1 = \u0026#34;, flag1) print(\u0026#34;flag2 = \u0026#34;, flag2) print(\u0026#34;flag3 = \u0026#34;, flag3) print(\u0026#34;flag4 = \u0026#34;, flag4) print(\u0026#34;flag5 = \u0026#34;, flag5) print(flag1 is True) print(flag2 is not False) 练习 练习1：华氏温度转摄氏温度。 \u0026#34;\u0026#34;\u0026#34; 将华氏温度转换为摄氏温度 F = 1.8C + 32 Version: 0.1 Author: 骆昊 \u0026#34;\u0026#34;\u0026#34; f = float(input(\u0026#39;请输入华氏温度: \u0026#39;)) c = (f - 32) / 1.8 print(\u0026#39;%.1f华氏度 = %.1f摄氏度\u0026#39; % (f, c)) 练习2：输入圆的半径计算计算周长和面积。 \u0026#34;\u0026#34;\u0026#34; 输入半径计算圆的周长和面积 Version: 0.1 Author: 骆昊 \u0026#34;\u0026#34;\u0026#34; import math radius = float(input(\u0026#39;请输入圆的半径: \u0026#39;)) perimeter = 2 * math.pi * radius area = math.pi * radius * radius print(\u0026#39;周长: %.2f\u0026#39; % perimeter) print(\u0026#39;面积: %.2f\u0026#39; % area) 练习3：输入年份判断是不是闰年。 \u0026#34;\u0026#34;\u0026#34; 输入年份 如果是闰年输出True 否则输出False Version: 0.1 Author: 骆昊 \u0026#34;\u0026#34;\u0026#34; year = int(input(\u0026#39;请输入年份: \u0026#39;)) # 如果代码太长写成一行不便于阅读 可以使用\\或()折行 is_leap = (year % 4 == 0 and year % 100 != 0 or year % 400 == 0) print(is_leap)"},{"idx":13,"href":"/python100days/docs/Day01-15/03-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/","title":"03 分支结构","content":" 分支结构 应用场景 迄今为止，我们写的Python代码都是一条一条语句顺序执行，这种代码结构通常称之为顺序结构。然而仅有顺序结构并不能解决所有的问题，比如我们设计一个游戏，游戏第一关的通关条件是玩家获得1000分，那么在完成本局游戏后，我们要根据玩家得到分数来决定究竟是进入第二关，还是告诉玩家“Game Over”，这里就会产生两个分支，而且这两个分支只有一个会被执行。类似的场景还有很多，我们将这种结构称之为“分支结构”或“选择结构”。给大家一分钟的时间，你应该可以想到至少5个以上这样的例子，赶紧试一试。\nif语句的使用 在Python中，要构造分支结构可以使用if、elif和else关键字。所谓关键字就是有特殊含义的单词，像if和else就是专门用于构造分支结构的关键字，很显然你不能够使用它作为变量名（事实上，用作其他的标识符也是不可以）。下面的例子中演示了如何构造一个分支结构。\n\u0026#34;\u0026#34;\u0026#34; 用户身份验证 Version: 0.1 Author: 骆昊 \u0026#34;\u0026#34;\u0026#34; username = input(\u0026#39;请输入用户名: \u0026#39;) password = input(\u0026#39;请输入口令: \u0026#39;) # 如果希望输入口令时 终端中没有回显 可以使用getpass模块的getpass函数 # import getpass # password = getpass.getpass(\u0026#39;请输入口令: \u0026#39;) if username == \u0026#39;admin\u0026#39; and password == \u0026#39;123456\u0026#39;: print(\u0026#39;身份验证成功!\u0026#39;) else: print(\u0026#39;身份验证失败!\u0026#39;) 唯一需要说明的是和C/C++、Java等语言不同，Python中没有用花括号来构造代码块而是使用了缩进的方式来设置代码的层次结构，如果if条件成立的情况下需要执行多条语句，只要保持多条语句具有相同的缩进就可以了，换句话说连续的代码如果又保持了相同的缩进那么它们属于同一个代码块，相当于是一个执行的整体。\n当然如果要构造出更多的分支，可以使用if…elif…else…结构，例如下面的分段函数求值。\n\u0026#34;\u0026#34;\u0026#34; 分段函数求值 3x - 5 (x \u0026gt; 1) f(x) = x + 2 (-1 \u0026lt;= x \u0026lt;= 1) 5x + 3 (x \u0026lt; -1) Version: 0.1 Author: 骆昊 \u0026#34;\u0026#34;\u0026#34; x = float(input(\u0026#39;x = \u0026#39;)) if x \u0026gt; 1: y = 3 * x - 5 elif x \u0026gt;= -1: y = x + 2 else: y = 5 * x + 3 print(\u0026#39;f(%.2f) = %.2f\u0026#39; % (x, y)) 当然根据实际开发的需要，分支结构是可以嵌套的，例如判断是否通关以后还要根据你获得的宝物或者道具的数量对你的表现给出等级（比如点亮两颗或三颗星星），那么我们就需要在if的内部构造出一个新的分支结构，同理elif和else中也可以再构造新的分支，我们称之为嵌套的分支结构，也就是说上面的代码也可以写成下面的样子。\n\u0026#34;\u0026#34;\u0026#34; 分段函数求值 3x - 5\t(x \u0026gt; 1) f(x) =\tx + 2\t(-1 \u0026lt;= x \u0026lt;= 1) 5x + 3\t(x \u0026lt; -1) Version: 0.1 Author: 骆昊 \u0026#34;\u0026#34;\u0026#34; x = float(input(\u0026#39;x = \u0026#39;)) if x \u0026gt; 1: y = 3 * x - 5 else: if x \u0026gt;= -1: y = x + 2 else: y = 5 * x + 3 print(\u0026#39;f(%.2f) = %.2f\u0026#39; % (x, y))  说明： 大家可以自己感受一下这两种写法到底是哪一种更好。在之前我们提到的Python之禅中有这么一句话“Flat is better than nested.”，之所以提倡代码“扁平化”是因为嵌套结构的嵌套层次多了之后会严重的影响代码的可读性，所以能使用扁平化的结构时就不要使用嵌套。\n 练习 练习1：英制单位与公制单位互换 \u0026#34;\u0026#34;\u0026#34; 英制单位英寸和公制单位厘米互换 Version: 0.1 Author: 骆昊 \u0026#34;\u0026#34;\u0026#34; value = float(input(\u0026#39;请输入长度: \u0026#39;)) unit = input(\u0026#39;请输入单位: \u0026#39;) if unit == \u0026#39;in\u0026#39; or unit == \u0026#39;英寸\u0026#39;: print(\u0026#39;%f英寸 = %f厘米\u0026#39; % (value, value * 2.54)) elif unit == \u0026#39;cm\u0026#39; or unit == \u0026#39;厘米\u0026#39;: print(\u0026#39;%f厘米 = %f英寸\u0026#39; % (value, value / 2.54)) else: print(\u0026#39;请输入有效的单位\u0026#39;) 练习2：掷骰子决定做什么 \u0026#34;\u0026#34;\u0026#34; 掷骰子决定做什么事情 Version: 0.1 Author: 骆昊 \u0026#34;\u0026#34;\u0026#34; from random import randint face = randint(1, 6) if face == 1: result = \u0026#39;唱首歌\u0026#39; elif face == 2: result = \u0026#39;跳个舞\u0026#39; elif face == 3: result = \u0026#39;学狗叫\u0026#39; elif face == 4: result = \u0026#39;做俯卧撑\u0026#39; elif face == 5: result = \u0026#39;念绕口令\u0026#39; else: result = \u0026#39;讲冷笑话\u0026#39; print(result)  说明： 上面的代码中使用了random模块的randint函数生成指定范围的随机数来模拟掷骰子。\n 练习3：百分制成绩转等级制 \u0026#34;\u0026#34;\u0026#34; 百分制成绩转等级制成绩 90分以上 --\u0026gt; A 80分~89分 --\u0026gt; B 70分~79分\t--\u0026gt; C 60分~69分 --\u0026gt; D 60分以下 --\u0026gt; E Version: 0.1 Author: 骆昊 \u0026#34;\u0026#34;\u0026#34; score = float(input(\u0026#39;请输入成绩: \u0026#39;)) if score \u0026gt;= 90: grade = \u0026#39;A\u0026#39; elif score \u0026gt;= 80: grade = \u0026#39;B\u0026#39; elif score \u0026gt;= 70: grade = \u0026#39;C\u0026#39; elif score \u0026gt;= 60: grade = \u0026#39;D\u0026#39; else: grade = \u0026#39;E\u0026#39; print(\u0026#39;对应的等级是:\u0026#39;, grade) 练习4：输入三条边长如果能构成三角形就计算周长和面积 \u0026#34;\u0026#34;\u0026#34; 判断输入的边长能否构成三角形 如果能则计算出三角形的周长和面积 Version: 0.1 Author: 骆昊 \u0026#34;\u0026#34;\u0026#34; import math a = float(input(\u0026#39;a = \u0026#39;)) b = float(input(\u0026#39;b = \u0026#39;)) c = float(input(\u0026#39;c = \u0026#39;)) if a + b \u0026gt; c and a + c \u0026gt; b and b + c \u0026gt; a: print(\u0026#39;周长: %f\u0026#39; % (a + b + c)) p = (a + b + c) / 2 area = math.sqrt(p * (p - a) * (p - b) * (p - c)) print(\u0026#39;面积: %f\u0026#39; % (area)) else: print(\u0026#39;不能构成三角形\u0026#39;)  说明： 上面的代码中使用了math模块的sqrt函数来计算平方根。用边长计算三角形面积的公式叫做海伦公式。\n 练习5：个人所得税计算器。 \u0026#34;\u0026#34;\u0026#34; 输入月收入和五险一金计算个人所得税 Version: 0.1 Author: 骆昊 \u0026#34;\u0026#34;\u0026#34; salary = float(input(\u0026#39;本月收入: \u0026#39;)) insurance = float(input(\u0026#39;五险一金: \u0026#39;)) diff = salary - insurance - 3500 if diff \u0026lt;= 0: rate = 0 deduction = 0 elif diff \u0026lt; 1500: rate = 0.03 deduction = 0 elif diff \u0026lt; 4500: rate = 0.1 deduction = 105 elif diff \u0026lt; 9000: rate = 0.2 deduction = 555 elif diff \u0026lt; 35000: rate = 0.25 deduction = 1005 elif diff \u0026lt; 55000: rate = 0.3 deduction = 2755 elif diff \u0026lt; 80000: rate = 0.35 deduction = 5505 else: rate = 0.45 deduction = 13505 tax = abs(diff * rate - deduction) print(\u0026#39;个人所得税: ￥%.2f元\u0026#39; % tax) print(\u0026#39;实际到手收入: ￥%.2f元\u0026#39; % (diff + 3500 - tax))  说明： 上面的代码中使用了Python内置的abs()函数取绝对值来处理-0的问题。\n "},{"idx":14,"href":"/python100days/docs/Day01-15/04-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/","title":"04 循环结构","content":" 循环结构 应用场景 如果在程序中我们需要重复的执行某条或某些指令，例如用程序控制机器人踢足球，如果机器人持球而且还没有进入射门范围，那么我们就要一直发出让机器人向球门方向奔跑的指令。当然你可能已经注意到了，刚才的描述中其实不仅仅有需要重复的动作，还有我们上一个章节讲到的分支结构。再举一个简单的例子，比如在我们的程序中要实现每隔1秒中在屏幕上打印一个\u0026quot;hello, world\u0026quot;这样的字符串并持续一个小时，我们肯定不能够将print('hello, world')这句代码写上3600遍，如果真的需要这样做，那么编程的工作就太无聊了。因此，我们还需要了解一下循环结构，有了循环结构我们就可以轻松的控制某件事或者某些事重复、重复、再重复的去执行。\n在Python中构造循环结构有两种做法，一种是for-in循环，一种是while循环。\nfor-in循环 如果明确的知道循环执行的次数或者要对一个容器进行迭代（后面会讲到），那么我们推荐使用for-in循环，例如下面代码中计算1~100求和的结果（$\\displaystyle \\sum \\limits_{n=1}^{100}n$）。\n\u0026#34;\u0026#34;\u0026#34; 用for循环实现1~100求和 Version: 0.1 Author: 骆昊 \u0026#34;\u0026#34;\u0026#34; sum = 0 for x in range(101): sum += x print(sum) 需要说明的是上面代码中的range类型，range可以用来产生一个不变的数值序列，而且这个序列通常都是用在循环中的，例如：\n range(101)可以产生一个0到100的整数序列。 range(1, 100)可以产生一个1到99的整数序列。 range(1, 100, 2)可以产生一个1到99的奇数序列，其中的2是步长，即数值序列的增量。  知道了这一点，我们可以用下面的代码来实现1~100之间的偶数求和。\n\u0026#34;\u0026#34;\u0026#34; 用for循环实现1~100之间的偶数求和 Version: 0.1 Author: 骆昊 \u0026#34;\u0026#34;\u0026#34; sum = 0 for x in range(2, 101, 2): sum += x print(sum) 也可以通过在循环中使用分支结构的方式来实现相同的功能，代码如下所示。\n\u0026#34;\u0026#34;\u0026#34; 用for循环实现1~100之间的偶数求和 Version: 0.1 Author: 骆昊 \u0026#34;\u0026#34;\u0026#34; sum = 0 for x in range(1, 101): if x % 2 == 0: sum += x print(sum) while循环 如果要构造不知道具体循环次数的循环结构，我们推荐使用while循环。while循环通过一个能够产生或转换出bool值的表达式来控制循环，表达式的值为True循环继续，表达式的值为False循环结束。下面我们通过一个“猜数字”的小游戏（计算机出一个1~100之间的随机数，人输入自己猜的数字，计算机给出对应的提示信息，直到人猜出计算机出的数字）来看看如何使用while循环。\n\u0026#34;\u0026#34;\u0026#34; 猜数字游戏 计算机出一个1~100之间的随机数由人来猜 计算机根据人猜的数字分别给出提示大一点/小一点/猜对了 Version: 0.1 Author: 骆昊 \u0026#34;\u0026#34;\u0026#34; import random answer = random.randint(1, 100) counter = 0 while True: counter += 1 number = int(input(\u0026#39;请输入: \u0026#39;)) if number \u0026lt; answer: print(\u0026#39;大一点\u0026#39;) elif number \u0026gt; answer: print(\u0026#39;小一点\u0026#39;) else: print(\u0026#39;恭喜你猜对了!\u0026#39;) break print(\u0026#39;你总共猜了%d次\u0026#39; % counter) if counter \u0026gt; 7: print(\u0026#39;你的智商余额明显不足\u0026#39;)  说明： 上面的代码中使用了break关键字来提前终止循环，需要注意的是break只能终止它所在的那个循环，这一点在使用嵌套的循环结构（下面会讲到）需要引起注意。除了break之外，还有另一个关键字是continue，它可以用来放弃本次循环后续的代码直接让循环进入下一轮。\n 和分支结构一样，循环结构也是可以嵌套的，也就是说在循环中还可以构造循环结构。下面的例子演示了如何通过嵌套的循环来输出一个九九乘法表。\n\u0026#34;\u0026#34;\u0026#34; 输出乘法口诀表(九九表) Version: 0.1 Author: 骆昊 \u0026#34;\u0026#34;\u0026#34; for i in range(1, 10): for j in range(1, i + 1): print(\u0026#39;%d*%d=%d\u0026#39; % (i, j, i * j), end=\u0026#39;\\t\u0026#39;) print() 练习 练习1：输入一个数判断是不是素数。 \u0026#34;\u0026#34;\u0026#34; 输入一个正整数判断它是不是素数 Version: 0.1 Author: 骆昊 Date: 2018-03-01 \u0026#34;\u0026#34;\u0026#34; from math import sqrt num = int(input(\u0026#39;请输入一个正整数: \u0026#39;)) end = int(sqrt(num)) is_prime = True for x in range(2, end + 1): if num % x == 0: is_prime = False break if is_prime and num != 1: print(\u0026#39;%d是素数\u0026#39; % num) else: print(\u0026#39;%d不是素数\u0026#39; % num) 练习2：输入两个正整数，计算最大公约数和最小公倍数。 \u0026#34;\u0026#34;\u0026#34; 输入两个正整数计算最大公约数和最小公倍数 Version: 0.1 Author: 骆昊 Date: 2018-03-01 \u0026#34;\u0026#34;\u0026#34; x = int(input(\u0026#39;x = \u0026#39;)) y = int(input(\u0026#39;y = \u0026#39;)) if x \u0026gt; y: x, y = y, x for factor in range(x, 0, -1): if x % factor == 0 and y % factor == 0: print(\u0026#39;%d和%d的最大公约数是%d\u0026#39; % (x, y, factor)) print(\u0026#39;%d和%d的最小公倍数是%d\u0026#39; % (x, y, x * y // factor)) break 练习3：打印三角形图案。 \u0026#34;\u0026#34;\u0026#34; 打印各种三角形图案 * ** *** **** ***** * ** *** **** ***** * *** ***** ******* ********* Version: 0.1 Author: 骆昊 \u0026#34;\u0026#34;\u0026#34; row = int(input(\u0026#39;请输入行数: \u0026#39;)) for i in range(row): for _ in range(i + 1): print(\u0026#39;*\u0026#39;, end=\u0026#39;\u0026#39;) print() for i in range(row): for j in range(row): if j \u0026lt; row - i - 1: print(\u0026#39; \u0026#39;, end=\u0026#39;\u0026#39;) else: print(\u0026#39;*\u0026#39;, end=\u0026#39;\u0026#39;) print() for i in range(row): for _ in range(row - i - 1): print(\u0026#39; \u0026#39;, end=\u0026#39;\u0026#39;) for _ in range(2 * i + 1): print(\u0026#39;*\u0026#39;, end=\u0026#39;\u0026#39;) print()"},{"idx":15,"href":"/python100days/docs/Day01-15/05-%E6%9E%84%E9%80%A0%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91/","title":"05 构造程序逻辑","content":" 构造程序逻辑 分支和循环结构会帮助我们将程序中逻辑建立起来，将来我们的程序无论简单复杂，都是由顺序结构、分支结构、循环结构构成的。对于编程语言的初学者来说，首先要锻炼的是将人类自然语言描述的解决问题的步骤和方法翻译成代码的能力，其次就是熟练的运用之前学过的运算符、表达式以及最近的两个章节讲解的分支结构和循环结构的知识。有了这些基本的能力才能够通过计算机程序去解决各种各样的现实问题。所以，开始做练习吧！\n练习清单  寻找“水仙花数”。 寻找“完美数”。 “百钱百鸡”问题。 生成“斐波拉切数列”。 Craps赌博游戏。   提示：练习的参考答案在code/Day05目录下。\n "},{"idx":16,"href":"/python100days/docs/Day01-15/06-%E5%87%BD%E6%95%B0%E5%92%8C%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"06 函数和模块的使用","content":" 函数和模块的使用 在讲解本章节的内容之前，我们先来研究一道数学题，请说出下面的方程有多少组正整数解。\n事实上，上面的问题等同于将8个苹果分成四组每组至少一个苹果有多少种方案。想到这一点问题的答案就呼之欲出了。\n可以用Python的程序来计算出这个值，代码如下所示。\n\u0026#34;\u0026#34;\u0026#34; 输入M和N计算C(M,N) \u0026#34;\u0026#34;\u0026#34; m = int(input(\u0026#39;m = \u0026#39;)) n = int(input(\u0026#39;n = \u0026#39;)) fm = 1 for num in range(1, m + 1): fm *= num fn = 1 for num in range(1, n + 1): fn *= num fmn = 1 for num in range(1, m - n + 1): fmn *= num print(fm // fn // fmn) 函数的作用 不知道大家是否注意到，在上面的代码中，我们做了3次求阶乘，这样的代码实际上就是重复代码。编程大师*Martin Fowler*先生曾经说过：“代码有很多种坏味道，重复是最坏的一种！”，要写出高质量的代码首先要解决的就是重复代码的问题。对于上面的代码来说，我们可以将计算阶乘的功能封装到一个称之为“函数”的功能模块中，在需要计算阶乘的地方，我们只需要“调用”这个“函数”就可以了。\n定义函数 在Python中可以使用def关键字来定义函数，和变量一样每个函数也有一个响亮的名字，而且命名规则跟变量的命名规则是一致的。在函数名后面的圆括号中可以放置传递给函数的参数，这一点和数学上的函数非常相似，程序中函数的参数就相当于是数学上说的函数的自变量，而函数执行完成后我们可以通过return关键字来返回一个值，这相当于数学上说的函数的因变量。\n在了解了如何定义函数后，我们可以对上面的代码进行重构，所谓重构就是在不影响代码执行结果的前提下对代码的结构进行调整，重构之后的代码如下所示。\ndef factorial(num): \u0026#34;\u0026#34;\u0026#34; 求阶乘 :param num: 非负整数 :return: num的阶乘 \u0026#34;\u0026#34;\u0026#34; result = 1 for n in range(1, num + 1): result *= n return result m = int(input(\u0026#39;m = \u0026#39;)) n = int(input(\u0026#39;n = \u0026#39;)) # 当需要计算阶乘的时候不用再写循环求阶乘而是直接调用已经定义好的函数 print(factorial(m) // factorial(n) // factorial(m - n))  说明： Python的math模块中其实已经有一个factorial函数了，事实上要计算阶乘可以直接使用这个现成的函数而不用自己定义。下面例子中的某些函数其实Python中也是内置了，我们这里是为了讲解函数的定义和使用才把它们又实现了一遍，实际开发中不建议做这种低级的重复性的工作。\n 函数的参数 函数是绝大多数编程语言中都支持的一个代码的“构建块”，但是Python中的函数与其他语言中的函数还是有很多不太相同的地方，其中一个显著的区别就是Python对函数参数的处理。在Python中，函数的参数可以有默认值，也支持使用可变参数，所以Python并不需要像其他语言一样支持函数的重载，因为我们在定义一个函数的时候可以让它有多种不同的使用方式，下面是两个小例子。\nfrom random import randint def roll_dice(n=2): \u0026#34;\u0026#34;\u0026#34; 摇色子 :param n: 色子的个数 :return: n颗色子点数之和 \u0026#34;\u0026#34;\u0026#34; total = 0 for _ in range(n): total += randint(1, 6) return total def add(a=0, b=0, c=0): return a + b + c # 如果没有指定参数那么使用默认值摇两颗色子 print(roll_dice()) # 摇三颗色子 print(roll_dice(3)) print(add()) print(add(1)) print(add(1, 2)) print(add(1, 2, 3)) # 传递参数时可以不按照设定的顺序进行传递 print(add(c=50, a=100, b=200)) 我们给上面两个函数的参数都设定了默认值，这也就意味着如果在调用函数的时候如果没有传入对应参数的值时将使用该参数的默认值，所以在上面的代码中我们可以用各种不同的方式去调用add函数，这跟其他很多语言中函数重载的效果是一致的。\n其实上面的add函数还有更好的实现方案，因为我们可能会对0个或多个参数进行加法运算，而具体有多少个参数是由调用者来决定，我们作为函数的设计者对这一点是一无所知的，因此在不确定参数个数的时候，我们可以使用可变参数，代码如下所示。\n# 在参数名前面的*表示args是一个可变参数 # 即在调用add函数时可以传入0个或多个参数 def add(*args): total = 0 for val in args: total += val return total print(add()) print(add(1)) print(add(1, 2)) print(add(1, 2, 3)) print(add(1, 3, 5, 7, 9)) 用模块管理函数 对于任何一种编程语言来说，给变量、函数这样的标识符起名字都是一个让人头疼的问题，因为我们会遇到命名冲突这种尴尬的情况。最简单的场景就是在同一个.py文件中定义了两个同名函数，由于Python没有函数重载的概念，那么后面的定义会覆盖之前的定义，也就意味着两个函数同名函数实际上只有一个是存在的。\ndef foo(): print(\u0026#39;hello, world!\u0026#39;) def foo(): print(\u0026#39;goodbye, world!\u0026#39;) # 下面的代码会输出什么呢？ foo() 当然上面的这种情况我们很容易就能避免，但是如果项目是由多人协作进行团队开发的时候，团队中可能有多个程序员都定义了名为foo的函数，那么怎么解决这种命名冲突呢？答案其实很简单，Python中每个文件就代表了一个模块（module），我们在不同的模块中可以有同名的函数，在使用函数的时候我们通过import关键字导入指定的模块就可以区分到底要使用的是哪个模块中的foo函数，代码如下所示。\nmodule1.py\ndef foo(): print(\u0026#39;hello, world!\u0026#39;) module2.py\ndef foo(): print(\u0026#39;goodbye, world!\u0026#39;) test.py\nfrom module1 import foo # 输出hello, world! foo() from module2 import foo # 输出goodbye, world! foo() 也可以按照如下所示的方式来区分到底要使用哪一个foo函数。\ntest.py\nimport module1 as m1 import module2 as m2 m1.foo() m2.foo() 但是如果将代码写成了下面的样子，那么程序中调用的是最后导入的那个foo，因为后导入的foo覆盖了之前导入的foo。\ntest.py\nfrom module1 import foo from module2 import foo # 输出goodbye, world! foo() test.py\nfrom module2 import foo from module1 import foo # 输出hello, world! foo() 需要说明的是，如果我们导入的模块除了定义函数之外还中有可以执行代码，那么Python解释器在导入这个模块时就会执行这些代码，事实上我们可能并不希望如此，因此如果我们在模块中编写了执行代码，最好是将这些执行代码放入如下所示的条件中，这样的话除非直接运行该模块，if条件下的这些代码是不会执行的，因为只有直接执行的模块的名字才是“__main__”。\nmodule3.py\ndef foo(): pass def bar(): pass # __name__是Python中一个隐含的变量它代表了模块的名字 # 只有被Python解释器直接执行的模块的名字才是__main__ if __name__ == \u0026#39;__main__\u0026#39;: print(\u0026#39;call foo()\u0026#39;) foo() print(\u0026#39;call bar()\u0026#39;) bar() test.py\nimport module3 # 导入module3时 不会执行模块中if条件成立时的代码 因为模块的名字是module3而不是__main__ 练习 练习1：实现计算求最大公约数和最小公倍数的函数。 def gcd(x, y): (x, y) = (y, x) if x \u0026gt; y else (x, y) for factor in range(x, 0, -1): if x % factor == 0 and y % factor == 0: return factor def lcm(x, y): return x * y // gcd(x, y) 练习2：实现判断一个数是不是回文数的函数。 def is_palindrome(num): temp = num total = 0 while temp \u0026gt; 0: total = total * 10 + temp % 10 temp //= 10 return total == num 练习3：实现判断一个数是不是素数的函数。 def is_prime(num): for factor in range(2, num): if num % factor == 0: return False return True if num != 1 else False 练习4：写一个程序判断输入的正整数是不是回文素数。 if __name__ == \u0026#39;__main__\u0026#39;: num = int(input(\u0026#39;请输入正整数: \u0026#39;)) if is_palindrome(num) and is_prime(num): print(\u0026#39;%d是回文素数\u0026#39; % num) 通过上面的程序可以看出，当我们将代码中重复出现的和相对独立的功能抽取成函数后，我们可以组合使用这些函数来解决更为复杂的问题，这也是我们为什么要定义和使用函数的一个非常重要的原因。\n最后，我们来讨论一下Python中有关变量作用域的问题。\ndef foo(): b = \u0026#39;hello\u0026#39; def bar(): # Python中可以在函数内部再定义函数 c = True print(a) print(b) print(c) bar() # print(c) # NameError: name \u0026#39;c\u0026#39; is not defined if __name__ == \u0026#39;__main__\u0026#39;: a = 100 # print(b) # NameError: name \u0026#39;b\u0026#39; is not defined foo() 上面的代码能够顺利的执行并且打印出100和“hello”，但我们注意到了，在bar函数的内部并没有定义a和b两个变量，那么a和b是从哪里来的。我们在上面代码的if分支中定义了一个变量a，这是一个全局变量（global variable），属于全局作用域，因为它没有定义在任何一个函数中。在上面的foo函数中我们定义了变量b，这是一个定义在函数中的局部变量（local variable），属于局部作用域，在foo函数的外部并不能访问到它；但对于foo函数内部的bar函数来说，变量b属于嵌套作用域，在bar函数中我们是可以访问到它的。bar函数中的变量c属于局部作用域，在bar函数之外是无法访问的。事实上，Python查找一个变量时会按照“局部作用域”、“嵌套作用域”、“全局作用域”和“内置作用域”的顺序进行搜索，前三者我们在上面的代码中已经看到了，所谓的“内置作用域”就是Python内置的那些隐含标识符min、len等都属于内置作用域）。\n再看看下面这段代码，我们希望通过函数调用修改全局变量a的值，但实际上下面的代码是做不到的。\ndef foo(): a = 200 print(a) # 200 if __name__ == \u0026#39;__main__\u0026#39;: a = 100 foo() print(a) # 100 在调用foo函数后，我们发现a的值仍然是100，这是因为当我们在函数foo中写a = 200的时候，是重新定义了一个名字为a的局部变量，它跟全局作用域的a并不是同一个变量，因为局部作用域中有了自己的变量a，因此foo函数不再搜索全局作用域中的a。如果我们希望在foo函数中修改全局作用域中的a，代码如下所示。\ndef foo(): global a a = 200 print(a) # 200 if __name__ == \u0026#39;__main__\u0026#39;: a = 100 foo() print(a) # 200 我们可以使用global关键字来指示foo函数中的变量a来自于全局作用域，如果全局作用域中没有a，那么下面一行的代码就会定义变量a并将其置于全局作用域。同理，如果我们希望函数内部的函数能够修改嵌套作用域中的变量，可以使用nonlocal关键字来指示变量来自于嵌套作用域，请大家自行试验。\n在实际开发中，我们应该尽量减少对全局变量的使用，因为全局变量的作用域和影响过于广泛，可能会发生意料之外的修改和使用，除此之外全局变量比局部变量拥有更长的生命周期，可能导致对象占用的内存长时间无法被垃圾回收。事实上，减少对全局变量的使用，也是降低代码之间耦合度的一个重要举措，同时也是对迪米特法则的践行。减少全局变量的使用就意味着我们应该尽量让变量的作用域在函数的内部，但是如果我们希望将一个局部变量的生命周期延长，使其在函数调用结束后依然可以访问，这时候就需要使用闭包，这个我们在后续的内容中进行讲解。\n 说明： 很多人经常会将“闭包”一词和“匿名函数”混为一谈，但实际上它们是不同的概念，如果想提前了解这个概念，推荐看看维基百科或者知乎上对这个概念的讨论。\n 说了那么多，其实结论很简单，从现在开始我们可以将Python代码按照下面的格式进行书写，这一点点的改进其实就是在我们理解了函数和作用域的基础上跨出的巨大的一步。\ndef main(): # Todo: Add your code here pass if __name__ == \u0026#39;__main__\u0026#39;: main()"},{"idx":17,"href":"/python100days/docs/Day01-15/07-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","title":"07 字符串和常用数据结构","content":" 字符串和常用数据结构 使用字符串 第二次世界大战促使了现代电子计算机的诞生，最初的目的用计算机来快速的完成导弹弹道的计算，因此在计算机刚刚诞生的那个年代，计算机处理的信息基本上都是数值型的信息，而世界上的第一台电子计算机ENIAC每秒钟能够完成约5000次浮点运算。随着时间的推移，虽然数值运算仍然是计算机日常工作中最为重要的事情之一，但是今天的计算机更多的时间需要处理的数据可能都是以文本的方式存在的，如果我们希望通过Python程序操作本这些文本信息，就必须要先了解字符串类型以及与它相关的知识。\n所谓字符串，就是由零个或多个字符组成的有限序列，一般记为。\n我们可以通过下面的代码来了解字符串的使用。\ndef main(): str1 = \u0026#39;hello, world!\u0026#39; # 通过len函数计算字符串的长度 print(len(str1)) # 13 # 获得字符串首字母大写的拷贝 print(str1.capitalize()) # Hello, world! # 获得字符串变大写后的拷贝 print(str1.upper()) # HELLO, WORLD! # 从字符串中查找子串所在位置 print(str1.find(\u0026#39;or\u0026#39;)) # 8 print(str1.find(\u0026#39;shit\u0026#39;)) # -1 # 与find类似但找不到子串时会引发异常 # print(str1.index(\u0026#39;or\u0026#39;)) # print(str1.index(\u0026#39;shit\u0026#39;)) # 检查字符串是否以指定的字符串开头 print(str1.startswith(\u0026#39;He\u0026#39;)) # False print(str1.startswith(\u0026#39;hel\u0026#39;)) # True # 检查字符串是否以指定的字符串结尾 print(str1.endswith(\u0026#39;!\u0026#39;)) # True # 将字符串以指定的宽度居中并在两侧填充指定的字符 print(str1.center(50, \u0026#39;*\u0026#39;)) # 将字符串以指定的宽度靠右放置左侧填充指定的字符 print(str1.rjust(50, \u0026#39; \u0026#39;)) str2 = \u0026#39;abc123456\u0026#39; # 从字符串中取出指定位置的字符(下标运算) print(str2[2]) # c # 字符串切片(从指定的开始索引到指定的结束索引) print(str2[2:5]) # c12 print(str2[2:]) # c123456 print(str2[2::2]) # c246 print(str2[::2]) # ac246 print(str2[::-1]) # 654321cba print(str2[-3:-1]) # 45 # 检查字符串是否由数字构成 print(str2.isdigit()) # False # 检查字符串是否以字母构成 print(str2.isalpha()) # False # 检查字符串是否以数字和字母构成 print(str2.isalnum()) # True str3 = \u0026#39; jackfrued@126.com \u0026#39; print(str3) # 获得字符串修剪左右两侧空格的拷贝 print(str3.strip()) if __name__ == \u0026#39;__main__\u0026#39;: main() 除了字符串，Python还内置了多种类型的数据结构，如果要在程序中保存和操作数据，绝大多数时候可以利用现有的数据结构来实现，最常用的包括列表、元组、集合和字典。\n使用列表 下面的代码演示了如何定义列表、使用下标访问列表元素以及添加和删除元素的操作。\ndef main(): list1 = [1, 3, 5, 7, 100] print(list1) list2 = [\u0026#39;hello\u0026#39;] * 5 print(list2) # 计算列表长度(元素个数) print(len(list1)) # 下标(索引)运算 print(list1[0]) print(list1[4]) # print(list1[5]) # IndexError: list index out of range print(list1[-1]) print(list1[-3]) list1[2] = 300 print(list1) # 添加元素 list1.append(200) list1.insert(1, 400) list1 += [1000, 2000] print(list1) print(len(list1)) # 删除元素 list1.remove(3) if 1234 in list1: list1.remove(1234) del list1[0] print(list1) # 清空列表元素 list1.clear() print(list1) if __name__ == \u0026#39;__main__\u0026#39;: main() 和字符串一样，列表也可以做切片操作，通过切片操作我们可以实现对列表的复制或者将列表中的一部分取出来创建出新的列表，代码如下所示。\ndef main(): fruits = [\u0026#39;grape\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;strawberry\u0026#39;, \u0026#39;waxberry\u0026#39;] fruits += [\u0026#39;pitaya\u0026#39;, \u0026#39;pear\u0026#39;, \u0026#39;mango\u0026#39;] # 循环遍历列表元素 for fruit in fruits: print(fruit.title(), end=\u0026#39; \u0026#39;) print() # 列表切片 fruits2 = fruits[1:4] print(fruits2) # fruit3 = fruits # 没有复制列表只创建了新的引用 # 可以通过完整切片操作来复制列表 fruits3 = fruits[:] print(fruits3) fruits4 = fruits[-3:-1] print(fruits4) # 可以通过反向切片操作来获得倒转后的列表的拷贝 fruits5 = fruits[::-1] print(fruits5) if __name__ == \u0026#39;__main__\u0026#39;: main() 下面的代码实现了对列表的排序操作。\ndef main(): list1 = [\u0026#39;orange\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;zoo\u0026#39;, \u0026#39;internationalization\u0026#39;, \u0026#39;blueberry\u0026#39;] list2 = sorted(list1) # sorted函数返回列表排序后的拷贝不会修改传入的列表 # 函数的设计就应该像sorted函数一样尽可能不产生副作用 list3 = sorted(list1, reverse=True) # 通过key关键字参数指定根据字符串长度进行排序而不是默认的字母表顺序 list4 = sorted(list1, key=len) print(list1) print(list2) print(list3) print(list4) # 给列表对象发出排序消息直接在列表对象上进行排序 list1.sort(reverse=True) print(list1) if __name__ == \u0026#39;__main__\u0026#39;: main() 我们还可以使用列表的生成式语法来创建列表，代码如下所示。\nimport sys def main(): f = [x for x in range(1, 10)] print(f) f = [x + y for x in \u0026#39;ABCDE\u0026#39; for y in \u0026#39;1234567\u0026#39;] print(f) # 用列表的生成表达式语法创建列表容器 # 用这种语法创建列表之后元素已经准备就绪所以需要耗费较多的内存空间 f = [x ** 2 for x in range(1, 1000)] print(sys.getsizeof(f)) # 查看对象占用内存的字节数 print(f) # 请注意下面的代码创建的不是一个列表而是一个生成器对象 # 通过生成器可以获取到数据但它不占用额外的空间存储数据 # 每次需要数据的时候就通过内部的运算得到数据(需要花费额外的时间) f = (x ** 2 for x in range(1, 1000)) print(sys.getsizeof(f)) # 相比生成式生成器不占用存储数据的空间 print(f) for val in f: print(val) if __name__ == \u0026#39;__main__\u0026#39;: main() 除了上面提到的生成器语法，Python中还有另外一种定义生成器的方式，就是通过yield关键字将一个普通函数改造成生成器函数。下面的代码演示了如何实现一个生成斐波拉切数列的生成器。所谓斐波拉切数列可以通过下面递归的方法来进行定义：\ndef fib(n): a, b = 0, 1 for _ in range(n): a, b = b, a + b yield a def main(): for val in fib(20): print(val) if __name__ == \u0026#39;__main__\u0026#39;: main() 使用元组 Python 的元组与列表类似，不同之处在于元组的元素不能修改，在前面的代码中我们已经不止一次使用过元组了。顾名思义，我们把多个元素组合到一起就形成了一个元组，所以它和列表一样可以保存多条数据。下面的代码演示了如何定义和使用元组。\ndef main(): # 定义元组 t = (\u0026#39;骆昊\u0026#39;, 38, True, \u0026#39;四川成都\u0026#39;) print(t) # 获取元组中的元素 print(t[0]) print(t[3]) # 遍历元组中的值 for member in t: print(member) # 重新给元组赋值 # t[0] = \u0026#39;王大锤\u0026#39; # TypeError # 变量t重新引用了新的元组原来的元组将被垃圾回收 t = (\u0026#39;王大锤\u0026#39;, 20, True, \u0026#39;云南昆明\u0026#39;) print(t) # 将元组转换成列表 person = list(t) print(person) # 列表是可以修改它的元素的 person[0] = \u0026#39;李小龙\u0026#39; person[1] = 25 print(person) # 将列表转换成元组 fruits_list = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;orange\u0026#39;] fruits_tuple = tuple(fruits_list) print(fruits_tuple) if __name__ == \u0026#39;__main__\u0026#39;: main() 这里有一个非常值得探讨的问题，我们已经有了列表这种数据结构，为什么还需要元组这样的类型呢？\n 元组中的元素是无法修改的，事实上我们在项目中尤其是多线程环境（后面会讲到）中可能更喜欢使用的是那些不变对象（一方面因为对象状态不能修改，所以可以避免由此引起的不必要的程序错误，简单的说就是一个不变的对象要比可变的对象更加容易维护；另一方面因为没有任何一个线程能够修改不变对象的内部状态，一个不变对象自动就是线程安全的，这样就可以省掉处理同步化的开销。一个不变对象可以方便的被共享访问）。所以结论就是：如果不需要对元素进行添加、删除、修改的时候，可以考虑使用元组，当然如果一个方法要返回多个值，使用元组也是不错的选择。 元组在创建时间和占用的空间上面都优于列表。我们可以使用sys模块的getsizeof函数来检查存储同样的元素的元组和列表各自占用了多少内存空间，这个很容易做到。我们也可以在ipython中使用魔法指令%timeit来分析创建同样内容的元组和列表所花费的时间，下图是我的macOS系统上测试的结果。  使用集合 Python中的集合跟数学上的集合是一致的，不允许有重复元素，而且可以进行交集、并集、差集等运算。\ndef main(): set1 = {1, 2, 3, 3, 3, 2} print(set1) print(\u0026#39;Length =\u0026#39;, len(set1)) set2 = set(range(1, 10)) print(set2) set1.add(4) set1.add(5) set2.update([11, 12]) print(set1) print(set2) set2.discard(5) # remove的元素如果不存在会引发KeyError if 4 in set2: set2.remove(4) print(set2) # 遍历集合容器 for elem in set2: print(elem ** 2, end=\u0026#39; \u0026#39;) print() # 将元组转换成集合 set3 = set((1, 2, 3, 3, 2, 1)) print(set3.pop()) print(set3) # 集合的交集、并集、差集、对称差运算 print(set1 \u0026amp; set2) # print(set1.intersection(set2)) print(set1 | set2) # print(set1.union(set2)) print(set1 - set2) # print(set1.difference(set2)) print(set1 ^ set2) # print(set1.symmetric_difference(set2)) # 判断子集和超集 print(set2 \u0026lt;= set1) # print(set2.issubset(set1)) print(set3 \u0026lt;= set1) # print(set3.issubset(set1)) print(set1 \u0026gt;= set2) # print(set1.issuperset(set2)) print(set1 \u0026gt;= set3) # print(set1.issuperset(set3)) if __name__ == \u0026#39;__main__\u0026#39;: main()  说明： Python中允许通过一些特殊的方法来为某种类型或数据结构自定义运算符（后面的章节中会讲到），上面的代码中我们对集合进行运算的时候可以调用集合对象的方法，也可以直接使用对应的运算符，例如\u0026amp;运算符跟intersection方法的作用就是一样的，但是使用运算符让代码更加直观。\n 使用字典 字典是另一种可变容器模型，类似于我们生活中使用的字典，它可以存储任意类型对象，与列表、集合不同的是，字典的每个元素都是由一个键和一个值组成的“键值对”，键和值通过冒号分开。下面的代码演示了如何定义和使用字典。\ndef main(): scores = {\u0026#39;骆昊\u0026#39;: 95, \u0026#39;白元芳\u0026#39;: 78, \u0026#39;狄仁杰\u0026#39;: 82} # 通过键可以获取字典中对应的值 print(scores[\u0026#39;骆昊\u0026#39;]) print(scores[\u0026#39;狄仁杰\u0026#39;]) # 对字典进行遍历(遍历的其实是键再通过键取对应的值) for elem in scores: print(\u0026#39;%s\\t---\u0026gt;\\t%d\u0026#39; % (elem, scores[elem])) # 更新字典中的元素 scores[\u0026#39;白元芳\u0026#39;] = 65 scores[\u0026#39;诸葛王朗\u0026#39;] = 71 scores.update(冷面=67, 方启鹤=85) print(scores) if \u0026#39;武则天\u0026#39; in scores: print(scores[\u0026#39;武则天\u0026#39;]) print(scores.get(\u0026#39;武则天\u0026#39;)) # get方法也是通过键获取对应的值但是可以设置默认值 print(scores.get(\u0026#39;武则天\u0026#39;, 60)) # 删除字典中的元素 print(scores.popitem()) print(scores.popitem()) print(scores.pop(\u0026#39;骆昊\u0026#39;, 100)) # 清空字典 scores.clear() print(scores) if __name__ == \u0026#39;__main__\u0026#39;: main() 练习 练习1：在屏幕上显示跑马灯文字 import os import time def main(): content = \u0026#39;北京欢迎你为你开天辟地…………\u0026#39; while True: # 清理屏幕上的输出 os.system(\u0026#39;cls\u0026#39;) # os.system(\u0026#39;clear\u0026#39;) print(content) # 休眠200毫秒 time.sleep(0.2) content = content[1:] + content[0] if __name__ == \u0026#39;__main__\u0026#39;: main() 练习2：设计一个函数产生指定长度的验证码，验证码由大小写字母和数字构成。 import random def generate_code(code_len=4): \u0026#34;\u0026#34;\u0026#34; 生成指定长度的验证码 :param code_len: 验证码的长度(默认4个字符) :return: 由大小写英文字母和数字构成的随机验证码 \u0026#34;\u0026#34;\u0026#34; all_chars = \u0026#39;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39; last_pos = len(all_chars) - 1 code = \u0026#39;\u0026#39; for _ in range(code_len): index = random.randint(0, last_pos) code += all_chars[index] return code 练习3：设计一个函数返回给定文件名的后缀名。 def get_suffix(filename, has_dot=False): \u0026#34;\u0026#34;\u0026#34; 获取文件名的后缀名 :param filename: 文件名 :param has_dot: 返回的后缀名是否需要带点 :return: 文件的后缀名 \u0026#34;\u0026#34;\u0026#34; pos = filename.rfind(\u0026#39;.\u0026#39;) if 0 \u0026lt; pos \u0026lt; len(filename) - 1: index = pos if has_dot else pos + 1 return filename[index:] else: return \u0026#39;\u0026#39; 练习4：设计一个函数返回传入的列表中最大和第二大的元素的值。 def max2(x): m1, m2 = (x[0], x[1]) if x[0] \u0026gt; x[1] else (x[1], x[0]) for index in range(2, len(x)): if x[index] \u0026gt; m1: m2 = m1 m1 = x[index] elif x[index] \u0026gt; m2: m2 = x[index] return m1, m2 练习5：计算指定的年月日是这一年的第几天 def is_leap_year(year): \u0026#34;\u0026#34;\u0026#34; 判断指定的年份是不是闰年 :param year: 年份 :return: 闰年返回True平年返回False \u0026#34;\u0026#34;\u0026#34; return year % 4 == 0 and year % 100 != 0 or year % 400 == 0 def which_day(year, month, date): \u0026#34;\u0026#34;\u0026#34; 计算传入的日期是这一年的第几天 :param year: 年 :param month: 月 :param date: 日 :return: 第几天 \u0026#34;\u0026#34;\u0026#34; days_of_month = [ [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] ][is_leap_year(year)] total = 0 for index in range(month - 1): total += days_of_month[index] return total + date def main(): print(which_day(1980, 11, 28)) print(which_day(1981, 12, 31)) print(which_day(2018, 1, 1)) print(which_day(2016, 3, 1)) if __name__ == \u0026#39;__main__\u0026#39;: main() 练习6：打印杨辉三角。 def main(): num = int(input(\u0026#39;Number of rows: \u0026#39;)) yh = [[]] * num for row in range(len(yh)): yh[row] = [None] * (row + 1) for col in range(len(yh[row])): if col == 0 or col == row: yh[row][col] = 1 else: yh[row][col] = yh[row - 1][col] + yh[row - 1][col - 1] print(yh[row][col], end=\u0026#39;\\t\u0026#39;) print() if __name__ == \u0026#39;__main__\u0026#39;: main() 综合案例 案例1：双色球选号 from random import randrange, randint, sample def display(balls): \u0026#34;\u0026#34;\u0026#34; 输出列表中的双色球号码 \u0026#34;\u0026#34;\u0026#34; for index, ball in enumerate(balls): if index == len(balls) - 1: print(\u0026#39;|\u0026#39;, end=\u0026#39; \u0026#39;) print(\u0026#39;%02d\u0026#39; % ball, end=\u0026#39; \u0026#39;) print() def random_select(): \u0026#34;\u0026#34;\u0026#34; 随机选择一组号码 \u0026#34;\u0026#34;\u0026#34; red_balls = [x for x in range(1, 34)] selected_balls = [] selected_balls = sample(red_balls, 6) selected_balls.sort() selected_balls.append(randint(1, 16)) return selected_balls def main(): n = int(input(\u0026#39;机选几注: \u0026#39;)) for _ in range(n): display(random_select()) if __name__ == \u0026#39;__main__\u0026#39;: main()  说明： 上面使用random模块的sample函数来实现从列表中选择不重复的n个元素。\n 综合案例2：约瑟夫环问题 \u0026#34;\u0026#34;\u0026#34; 《幸运的基督徒》 有15个基督徒和15个非基督徒在海上遇险，为了能让一部分人活下来不得不将其中15个人扔到海里面去，有个人想了个办法就是大家围成一个圈，由某个人开始从1报数，报到9的人就扔到海里面，他后面的人接着从1开始报数，报到9的人继续扔到海里面，直到扔掉15个人。由于上帝的保佑，15个基督徒都幸免于难，问这些人最开始是怎么站的，哪些位置是基督徒哪些位置是非基督徒。 \u0026#34;\u0026#34;\u0026#34; def main(): persons = [True] * 30 counter, index, number = 0, 0, 0 while counter \u0026lt; 15: if persons[index]: number += 1 if number == 9: persons[index] = False counter += 1 number = 0 index += 1 index %= 30 for person in persons: print(\u0026#39;基\u0026#39; if person else \u0026#39;非\u0026#39;, end=\u0026#39;\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: main() 综合案例3：井字棋游戏 import os def print_board(board): print(board[\u0026#39;TL\u0026#39;] + \u0026#39;|\u0026#39; + board[\u0026#39;TM\u0026#39;] + \u0026#39;|\u0026#39; + board[\u0026#39;TR\u0026#39;]) print(\u0026#39;-+-+-\u0026#39;) print(board[\u0026#39;ML\u0026#39;] + \u0026#39;|\u0026#39; + board[\u0026#39;MM\u0026#39;] + \u0026#39;|\u0026#39; + board[\u0026#39;MR\u0026#39;]) print(\u0026#39;-+-+-\u0026#39;) print(board[\u0026#39;BL\u0026#39;] + \u0026#39;|\u0026#39; + board[\u0026#39;BM\u0026#39;] + \u0026#39;|\u0026#39; + board[\u0026#39;BR\u0026#39;]) def main(): init_board = { \u0026#39;TL\u0026#39;: \u0026#39; \u0026#39;, \u0026#39;TM\u0026#39;: \u0026#39; \u0026#39;, \u0026#39;TR\u0026#39;: \u0026#39; \u0026#39;, \u0026#39;ML\u0026#39;: \u0026#39; \u0026#39;, \u0026#39;MM\u0026#39;: \u0026#39; \u0026#39;, \u0026#39;MR\u0026#39;: \u0026#39; \u0026#39;, \u0026#39;BL\u0026#39;: \u0026#39; \u0026#39;, \u0026#39;BM\u0026#39;: \u0026#39; \u0026#39;, \u0026#39;BR\u0026#39;: \u0026#39; \u0026#39; } begin = True while begin: curr_board = init_board.copy() begin = False turn = \u0026#39;x\u0026#39; counter = 0 os.system(\u0026#39;clear\u0026#39;) print_board(curr_board) while counter \u0026lt; 9: move = input(\u0026#39;轮到%s走棋, 请输入位置: \u0026#39; % turn) if curr_board[move] == \u0026#39; \u0026#39;: counter += 1 curr_board[move] = turn if turn == \u0026#39;x\u0026#39;: turn = \u0026#39;o\u0026#39; else: turn = \u0026#39;x\u0026#39; os.system(\u0026#39;clear\u0026#39;) print_board(curr_board) choice = input(\u0026#39;再玩一局?(yes|no)\u0026#39;) begin = choice == \u0026#39;yes\u0026#39; if __name__ == \u0026#39;__main__\u0026#39;: main()  说明： 最后这个案例来自《Python编程快速上手:让繁琐工作自动化》一书（这本书对有编程基础想迅速使用Python将日常工作自动化的人来说还是不错的选择），对代码做了一点点的调整。\n "},{"idx":18,"href":"/python100days/docs/Day01-15/08-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/","title":"08 面向对象编程基础","content":" 面向对象编程基础 活在当下的程序员应该都听过“面向对象编程”一词，也经常有人问能不能用一句话解释下什么是“面向对象编程”，我们先来看看比较正式的说法。\n“把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class），通过类的封装（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（specialization）和泛化（generalization），通过多态（polymorphism）实现基于对象类型的动态分派。”\n这样一说是不是更不明白了。所以我们还是看看更通俗易懂的说法，下面这段内容来自于知乎。\n 说明： 以上的内容来自于网络，不代表作者本人的观点和看法，与作者本人立场无关，相关责任不由作者承担。\n 之前我们说过“程序是指令的集合”，我们在程序中书写的语句在执行时会变成一条或多条指令然后由CPU去执行。当然为了简化程序的设计，我们引入了函数的概念，把相对独立且经常重复使用的代码放置到函数中，在需要使用这些功能的时候只要调用函数即可；如果一个函数的功能过于复杂和臃肿，我们又可以进一步将函数继续切分为子函数来降低系统的复杂性。但是说了这么多，不知道大家是否发现，所谓编程就是程序员按照计算机的工作方式控制计算机完成各种任务。但是，计算机的工作方式与正常人类的思维模式是不同的，如果编程就必须得抛弃人类正常的思维方式去迎合计算机，编程的乐趣就少了很多，“每个人都应该学习编程”这样的豪言壮语就只能说说而已。当然，这些还不是最重要的，最重要的是当我们需要开发一个复杂的系统时，代码的复杂性会让开发和维护工作都变得举步维艰，所以在上世纪60年代末期，“软件危机”、“软件工程”等一系列的概念开始在行业中出现。\n当然，程序员圈子内的人都知道，现实中并没有解决上面所说的这些问题的“银弹”，真正让软件开发者看到希望的是上世纪70年代诞生的Smalltalk编程语言中引入的面向对象的编程思想（面向对象编程的雏形可以追溯到更早期的Simula语言）。按照这种编程理念，程序中的数据和操作数据的函数是一个逻辑上的整体，我们称之为“对象”，而我们解决问题的方式就是创建出需要的对象并向对象发出各种各样的消息，多个对象的协同工作最终可以让我们构造出复杂的系统来解决现实中的问题。\n 说明： 当然面向对象也不是解决软件开发中所有问题的最后的“银弹”，所以今天的高级程序设计语言几乎都提供了对多种编程范式的支持，Python也不例外。\n 类和对象 简单的说，类是对象的蓝图和模板，而对象是类的实例。这个解释虽然有点像用概念在解释概念，但是从这句话我们至少可以看出，类是抽象的概念，而对象是具体的东西。在面向对象编程的世界中，一切皆为对象，对象都有属性和行为，每个对象都是独一无二的，而且对象一定属于某个类（型）。当我们把一大堆拥有共同特征的对象的静态特征（属性）和动态特征（行为）都抽取出来后，就可以定义出一个叫做“类”的东西。\n定义类 在Python中可以使用class关键字定义类，然后在类中通过之前学习过的函数来定义方法，这样就可以将对象的动态特征描述出来，代码如下所示。\nclass Student(object): # __init__是一个特殊方法用于在创建对象时进行初始化操作 # 通过这个方法我们可以为学生对象绑定name和age两个属性 def __init__(self, name, age): self.name = name self.age = age def study(self, course_name): print(\u0026#39;%s正在学习%s.\u0026#39; % (self.name, course_name)) # PEP 8要求标识符的名字用全小写多个单词用下划线连接 # 但是部分程序员和公司更倾向于使用驼峰命名法(驼峰标识) def watch_movie(self): if self.age \u0026lt; 18: print(\u0026#39;%s只能观看《熊出没》.\u0026#39; % self.name) else: print(\u0026#39;%s正在观看岛国爱情大电影.\u0026#39; % self.name)  说明： 写在类中的函数，我们通常称之为（对象的）方法，这些方法就是对象可以接收的消息。\n 创建和使用对象 当我们定义好一个类之后，可以通过下面的方式来创建对象并给对象发消息。\ndef main(): # 创建学生对象并指定姓名和年龄 stu1 = Student(\u0026#39;骆昊\u0026#39;, 38) # 给对象发study消息 stu1.study(\u0026#39;Python程序设计\u0026#39;) # 给对象发watch_av消息 stu1.watch_movie() stu2 = Student(\u0026#39;王大锤\u0026#39;, 15) stu2.study(\u0026#39;思想品德\u0026#39;) stu2.watch_movie() if __name__ == \u0026#39;__main__\u0026#39;: main() 访问可见性问题 对于上面的代码，有C++、Java、C#等编程经验的程序员可能会问，我们给Student对象绑定的name和age属性到底具有怎样的访问权限（也称为可见性）。因为在很多面向对象编程语言中，我们通常会将对象的属性设置为私有的（private）或受保护的（protected），简单的说就是不允许外界访问，而对象的方法通常都是公开的（public），因为公开的方法就是对象能够接受的消息。在Python中，属性和方法的访问权限只有两种，也就是公开的和私有的，如果希望属性是私有的，在给属性命名时可以用两个下划线作为开头，下面的代码可以验证这一点。\nclass Test: def __init__(self, foo): self.__foo = foo def __bar(self): print(self.__foo) print(\u0026#39;__bar\u0026#39;) def main(): test = Test(\u0026#39;hello\u0026#39;) # AttributeError: \u0026#39;Test\u0026#39; object has no attribute \u0026#39;__bar\u0026#39; test.__bar() # AttributeError: \u0026#39;Test\u0026#39; object has no attribute \u0026#39;__foo\u0026#39; print(test.__foo) if __name__ == \u0026#34;__main__\u0026#34;: main() 但是，Python并没有从语法上严格保证私有属性或方法的私密性，它只是给私有的属性和方法换了一个名字来“妨碍”对它们的访问，事实上如果你知道更换名字的规则仍然可以访问到它们，下面的代码就可以验证这一点。之所以这样设定，可以用这样一句名言加以解释，就是“We are all consenting adults here”。因为绝大多数程序员都认为开放比封闭要好，而且程序员要自己为自己的行为负责。\nclass Test: def __init__(self, foo): self.__foo = foo def __bar(self): print(self.__foo) print(\u0026#39;__bar\u0026#39;) def main(): test = Test(\u0026#39;hello\u0026#39;) test._Test__bar() print(test._Test__foo) if __name__ == \u0026#34;__main__\u0026#34;: main() 在实际开发中，我们并不建议将属性设置为私有的，因为这会导致子类无法访问（后面会讲到）。所以大多数Python程序员会遵循一种命名惯例就是让属性名以单下划线开头来表示属性是受保护的，本类之外的代码在访问这样的属性时应该要保持慎重。这种做法并不是语法上的规则，单下划线开头的属性和方法外界仍然是可以访问的，所以更多的时候它是一种暗示或隐喻，关于这一点可以看看我的《Python - 那些年我们踩过的那些坑》文章中的讲解。\n面向对象的支柱 面向对象有三大支柱：封装、继承和多态。后面两个概念在下一个章节中进行详细的说明，这里我们先说一下什么是封装。我自己对封装的理解是“隐藏一切可以隐藏的实现细节，只向外界暴露（提供）简单的编程接口”。我们在类中定义的方法其实就是把数据和对数据的操作封装起来了，在我们创建了对象之后，只需要给对象发送一个消息（调用方法）就可以执行方法中的代码，也就是说我们只需要知道方法的名字和传入的参数（方法的外部视图），而不需要知道方法内部的实现细节（方法的内部视图）。\n练习 练习1：定义一个类描述数字时钟 from time import sleep class Clock(object): \u0026#34;\u0026#34;\u0026#34;数字时钟\u0026#34;\u0026#34;\u0026#34; def __init__(self, hour=0, minute=0, second=0): \u0026#34;\u0026#34;\u0026#34;初始化方法 :param hour: 时 :param minute: 分 :param second: 秒 \u0026#34;\u0026#34;\u0026#34; self._hour = hour self._minute = minute self._second = second def run(self): \u0026#34;\u0026#34;\u0026#34;走字\u0026#34;\u0026#34;\u0026#34; self._second += 1 if self._second == 60: self._second = 0 self._minute += 1 if self._minute == 60: self._minute = 0 self._hour += 1 if self._hour == 24: self._hour = 0 def show(self): \u0026#34;\u0026#34;\u0026#34;显示时间\u0026#34;\u0026#34;\u0026#34; return \u0026#39;%02d:%02d:%02d\u0026#39; % \\ (self._hour, self._minute, self._second) def main(): clock = Clock(23, 59, 58) while True: print(clock.show()) sleep(1) clock.run() if __name__ == \u0026#39;__main__\u0026#39;: main() 练习2：定义一个类描述平面上的点并提供移动点和计算到另一个点距离的方法。 from math import sqrt class Point(object): def __init__(self, x=0, y=0): \u0026#34;\u0026#34;\u0026#34;初始化方法 :param x: 横坐标 :param y: 纵坐标 \u0026#34;\u0026#34;\u0026#34; self.x = x self.y = y def move_to(self, x, y): \u0026#34;\u0026#34;\u0026#34;移动到指定位置 :param x: 新的横坐标 \u0026#34;param y: 新的纵坐标 \u0026#34;\u0026#34;\u0026#34; self.x = x self.y = y def move_by(self, dx, dy): \u0026#34;\u0026#34;\u0026#34;移动指定的增量 :param dx: 横坐标的增量 \u0026#34;param dy: 纵坐标的增量 \u0026#34;\u0026#34;\u0026#34; self.x += dx self.y += dy def distance_to(self, other): \u0026#34;\u0026#34;\u0026#34;计算与另一个点的距离 :param other: 另一个点 \u0026#34;\u0026#34;\u0026#34; dx = self.x - other.x dy = self.y - other.y return sqrt(dx ** 2 + dy ** 2) def __str__(self): return \u0026#39;(%s, %s)\u0026#39; % (str(self.x), str(self.y)) def main(): p1 = Point(3, 5) p2 = Point() print(p1) print(p2) p2.move_by(-1, 2) print(p2) print(p1.distance_to(p2)) if __name__ == \u0026#39;__main__\u0026#39;: main()  说明： 本章中的插图来自于Grady Booch等著作的《面向对象分析与设计》一书，该书是讲解面向对象编程的经典著作，有兴趣的读者可以购买和阅读这本书来了解更多的面向对象的相关知识。\n "},{"idx":19,"href":"/python100days/docs/Day01-15/09-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6/","title":"09 面向对象进阶","content":" 面向对象进阶 在前面的章节我们已经了解了面向对象的入门知识，知道了如何定义类，如何创建对象以及如何给对象发消息。为了能够更好的使用面向对象编程思想进行程序开发，我们还需要对Python中的面向对象编程进行更为深入的了解。\n@property装饰器 之前我们讨论过Python中属性和方法访问权限的问题，虽然我们不建议将属性设置为私有的，但是如果直接将属性暴露给外界也是有问题的，比如我们没有办法检查赋给属性的值是否有效。我们之前的建议是将属性命名以单下划线开头，通过这种方式来暗示属性是受保护的，不建议外界直接访问，那么如果想访问属性可以通过属性的getter（访问器）和setter（修改器）方法进行对应的操作。如果要做到这点，就可以考虑使用@property包装器来包装getter和setter方法，使得对属性的访问既安全又方便，代码如下所示。\nclass Person(object): def __init__(self, name, age): self._name = name self._age = age # 访问器 - getter方法 @property def name(self): return self._name # 访问器 - getter方法 @property def age(self): return self._age # 修改器 - setter方法 @age.setter def age(self, age): self._age = age def play(self): if self._age \u0026lt;= 16: print(\u0026#39;%s正在玩飞行棋.\u0026#39; % self._name) else: print(\u0026#39;%s正在玩斗地主.\u0026#39; % self._name) def main(): person = Person(\u0026#39;王大锤\u0026#39;, 12) person.play() person.age = 22 person.play() # person.name = \u0026#39;白元芳\u0026#39; # AttributeError: can\u0026#39;t set attribute if __name__ == \u0026#39;__main__\u0026#39;: main() __slots__魔法 我们讲到这里，不知道大家是否已经意识到，Python是一门动态语言。通常，动态语言允许我们在程序运行时给对象绑定新的属性或方法，当然也可以对已经绑定的属性和方法进行解绑定。但是如果我们需要限定自定义类型的对象只能绑定某些属性，可以通过在类中定义__slots__变量来进行限定。需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用。\nclass Person(object): # 限定Person对象只能绑定_name, _age和_gender属性 __slots__ = (\u0026#39;_name\u0026#39;, \u0026#39;_age\u0026#39;, \u0026#39;_gender\u0026#39;) def __init__(self, name, age): self._name = name self._age = age @property def name(self): return self._name @property def age(self): return self._age @age.setter def age(self, age): self._age = age def play(self): if self._age \u0026lt;= 16: print(\u0026#39;%s正在玩飞行棋.\u0026#39; % self._name) else: print(\u0026#39;%s正在玩斗地主.\u0026#39; % self._name) def main(): person = Person(\u0026#39;王大锤\u0026#39;, 22) person.play() person._gender = \u0026#39;男\u0026#39; # AttributeError: \u0026#39;Person\u0026#39; object has no attribute \u0026#39;_is_gay\u0026#39; # person._is_gay = True 静态方法和类方法 之前，我们在类中定义的方法都是对象方法，也就是说这些方法都是发送给对象的消息。实际上，我们写在类中的方法并不需要都是对象方法，例如我们定义一个“三角形”类，通过传入三条边长来构造三角形，并提供计算周长和面积的方法，但是传入的三条边长未必能构造出三角形对象，因此我们可以先写一个方法来验证三条边长是否可以构成三角形，这个方法很显然就不是对象方法，因为在调用这个方法时三角形对象尚未创建出来（因为都不知道三条边能不能构成三角形），所以这个方法是属于三角形类而并不属于三角形对象的。我们可以使用静态方法来解决这类问题，代码如下所示。\nfrom math import sqrt class Triangle(object): def __init__(self, a, b, c): self._a = a self._b = b self._c = c @staticmethod def is_valid(a, b, c): return a + b \u0026gt; c and b + c \u0026gt; a and a + c \u0026gt; b def perimeter(self): return self._a + self._b + self._c def area(self): half = self.perimeter() / 2 return sqrt(half * (half - self._a) * (half - self._b) * (half - self._c)) def main(): a, b, c = 3, 4, 5 # 静态方法和类方法都是通过给类发消息来调用的 if Triangle.is_valid(a, b, c): t = Triangle(a, b, c) print(t.perimeter()) # 也可以通过给类发消息来调用对象方法但是要传入接收消息的对象作为参数 # print(Triangle.perimeter(t)) print(t.area()) # print(Triangle.area(t)) else: print(\u0026#39;无法构成三角形.\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: main() 和静态方法比较类似，Python还可以在类中定义类方法，类方法的第一个参数约定名为cls，它代表的是当前类相关的信息的对象（类本身也是一个对象，有的地方也称之为类的元数据对象），通过这个参数我们可以获取和类相关的信息并且可以创建出类的对象，代码如下所示。\nfrom time import time, localtime, sleep class Clock(object): \u0026#34;\u0026#34;\u0026#34;数字时钟\u0026#34;\u0026#34;\u0026#34; def __init__(self, hour=0, minute=0, second=0): self._hour = hour self._minute = minute self._second = second @classmethod def now(cls): ctime = localtime(time()) return cls(ctime.tm_hour, ctime.tm_min, ctime.tm_sec) def run(self): \u0026#34;\u0026#34;\u0026#34;走字\u0026#34;\u0026#34;\u0026#34; self._second += 1 if self._second == 60: self._second = 0 self._minute += 1 if self._minute == 60: self._minute = 0 self._hour += 1 if self._hour == 24: self._hour = 0 def show(self): \u0026#34;\u0026#34;\u0026#34;显示时间\u0026#34;\u0026#34;\u0026#34; return \u0026#39;%02d:%02d:%02d\u0026#39; % \\ (self._hour, self._minute, self._second) def main(): # 通过类方法创建对象并获取系统时间 clock = Clock.now() while True: print(clock.show()) sleep(1) clock.run() if __name__ == \u0026#39;__main__\u0026#39;: main() 类之间的关系 简单的说，类和类之间的关系有三种：is-a、has-a和use-a关系。\n is-a关系也叫继承或泛化，比如学生和人的关系、手机和电子产品的关系都属于继承关系。 has-a关系通常称之为关联，比如部门和员工的关系，汽车和引擎的关系都属于关联关系；关联关系如果是整体和部分的关联，那么我们称之为聚合关系；如果整体进一步负责了部分的生命周期（整体和部分是不可分割的，同时同在也同时消亡），那么这种就是最强的关联关系，我们称之为合成关系。 use-a关系通常称之为依赖，比如司机有一个驾驶的行为（方法），其中（的参数）使用到了汽车，那么司机和汽车的关系就是依赖关系。  我们可以使用一种叫做UML（统一建模语言）的东西来进行面向对象建模，其中一项重要的工作就是把类和类之间的关系用标准化的图形符号描述出来。关于UML我们在这里不做详细的介绍，有兴趣的读者可以自行阅读《UML面向对象设计基础》一书。\n利用类之间的这些关系，我们可以在已有类的基础上来完成某些操作，也可以在已有类的基础上创建新的类，这些都是实现代码复用的重要手段。复用现有的代码不仅可以减少开发的工作量，也有利于代码的管理和维护，这是我们在日常工作中都会使用到的技术手段。\n继承和多态 刚才我们提到了，可以在已有类的基础上创建新类，这其中的一种做法就是让一个类从另一个类那里将属性和方法直接继承下来，从而减少重复代码的编写。提供继承信息的我们称之为父类，也叫超类或基类；得到继承信息的我们称之为子类，也叫派生类或衍生类。子类除了继承父类提供的属性和方法，还可以定义自己特有的属性和方法，所以子类比父类拥有的更多的能力，在实际开发中，我们经常会用子类对象去替换掉一个父类对象，这是面向对象编程中一个常见的行为，对应的原则称之为里氏替换原则。下面我们先看一个继承的例子。\nclass Person(object): \u0026#34;\u0026#34;\u0026#34;人\u0026#34;\u0026#34;\u0026#34; def __init__(self, name, age): self._name = name self._age = age @property def name(self): return self._name @property def age(self): return self._age @age.setter def age(self, age): self._age = age def play(self): print(\u0026#39;%s正在愉快的玩耍.\u0026#39; % self._name) def watch_av(self): if self._age \u0026gt;= 18: print(\u0026#39;%s正在观看爱情动作片.\u0026#39; % self._name) else: print(\u0026#39;%s只能观看《熊出没》.\u0026#39; % self._name) class Student(Person): \u0026#34;\u0026#34;\u0026#34;学生\u0026#34;\u0026#34;\u0026#34; def __init__(self, name, age, grade): super().__init__(name, age) self._grade = grade @property def grade(self): return self._grade @grade.setter def grade(self, grade): self._grade = grade def study(self, course): print(\u0026#39;%s的%s正在学习%s.\u0026#39; % (self._grade, self._name, course)) class Teacher(Person): \u0026#34;\u0026#34;\u0026#34;老师\u0026#34;\u0026#34;\u0026#34; def __init__(self, name, age, title): super().__init__(name, age) self._title = title @property def title(self): return self._title @title.setter def title(self, title): self._title = title def teach(self, course): print(\u0026#39;%s%s正在讲%s.\u0026#39; % (self._name, self._title, course)) def main(): stu = Student(\u0026#39;王大锤\u0026#39;, 15, \u0026#39;初三\u0026#39;) stu.study(\u0026#39;数学\u0026#39;) stu.watch_av() t = Teacher(\u0026#39;骆昊\u0026#39;, 38, \u0026#39;砖家\u0026#39;) t.teach(\u0026#39;Python程序设计\u0026#39;) t.watch_av() if __name__ == \u0026#39;__main__\u0026#39;: main() 子类在继承了父类的方法后，可以对父类已有的方法给出新的实现版本，这个动作称之为方法重写（override）。通过方法重写我们可以让父类的同一个行为在子类中拥有不同的实现版本，当我们调用这个经过子类重写的方法时，不同的子类对象会表现出不同的行为，这个就是多态（poly-morphism）。\nfrom abc import ABCMeta, abstractmethod class Pet(object, metaclass=ABCMeta): \u0026#34;\u0026#34;\u0026#34;宠物\u0026#34;\u0026#34;\u0026#34; def __init__(self, nickname): self._nickname = nickname @abstractmethod def make_voice(self): \u0026#34;\u0026#34;\u0026#34;发出声音\u0026#34;\u0026#34;\u0026#34; pass class Dog(Pet): \u0026#34;\u0026#34;\u0026#34;狗\u0026#34;\u0026#34;\u0026#34; def make_voice(self): print(\u0026#39;%s: 汪汪汪...\u0026#39; % self._nickname) class Cat(Pet): \u0026#34;\u0026#34;\u0026#34;猫\u0026#34;\u0026#34;\u0026#34; def make_voice(self): print(\u0026#39;%s: 喵...喵...\u0026#39; % self._nickname) def main(): pets = [Dog(\u0026#39;旺财\u0026#39;), Cat(\u0026#39;凯蒂\u0026#39;), Dog(\u0026#39;大黄\u0026#39;)] for pet in pets: pet.make_voice() if __name__ == \u0026#39;__main__\u0026#39;: main() 在上面的代码中，我们将Pet类处理成了一个抽象类，所谓抽象类就是不能够创建对象的类，这种类的存在就是专门为了让其他类去继承它。Python从语法层面并没有像Java或C#那样提供对抽象类的支持，但是我们可以通过abc模块的ABCMeta元类和abstractmethod包装器来达到抽象类的效果，如果一个类中存在抽象方法那么这个类就不能够实例化（创建对象）。上面的代码中，Dog和Cat两个子类分别对Pet类中的make_voice抽象方法进行了重写并给出了不同的实现版本，当我们在main函数中调用该方法时，这个方法就表现出了多态行为（同样的方法做了不同的事情）。\n综合案例 案例1：奥特曼打小怪兽 from abc import ABCMeta, abstractmethod from random import randint, randrange class Fighter(object, metaclass=ABCMeta): \u0026#34;\u0026#34;\u0026#34;战斗者\u0026#34;\u0026#34;\u0026#34; # 通过__slots__魔法限定对象可以绑定的成员变量 __slots__ = (\u0026#39;_name\u0026#39;, \u0026#39;_hp\u0026#39;) def __init__(self, name, hp): \u0026#34;\u0026#34;\u0026#34;初始化方法 :param name: 名字 :param hp: 生命值 \u0026#34;\u0026#34;\u0026#34; self._name = name self._hp = hp @property def name(self): return self._name @property def hp(self): return self._hp @hp.setter def hp(self, hp): self._hp = hp if hp \u0026gt;= 0 else 0 @property def alive(self): return self._hp \u0026gt; 0 @abstractmethod def attack(self, other): \u0026#34;\u0026#34;\u0026#34;攻击 :param other: 被攻击的对象 \u0026#34;\u0026#34;\u0026#34; pass class Ultraman(Fighter): \u0026#34;\u0026#34;\u0026#34;奥特曼\u0026#34;\u0026#34;\u0026#34; __slots__ = (\u0026#39;_name\u0026#39;, \u0026#39;_hp\u0026#39;, \u0026#39;_mp\u0026#39;) def __init__(self, name, hp, mp): \u0026#34;\u0026#34;\u0026#34;初始化方法 :param name: 名字 :param hp: 生命值 :param mp: 魔法值 \u0026#34;\u0026#34;\u0026#34; super().__init__(name, hp) self._mp = mp def attack(self, other): other.hp -= randint(15, 25) def huge_attack(self, other): \u0026#34;\u0026#34;\u0026#34;究极必杀技(打掉对方至少50点或四分之三的血) :param other: 被攻击的对象 :return: 使用成功返回True否则返回False \u0026#34;\u0026#34;\u0026#34; if self._mp \u0026gt;= 50: self._mp -= 50 injury = other.hp * 3 // 4 injury = injury if injury \u0026gt;= 50 else 50 other.hp -= injury return True else: self.attack(other) return False def magic_attack(self, others): \u0026#34;\u0026#34;\u0026#34;魔法攻击 :param others: 被攻击的群体 :return: 使用魔法成功返回True否则返回False \u0026#34;\u0026#34;\u0026#34; if self._mp \u0026gt;= 20: self._mp -= 20 for temp in others: if temp.alive: temp.hp -= randint(10, 15) return True else: return False def resume(self): \u0026#34;\u0026#34;\u0026#34;恢复魔法值\u0026#34;\u0026#34;\u0026#34; incr_point = randint(1, 10) self._mp += incr_point return incr_point def __str__(self): return \u0026#39;~~~%s奥特曼~~~\\n\u0026#39; % self._name + \\ \u0026#39;生命值: %d\\n\u0026#39; % self._hp + \\ \u0026#39;魔法值: %d\\n\u0026#39; % self._mp class Monster(Fighter): \u0026#34;\u0026#34;\u0026#34;小怪兽\u0026#34;\u0026#34;\u0026#34; __slots__ = (\u0026#39;_name\u0026#39;, \u0026#39;_hp\u0026#39;) def attack(self, other): other.hp -= randint(10, 20) def __str__(self): return \u0026#39;~~~%s小怪兽~~~\\n\u0026#39; % self._name + \\ \u0026#39;生命值: %d\\n\u0026#39; % self._hp def is_any_alive(monsters): \u0026#34;\u0026#34;\u0026#34;判断有没有小怪兽是活着的\u0026#34;\u0026#34;\u0026#34; for monster in monsters: if monster.alive \u0026gt; 0: return True return False def select_alive_one(monsters): \u0026#34;\u0026#34;\u0026#34;选中一只活着的小怪兽\u0026#34;\u0026#34;\u0026#34; monsters_len = len(monsters) while True: index = randrange(monsters_len) monster = monsters[index] if monster.alive \u0026gt; 0: return monster def display_info(ultraman, monsters): \u0026#34;\u0026#34;\u0026#34;显示奥特曼和小怪兽的信息\u0026#34;\u0026#34;\u0026#34; print(ultraman) for monster in monsters: print(monster, end=\u0026#39;\u0026#39;) def main(): u = Ultraman(\u0026#39;骆昊\u0026#39;, 1000, 120) m1 = Monster(\u0026#39;狄仁杰\u0026#39;, 250) m2 = Monster(\u0026#39;白元芳\u0026#39;, 500) m3 = Monster(\u0026#39;王大锤\u0026#39;, 750) ms = [m1, m2, m3] fight_round = 1 while u.alive and is_any_alive(ms): print(\u0026#39;========第%02d回合========\u0026#39; % fight_round) m = select_alive_one(ms) # 选中一只小怪兽 skill = randint(1, 10) # 通过随机数选择使用哪种技能 if skill \u0026lt;= 6: # 60%的概率使用普通攻击 print(\u0026#39;%s使用普通攻击打了%s.\u0026#39; % (u.name, m.name)) u.attack(m) print(\u0026#39;%s的魔法值恢复了%d点.\u0026#39; % (u.name, u.resume())) elif skill \u0026lt;= 9: # 30%的概率使用魔法攻击(可能因魔法值不足而失败) if u.magic_attack(ms): print(\u0026#39;%s使用了魔法攻击.\u0026#39; % u.name) else: print(\u0026#39;%s使用魔法失败.\u0026#39; % u.name) else: # 10%的概率使用究极必杀技(如果魔法值不足则使用普通攻击) if u.huge_attack(m): print(\u0026#39;%s使用究极必杀技虐了%s.\u0026#39; % (u.name, m.name)) else: print(\u0026#39;%s使用普通攻击打了%s.\u0026#39; % (u.name, m.name)) print(\u0026#39;%s的魔法值恢复了%d点.\u0026#39; % (u.name, u.resume())) if m.alive \u0026gt; 0: # 如果选中的小怪兽没有死就回击奥特曼 print(\u0026#39;%s回击了%s.\u0026#39; % (m.name, u.name)) m.attack(u) display_info(u, ms) # 每个回合结束后显示奥特曼和小怪兽的信息 fight_round += 1 print(\u0026#39;\\n========战斗结束!========\\n\u0026#39;) if u.alive \u0026gt; 0: print(\u0026#39;%s奥特曼胜利!\u0026#39; % u.name) else: print(\u0026#39;小怪兽胜利!\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: main() 案例2：扑克游戏 import random class Card(object): \u0026#34;\u0026#34;\u0026#34;一张牌\u0026#34;\u0026#34;\u0026#34; def __init__(self, suite, face): self._suite = suite self._face = face @property def face(self): return self._face @property def suite(self): return self._suite def __str__(self): if self._face == 1: face_str = \u0026#39;A\u0026#39; elif self._face == 11: face_str = \u0026#39;J\u0026#39; elif self._face == 12: face_str = \u0026#39;Q\u0026#39; elif self._face == 13: face_str = \u0026#39;K\u0026#39; else: face_str = str(self._face) return \u0026#39;%s%s\u0026#39; % (self._suite, face_str) def __repr__(self): return self.__str__() class Poker(object): \u0026#34;\u0026#34;\u0026#34;一副牌\u0026#34;\u0026#34;\u0026#34; def __init__(self): self._cards = [Card(suite, face) for suite in \u0026#39;♠♥♣♦\u0026#39; for face in range(1, 14)] self._current = 0 @property def cards(self): return self._cards def shuffle(self): \u0026#34;\u0026#34;\u0026#34;洗牌(随机乱序)\u0026#34;\u0026#34;\u0026#34; self._current = 0 random.shuffle(self._cards) @property def next(self): \u0026#34;\u0026#34;\u0026#34;发牌\u0026#34;\u0026#34;\u0026#34; card = self._cards[self._current] self._current += 1 return card @property def has_next(self): \u0026#34;\u0026#34;\u0026#34;还有没有牌\u0026#34;\u0026#34;\u0026#34; return self._current \u0026lt; len(self._cards) class Player(object): \u0026#34;\u0026#34;\u0026#34;玩家\u0026#34;\u0026#34;\u0026#34; def __init__(self, name): self._name = name self._cards_on_hand = [] @property def name(self): return self._name @property def cards_on_hand(self): return self._cards_on_hand def get(self, card): \u0026#34;\u0026#34;\u0026#34;摸牌\u0026#34;\u0026#34;\u0026#34; self._cards_on_hand.append(card) def arrange(self, card_key): \u0026#34;\u0026#34;\u0026#34;玩家整理手上的牌\u0026#34;\u0026#34;\u0026#34; self._cards_on_hand.sort(key=card_key) # 排序规则-先根据花色再根据点数排序 def get_key(card): return (card.suite, card.face) def main(): p = Poker() p.shuffle() players = [Player(\u0026#39;东邪\u0026#39;), Player(\u0026#39;西毒\u0026#39;), Player(\u0026#39;南帝\u0026#39;), Player(\u0026#39;北丐\u0026#39;)] for _ in range(13): for player in players: player.get(p.next) for player in players: print(player.name + \u0026#39;:\u0026#39;, end=\u0026#39; \u0026#39;) player.arrange(get_key) print(player.cards_on_hand) if __name__ == \u0026#39;__main__\u0026#39;: main()  说明： 大家可以自己尝试在上面代码的基础上写一个简单的扑克游戏，例如21点(Black Jack)，游戏的规则可以自己在网上找一找。\n 案例3：工资结算系统 \u0026#34;\u0026#34;\u0026#34; 某公司有三种类型的员工 分别是部门经理、程序员和销售员 需要设计一个工资结算系统 根据提供的员工信息来计算月薪 部门经理的月薪是每月固定15000元 程序员的月薪按本月工作时间计算 每小时150元 销售员的月薪是1200元的底薪加上销售额5%的提成 \u0026#34;\u0026#34;\u0026#34; from abc import ABCMeta, abstractmethod class Employee(object, metaclass=ABCMeta): \u0026#34;\u0026#34;\u0026#34;员工\u0026#34;\u0026#34;\u0026#34; def __init__(self, name): \u0026#34;\u0026#34;\u0026#34; 初始化方法 :param name: 姓名 \u0026#34;\u0026#34;\u0026#34; self._name = name @property def name(self): return self._name @abstractmethod def get_salary(self): \u0026#34;\u0026#34;\u0026#34; 获得月薪 :return: 月薪 \u0026#34;\u0026#34;\u0026#34; pass class Manager(Employee): \u0026#34;\u0026#34;\u0026#34;部门经理\u0026#34;\u0026#34;\u0026#34; def get_salary(self): return 15000.0 class Programmer(Employee): \u0026#34;\u0026#34;\u0026#34;程序员\u0026#34;\u0026#34;\u0026#34; def __init__(self, name, working_hour=0): super().__init__(name) self._working_hour = working_hour @property def working_hour(self): return self._working_hour @working_hour.setter def working_hour(self, working_hour): self._working_hour = working_hour if working_hour \u0026gt; 0 else 0 def get_salary(self): return 150.0 * self._working_hour class Salesman(Employee): \u0026#34;\u0026#34;\u0026#34;销售员\u0026#34;\u0026#34;\u0026#34; def __init__(self, name, sales=0): super().__init__(name) self._sales = sales @property def sales(self): return self._sales @sales.setter def sales(self, sales): self._sales = sales if sales \u0026gt; 0 else 0 def get_salary(self): return 1200.0 + self._sales * 0.05 def main(): emps = [ Manager(\u0026#39;刘备\u0026#39;), Programmer(\u0026#39;诸葛亮\u0026#39;), Manager(\u0026#39;曹操\u0026#39;), Salesman(\u0026#39;荀彧\u0026#39;), Salesman(\u0026#39;吕布\u0026#39;), Programmer(\u0026#39;张辽\u0026#39;), Programmer(\u0026#39;赵云\u0026#39;) ] for emp in emps: if isinstance(emp, Programmer): emp.working_hour = int(input(\u0026#39;请输入%s本月工作时间: \u0026#39; % emp.name)) elif isinstance(emp, Salesman): emp.sales = float(input(\u0026#39;请输入%s本月销售额: \u0026#39; % emp.name)) # 同样是接收get_salary这个消息但是不同的员工表现出了不同的行为(多态) print(\u0026#39;%s本月工资为: ￥%s元\u0026#39; % (emp.name, emp.get_salary())) if __name__ == \u0026#39;__main__\u0026#39;: main()"},{"idx":20,"href":"/python100days/docs/Day01-15/10-%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E5%92%8C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/","title":"10 图形用户界面和游戏开发","content":" 图形用户界面和游戏开发 基于tkinter模块的GUI GUI是图形用户界面的缩写，图形化的用户界面对使用过计算机的人来说应该都不陌生，在此也无需进行赘述。Python默认的GUI开发模块是tkinter（在Python 3以前的版本中名为Tkinter），从这个名字就可以看出它是基于Tk的，Tk是一个工具包，最初是为Tcl设计的，后来被移植到很多其他的脚本语言中，它提供了跨平台的GUI控件。当然Tk并不是最新和最好的选择，也没有功能特别强大的GUI控件，事实上，开发GUI应用并不是Python最擅长的工作，如果真的需要使用Python开发GUI应用，wxPython、PyQt、PyGTK等模块都是不错的选择。\n基本上使用tkinter来开发GUI应用需要以下5个步骤：\n 导入tkinter模块中我们需要的东西。 创建一个顶层窗口对象并用它来承载整个GUI应用。 在顶层窗口对象上添加GUI组件。 通过代码将这些GUI组件的功能组织起来。 进入主事件循环(main loop)。  下面的代码演示了如何使用tkinter做一个简单的GUI应用。\nimport tkinter import tkinter.messagebox def main(): flag = True # 修改标签上的文字 def change_label_text(): nonlocal flag flag = not flag color, msg = (\u0026#39;red\u0026#39;, \u0026#39;Hello, world!\u0026#39;)\\ if flag else (\u0026#39;blue\u0026#39;, \u0026#39;Goodbye, world!\u0026#39;) label.config(text=msg, fg=color) # 确认退出 def confirm_to_quit(): if tkinter.messagebox.askokcancel(\u0026#39;温馨提示\u0026#39;, \u0026#39;确定要退出吗?\u0026#39;): top.quit() # 创建顶层窗口 top = tkinter.Tk() # 设置窗口大小 top.geometry(\u0026#39;240x160\u0026#39;) # 设置窗口标题 top.title(\u0026#39;小游戏\u0026#39;) # 创建标签对象并添加到顶层窗口 label = tkinter.Label(top, text=\u0026#39;Hello, world!\u0026#39;, font=\u0026#39;Arial -32\u0026#39;, fg=\u0026#39;red\u0026#39;) label.pack(expand=1) # 创建一个装按钮的容器 panel = tkinter.Frame(top) # 创建按钮对象 指定添加到哪个容器中 通过command参数绑定事件回调函数 button1 = tkinter.Button(panel, text=\u0026#39;修改\u0026#39;, command=change_label_text) button1.pack(side=\u0026#39;left\u0026#39;) button2 = tkinter.Button(panel, text=\u0026#39;退出\u0026#39;, command=confirm_to_quit) button2.pack(side=\u0026#39;right\u0026#39;) panel.pack(side=\u0026#39;bottom\u0026#39;) # 开启主事件循环 tkinter.mainloop() if __name__ == \u0026#39;__main__\u0026#39;: main() 需要说明的是，GUI应用通常是事件驱动式的，之所以要进入主事件循环就是要监听鼠标、键盘等各种事件的发生并执行对应的代码对事件进行处理，因为事件会持续的发生，所以需要这样的一个循环一直运行着等待下一个事件的发生。另一方面，Tk为控件的摆放提供了三种布局管理器，通过布局管理器可以对控件进行定位，这三种布局管理器分别是：Placer（开发者提供控件的大小和摆放位置）、Packer（自动将控件填充到合适的位置）和Grid（基于网格坐标来摆放控件），此处不进行赘述。\n使用Pygame进行游戏开发 Pygame是一个开源的Python模块，专门用于多媒体应用（如电子游戏）的开发，其中包含对图像、声音、视频、事件、碰撞等的支持。Pygame建立在SDL的基础上，SDL是一套跨平台的多媒体开发库，用C语言实现，被广泛的应用于游戏、模拟器、播放器等的开发。而Pygame让游戏开发者不再被底层语言束缚，可以更多的关注游戏的功能和逻辑。\n下面我们来完成一个简单的小游戏，游戏的名字叫“大球吃小球”，当然完成这个游戏并不是重点，学会使用Pygame也不是重点，最重要的我们要在这个过程中体会如何使用前面讲解的面向对象程序设计，学会用这种编程思想去解决现实中的问题。\n制作游戏窗口 import pygame def main(): # 初始化导入的pygame中的模块 pygame.init() # 初始化用于显示的窗口并设置窗口尺寸 screen = pygame.display.set_mode((800, 600)) # 设置当前窗口的标题 pygame.display.set_caption(\u0026#39;大球吃小球\u0026#39;) running = True # 开启一个事件循环处理发生的事件 while running: # 从消息队列中获取事件并对事件进行处理 for event in pygame.event.get(): if event.type == pygame.QUIT: running = False if __name__ == \u0026#39;__main__\u0026#39;: main() 在窗口中绘图 可以通过pygame中draw模块的函数在窗口上绘图，可以绘制的图形包括：线条、矩形、多边形、圆、椭圆、圆弧等。需要说明的是，屏幕坐标系是将屏幕左上角设置为坐标原点(0, 0)，向右是x轴的正向，向下是y轴的正向，在表示位置或者设置尺寸的时候，我们默认的单位都是像素。所谓像素就是屏幕上的一个点，你可以用浏览图片的软件试着将一张图片放大若干倍，就可以看到这些点。pygame中表示颜色用的是色光三原色表示法，即通过一个元组或列表来指定颜色的RGB值，每个值都在0~255之间，因为是每种原色都用一个8位（bit）的值来表示，三种颜色相当于一共由24位构成，这也就是常说的“24位颜色表示法”。\nimport pygame def main(): # 初始化导入的pygame中的模块 pygame.init() # 初始化用于显示的窗口并设置窗口尺寸 screen = pygame.display.set_mode((800, 600)) # 设置当前窗口的标题 pygame.display.set_caption(\u0026#39;大球吃小球\u0026#39;) # 设置窗口的背景色(颜色是由红绿蓝三原色构成的元组) screen.fill((242, 242, 242)) # 绘制一个圆(参数分别是: 屏幕, 颜色, 圆心位置, 半径, 0表示填充圆) pygame.draw.circle(screen, (255, 0, 0,), (100, 100), 30, 0) # 刷新当前窗口(渲染窗口将绘制的图像呈现出来) pygame.display.flip() running = True # 开启一个事件循环处理发生的事件 while running: # 从消息队列中获取事件并对事件进行处理 for event in pygame.event.get(): if event.type == pygame.QUIT: running = False if __name__ == \u0026#39;__main__\u0026#39;: main() 加载图像 如果需要直接加载图像到窗口上，可以使用pygame中image模块的函数来加载图像，再通过之前获得的窗口对象的blit方法渲染图像，代码如下所示。\nimport pygame def main(): # 初始化导入的pygame中的模块 pygame.init() # 初始化用于显示的窗口并设置窗口尺寸 screen = pygame.display.set_mode((800, 600)) # 设置当前窗口的标题 pygame.display.set_caption(\u0026#39;大球吃小球\u0026#39;) # 设置窗口的背景色(颜色是由红绿蓝三原色构成的元组) screen.fill((255, 255, 255)) # 通过指定的文件名加载图像 ball_image = pygame.image.load(\u0026#39;/Day01-15/res/ball.png\u0026#39;) # 在窗口上渲染图像 screen.blit(ball_image, (50, 50)) # 刷新当前窗口(渲染窗口将绘制的图像呈现出来) pygame.display.flip() running = True # 开启一个事件循环处理发生的事件 while running: # 从消息队列中获取事件并对事件进行处理 for event in pygame.event.get(): if event.type == pygame.QUIT: running = False if __name__ == \u0026#39;__main__\u0026#39;: main() 实现动画效果 说到动画这个词大家都不会陌生，事实上要实现动画效果，本身的原理也非常简单，就是将不连续的图片连续的播放，只要每秒钟达到了一定的帧数，那么就可以做出比较流畅的动画效果。如果要让上面代码中的小球动起来，可以将小球的位置用变量来表示，并在循环中修改小球的位置再刷新整个窗口即可。\nimport pygame def main(): # 初始化导入的pygame中的模块 pygame.init() # 初始化用于显示的窗口并设置窗口尺寸 screen = pygame.display.set_mode((800, 600)) # 设置当前窗口的标题 pygame.display.set_caption(\u0026#39;大球吃小球\u0026#39;) # 定义变量来表示小球在屏幕上的位置 x, y = 50, 50 running = True # 开启一个事件循环处理发生的事件 while running: # 从消息队列中获取事件并对事件进行处理 for event in pygame.event.get(): if event.type == pygame.QUIT: running = False screen.fill((255, 255, 255)) pygame.draw.circle(screen, (255, 0, 0,), (x, y), 30, 0) pygame.display.flip() # 每隔50毫秒就改变小球的位置再刷新窗口 pygame.time.delay(50) x, y = x + 5, y + 5 if __name__ == \u0026#39;__main__\u0026#39;: main() 碰撞检测 通常一个游戏中会有很多对象出现，而这些对象之间的“碰撞”在所难免，比如炮弹击中了飞机、箱子撞到了地面等。碰撞检测在绝大多数的游戏中都是一个必须得处理的至关重要的问题，pygame的sprite（动画精灵）模块就提供了对碰撞检测的支持，这里我们暂时不介绍sprite模块提供的功能，因为要检测两个小球有没有碰撞其实非常简单，只需要检查球心的距离有没有小于两个球的半径之和。为了制造出更多的小球，我们可以通过对鼠标事件的处理，在点击鼠标的位置创建颜色、大小和移动速度都随机的小球，当然要做到这一点，我们可以把之前学习到的面向对象的知识应用起来。\nfrom enum import Enum, unique from math import sqrt from random import randint import pygame @unique class Color(Enum): \u0026#34;\u0026#34;\u0026#34;颜色\u0026#34;\u0026#34;\u0026#34; RED = (255, 0, 0) GREEN = (0, 255, 0) BLUE = (0, 0, 255) BLACK = (0, 0, 0) WHITE = (255, 255, 255) GRAY = (242, 242, 242) @staticmethod def random_color(): \u0026#34;\u0026#34;\u0026#34;获得随机颜色\u0026#34;\u0026#34;\u0026#34; r = randint(0, 255) g = randint(0, 255) b = randint(0, 255) return (r, g, b) class Ball(object): \u0026#34;\u0026#34;\u0026#34;球\u0026#34;\u0026#34;\u0026#34; def __init__(self, x, y, radius, sx, sy, color=Color.RED): \u0026#34;\u0026#34;\u0026#34;初始化方法\u0026#34;\u0026#34;\u0026#34; self.x = x self.y = y self.radius = radius self.sx = sx self.sy = sy self.color = color self.alive = True def move(self, screen): \u0026#34;\u0026#34;\u0026#34;移动\u0026#34;\u0026#34;\u0026#34; self.x += self.sx self.y += self.sy if self.x - self.radius \u0026lt;= 0 or \\ self.x + self.radius \u0026gt;= screen.get_width(): self.sx = -self.sx if self.y - self.radius \u0026lt;= 0 or \\ self.y + self.radius \u0026gt;= screen.get_height(): self.sy = -self.sy def eat(self, other): \u0026#34;\u0026#34;\u0026#34;吃其他球\u0026#34;\u0026#34;\u0026#34; if self.alive and other.alive and self != other: dx, dy = self.x - other.x, self.y - other.y distance = sqrt(dx ** 2 + dy ** 2) if distance \u0026lt; self.radius + other.radius \\ and self.radius \u0026gt; other.radius: other.alive = False self.radius = self.radius + int(other.radius * 0.146) def draw(self, screen): \u0026#34;\u0026#34;\u0026#34;在窗口上绘制球\u0026#34;\u0026#34;\u0026#34; pygame.draw.circle(screen, self.color, (self.x, self.y), self.radius, 0) 事件处理 可以在事件循环中对鼠标事件进行处理，通过事件对象的type属性可以判定事件类型，再通过pos属性就可以获得鼠标点击的位置。如果要处理键盘事件也是在这个地方，做法与处理鼠标事件类似。\ndef main(): # 定义用来装所有球的容器 balls = [] # 初始化导入的pygame中的模块 pygame.init() # 初始化用于显示的窗口并设置窗口尺寸 screen = pygame.display.set_mode((800, 600)) # 设置当前窗口的标题 pygame.display.set_caption(\u0026#39;大球吃小球\u0026#39;) running = True # 开启一个事件循环处理发生的事件 while running: # 从消息队列中获取事件并对事件进行处理 for event in pygame.event.get(): if event.type == pygame.QUIT: running = False # 处理鼠标事件的代码 if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1: # 获得点击鼠标的位置 x, y = event.pos radius = randint(10, 100) sx, sy = randint(-10, 10), randint(-10, 10) color = Color.random_color() # 在点击鼠标的位置创建一个球(大小、速度和颜色随机) ball = Ball(x, y, radius, sx, sy, color) # 将球添加到列表容器中 balls.append(ball) screen.fill((255, 255, 255)) # 取出容器中的球 如果没被吃掉就绘制 被吃掉了就移除 for ball in balls: if ball.alive: ball.draw(screen) else: balls.remove(ball) pygame.display.flip() # 每隔50毫秒就改变球的位置再刷新窗口 pygame.time.delay(50) for ball in balls: ball.move(screen) # 检查球有没有吃到其他的球 for other in balls: ball.eat(other) if __name__ == \u0026#39;__main__\u0026#39;: main() 上面的两段代码合在一起，我们就完成了“大球吃小球”的游戏（如下图所示），准确的说它算不上一个游戏，但是做一个小游戏的基本知识我们已经通过这个例子告诉大家了，有了这些知识已经可以开始你的小游戏开发之旅了。其实上面的代码中还有很多值得改进的地方，比如刷新窗口以及让球移动起来的代码并不应该放在事件循环中，等学习了多线程的知识后，用一个后台线程来处理这些事可能是更好的选择。如果希望获得更好的用户体验，我们还可以在游戏中加入背景音乐以及在球与球发生碰撞时播放音效，利用pygame的mixer和music模块，我们可以很容易的做到这一点，大家可以自行了解这方面的知识。事实上，想了解更多的关于pygame的知识，最好的教程是pygame的官方网站，如果英语没毛病就可以赶紧去看看啦。 如果想开发3D游戏，pygame就显得力不从心了，对3D游戏开发如果有兴趣的读者不妨看看Panda3D。\n"},{"idx":21,"href":"/python100days/docs/Day01-15/11-%E6%96%87%E4%BB%B6%E5%92%8C%E5%BC%82%E5%B8%B8/","title":"11 文件和异常","content":" 文件和异常 实际开发中常常会遇到对数据进行持久化操作的场景，而实现数据持久化最直接简单的方式就是将数据保存到文件中。说到“文件”这个词，可能需要先科普一下关于文件系统的知识，但是这里我们并不浪费笔墨介绍这个概念，请大家自行通过维基百科进行了解。\n在Python中实现文件的读写操作其实非常简单，通过Python内置的open函数，我们可以指定文件名、操作模式、编码信息等来获得操作文件的对象，接下来就可以对文件进行读写操作了。这里所说的操作模式是指要打开什么样的文件（字符文件还是二进制文件）以及做什么样的操作（读、写还是追加），具体的如下表所示。\n   操作模式 具体含义     'r' 读取 （默认）   'w' 写入（会先截断之前的内容）   'x' 写入，如果文件已经存在会产生异常   'a' 追加，将内容写入到已有文件的末尾   'b' 二进制模式   't' 文本模式（默认）   '+' 更新（既可以读又可以写）    下面这张图来自于菜鸟教程网站，它展示了如果根据应用程序的需要来设置操作模式。\n读写文本文件 读取文本文件时，需要在使用open函数时指定好带路径的文件名（可以使用相对路径或绝对路径）并将文件模式设置为'r'（如果不指定，默认值也是'r'），然后通过encoding参数指定编码（如果不指定，默认值是None，那么在读取文件时使用的是操作系统默认的编码），如果不能保证保存文件时使用的编码方式与encoding参数指定的编码方式是一致的，那么就可能因无法解码字符而导致读取失败。下面的例子演示了如何读取一个纯文本文件。\ndef main(): f = open(\u0026#39;致橡树.txt\u0026#39;, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) print(f.read()) f.close() if __name__ == \u0026#39;__main__\u0026#39;: main() 请注意上面的代码，如果open函数指定的文件并不存在或者无法打开，那么将引发异常状况导致程序崩溃。为了让代码有一定的健壮性和容错性，我们可以使用Python的异常机制对可能在运行时发生状况的代码进行适当的处理，如下所示。\ndef main(): f = None try: f = open(\u0026#39;致橡树.txt\u0026#39;, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) print(f.read()) except FileNotFoundError: print(\u0026#39;无法打开指定的文件!\u0026#39;) except LookupError: print(\u0026#39;指定了未知的编码!\u0026#39;) except UnicodeDecodeError: print(\u0026#39;读取文件时解码错误!\u0026#39;) finally: if f: f.close() if __name__ == \u0026#39;__main__\u0026#39;: main() 在Python中，我们可以将那些在运行时可能会出现状况的代码放在try代码块中，在try代码块的后面可以跟上一个或多个except来捕获可能出现的异常状况。例如在上面读取文件的过程中，文件找不到会引发FileNotFoundError，指定了未知的编码会引发LookupError，而如果读取文件时无法按指定方式解码会引发UnicodeDecodeError，我们在try后面跟上了三个except分别处理这三种不同的异常状况。最后我们使用finally代码块来关闭打开的文件，释放掉程序中获取的外部资源，由于finally块的代码不论程序正常还是异常都会执行到（甚至是调用了sys模块的exit函数退出Python环境，finally块都会被执行，因为exit函数实质上是引发了SystemExit异常），因此我们通常把finally块称为“总是执行代码块”，它最适合用来做释放外部资源的操作。如果不愿意在finally代码块中关闭文件对象释放资源，也可以使用上下文语法，通过with关键字指定文件对象的上下文环境并在离开上下文环境时自动释放文件资源，代码如下所示。\ndef main(): try: with open(\u0026#39;致橡树.txt\u0026#39;, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: print(f.read()) except FileNotFoundError: print(\u0026#39;无法打开指定的文件!\u0026#39;) except LookupError: print(\u0026#39;指定了未知的编码!\u0026#39;) except UnicodeDecodeError: print(\u0026#39;读取文件时解码错误!\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: main() 除了使用文件对象的read方法读取文件之外，还可以使用for-in循环逐行读取或者用readlines方法将文件按行读取到一个列表容器中，代码如下所示。\nimport time def main(): # 一次性读取整个文件内容 with open(\u0026#39;致橡树.txt\u0026#39;, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: print(f.read()) # 通过for-in循环逐行读取 with open(\u0026#39;致橡树.txt\u0026#39;, mode=\u0026#39;r\u0026#39;) as f: for line in f: print(line, end=\u0026#39;\u0026#39;) time.sleep(0.5) print() # 读取文件按行读取到列表中 with open(\u0026#39;致橡树.txt\u0026#39;) as f: lines = f.readlines() print(lines) if __name__ == \u0026#39;__main__\u0026#39;: main() 要将文本信息写入文件文件也非常简单，在使用open函数时指定好文件名并将文件模式设置为'w'即可。注意如果需要对文件内容进行追加式写入，应该将模式设置为'a'。如果要写入的文件不存在会自动创建文件而不是引发异常。下面的例子演示了如何将1-9999之间的素数分别写入三个文件中（1-99之间的素数保存在a.txt中，100-999之间的素数保存在b.txt中，1000-9999之间的素数保存在c.txt中）。\nfrom math import sqrt def is_prime(n): \u0026#34;\u0026#34;\u0026#34;判断素数的函数\u0026#34;\u0026#34;\u0026#34; assert n \u0026gt; 0 for factor in range(2, int(sqrt(n)) + 1): if n % factor == 0: return False return True if n != 1 else False def main(): filenames = (\u0026#39;a.txt\u0026#39;, \u0026#39;b.txt\u0026#39;, \u0026#39;c.txt\u0026#39;) fs_list = [] try: for filename in filenames: fs_list.append(open(filename, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;)) for number in range(1, 10000): if is_prime(number): if number \u0026lt; 100: fs_list[0].write(str(number) + \u0026#39;\\n\u0026#39;) elif number \u0026lt; 1000: fs_list[1].write(str(number) + \u0026#39;\\n\u0026#39;) else: fs_list[2].write(str(number) + \u0026#39;\\n\u0026#39;) except IOError as ex: print(ex) print(\u0026#39;写文件时发生错误!\u0026#39;) finally: for fs in fs_list: fs.close() print(\u0026#39;操作完成!\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: main() 读写二进制文件 知道了如何读写文本文件要读写二进制文件也就很简单了，下面的代码实现了复制图片文件的功能。\ndef main(): try: with open(\u0026#39;guido.jpg\u0026#39;, \u0026#39;rb\u0026#39;) as fs1: data = fs1.read() print(type(data)) # \u0026lt;class \u0026#39;bytes\u0026#39;\u0026gt; with open(\u0026#39;吉多.jpg\u0026#39;, \u0026#39;wb\u0026#39;) as fs2: fs2.write(data) except FileNotFoundError as e: print(\u0026#39;指定的文件无法打开.\u0026#39;) except IOError as e: print(\u0026#39;读写文件时出现错误.\u0026#39;) print(\u0026#39;程序执行结束.\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: main() 读写JSON文件 通过上面的讲解，我们已经知道如何将文本数据和二进制数据保存到文件中，那么这里还有一个问题，如果希望把一个列表或者一个字典中的数据保存到文件中又该怎么做呢？答案是将数据以JSON格式进行保存。JSON是“JavaScript Object Notation”的缩写，它本来是JavaScript语言中创建对象的一种字面量语法，现在已经被广泛的应用于跨平台跨语言的数据交换，原因很简单，因为JSON也是纯文本，任何系统任何编程语言处理纯文本都是没有问题的。目前JSON基本上已经取代了XML作为异构系统间交换数据的事实标准。关于JSON的知识，更多的可以参考JSON的官方网站，从这个网站也可以了解到每种语言处理JSON数据格式可以使用的工具或三方库，下面是一个JSON的简单例子。\n{ \u0026#34;name\u0026#34;: \u0026#34;骆昊\u0026#34;, \u0026#34;age\u0026#34;: 38, \u0026#34;qq\u0026#34;: 957658, \u0026#34;friends\u0026#34;: [\u0026#34;王大锤\u0026#34;, \u0026#34;白元芳\u0026#34;], \u0026#34;cars\u0026#34;: [ {\u0026#34;brand\u0026#34;: \u0026#34;BYD\u0026#34;, \u0026#34;max_speed\u0026#34;: 180}, {\u0026#34;brand\u0026#34;: \u0026#34;Audi\u0026#34;, \u0026#34;max_speed\u0026#34;: 280}, {\u0026#34;brand\u0026#34;: \u0026#34;Benz\u0026#34;, \u0026#34;max_speed\u0026#34;: 320} ] } 可能大家已经注意到了，上面的JSON跟Python中的字典其实是一样一样的，事实上JSON的数据类型和Python的数据类型是很容易找到对应关系的，如下面两张表所示。\n   JSON Python     object dict   array list   string str   number (int / real) int / float   true / false True / False   null None       Python JSON     dict object   list, tuple array   str string   int, float, int- \u0026amp; float-derived Enums number   True / False true / false   None null    我们使用Python中的json模块就可以将字典或列表以JSON格式保存到文件中，代码如下所示。\nimport json def main(): mydict = { \u0026#39;name\u0026#39;: \u0026#39;骆昊\u0026#39;, \u0026#39;age\u0026#39;: 38, \u0026#39;qq\u0026#39;: 957658, \u0026#39;friends\u0026#39;: [\u0026#39;王大锤\u0026#39;, \u0026#39;白元芳\u0026#39;], \u0026#39;cars\u0026#39;: [ {\u0026#39;brand\u0026#39;: \u0026#39;BYD\u0026#39;, \u0026#39;max_speed\u0026#39;: 180}, {\u0026#39;brand\u0026#39;: \u0026#39;Audi\u0026#39;, \u0026#39;max_speed\u0026#39;: 280}, {\u0026#39;brand\u0026#39;: \u0026#39;Benz\u0026#39;, \u0026#39;max_speed\u0026#39;: 320} ] } try: with open(\u0026#39;data.json\u0026#39;, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as fs: json.dump(mydict, fs) except IOError as e: print(e) print(\u0026#39;保存数据完成!\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: main() json模块主要有四个比较重要的函数，分别是：\n dump - 将Python对象按照JSON格式序列化到文件中 dumps - 将Python对象处理成JSON格式的字符串 load - 将文件中的JSON数据反序列化成对象 loads - 将字符串的内容反序列化成Python对象  这里出现了两个概念，一个叫序列化，一个叫反序列化。自由的百科全书维基百科上对这两个概念是这样解释的：“序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换为可以存储或传输的形式，这样在需要的时候能够恢复到原先的状态，而且通过序列化的数据重新获取字节时，可以利用这些字节来产生原始对象的副本（拷贝）。与这个过程相反的动作，即从一系列字节中提取数据结构的操作，就是反序列化（deserialization）”。\n目前绝大多数网络数据服务（或称之为网络API）都是基于HTTP协议提供JSON格式的数据，关于HTTP协议的相关知识，可以看看阮一峰老师的《HTTP协议入门》，如果想了解国内的网络数据服务，可以看看聚合数据和阿凡达数据等网站，国外的可以看看{API}Search网站。下面的例子演示了如何使用requests模块（封装得足够好的第三方网络访问模块）访问网络API获取国内新闻，如何通过json模块解析JSON数据并显示新闻标题，这个例子使用了天行数据提供的国内新闻数据接口，其中的APIKey需要自己到该网站申请。\nimport requests import json def main(): resp = requests.get(\u0026#39;http://api.tianapi.com/guonei/?key=APIKey\u0026amp;num=10\u0026#39;) data_model = json.loads(resp.text) for news in data_model[\u0026#39;newslist\u0026#39;]: print(news[\u0026#39;title\u0026#39;]) if __name__ == \u0026#39;__main__\u0026#39;: main() 在Python中要实现序列化和反序列化除了使用json模块之外，还可以使用pickle和shelve模块，但是这两个模块是使用特有的序列化协议来序列化数据，因此序列化后的数据只能被Python识别。关于这两个模块的相关知识可以自己看看网络上的资料。另外，如果要了解更多的关于Python异常机制的知识，可以看看segmentfault上面的文章《总结：Python中的异常处理》，这篇文章不仅介绍了Python中异常机制的使用，还总结了一系列的最佳实践，很值得一读。\n"},{"idx":22,"href":"/python100days/docs/Day01-15/12-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","title":"12 字符串和正则表达式","content":" 使用正则表达式 正则表达式相关知识 在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要，正则表达式就是用于描述这些规则的工具，换句话说正则表达式是一种工具，它定义了字符串的匹配模式（如何检查一个字符串是否有跟某种模式匹配的部分或者从一个字符串中将与模式匹配的部分提取出来或者替换掉）。如果你在Windows操作系统中使用过文件查找并且在指定文件名时使用过通配符（*和?），那么正则表达式也是与之类似的用来进行文本匹配的工具，只不过比起通配符正则表达式更强大，它能更精确地描述你的需求（当然你付出的代价是书写一个正则表达式比打出一个通配符要复杂得多，要知道任何给你带来好处的东西都是有代价的，就如同学习一门编程语言一样），比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串（像028-12345678或0813-7654321），这不就是国内的座机号码吗。最初计算机是为了做数学运算而诞生的，处理的信息基本上都是数值，而今天我们在日常工作中处理的信息基本上都是文本数据，我们希望计算机能够识别和处理符合某些模式的文本，正则表达式就显得非常重要了。今天几乎所有的编程语言都提供了对正则表达式操作的支持，Python通过标准库中的re模块来支持正则表达式操作。\n我们可以考虑下面一个问题：我们从某个地方（可能是一个文本文件，也可能是网络上的一则新闻）获得了一个字符串，希望在字符串中找出手机号和座机号。当然我们可以设定手机号是11位的数字（注意并不是随机的11位数字，因为你没有见过“25012345678”这样的手机号吧）而座机号跟上一段中描述的模式相同，如果不使用正则表达式要完成这个任务就会很麻烦。\n关于正则表达式的相关知识，大家可以阅读一篇非常有名的博客叫《正则表达式30分钟入门教程》，读完这篇文章后你就可以看懂下面的表格，这是我们对正则表达式中的一些基本符号进行的扼要总结。\n   符号 解释 示例 说明     . 匹配任意字符 b.t 可以匹配bat / but / b#t / b1t等   \\w 匹配字母/数字/下划线 b\\wt 可以匹配bat / b1t / b_t等\n但不能匹配b#t   \\s 匹配空白字符（包括\\r、\\n、\\t等） love\\syou 可以匹配love you   \\d 匹配数字 \\d\\d 可以匹配01 / 23 / 99等   \\b 匹配单词的边界 \\bThe\\b    ^ 匹配字符串的开始 ^The 可以匹配The开头的字符串   $ 匹配字符串的结束 .exe$ 可以匹配.exe结尾的字符串   \\W 匹配非字母/数字/下划线 b\\Wt 可以匹配b#t / b@t等\n但不能匹配but / b1t / b_t等   \\S 匹配非空白字符 love\\Syou 可以匹配love#you等\n但不能匹配love you   \\D 匹配非数字 \\d\\D 可以匹配9a / 3# / 0F等   \\B 匹配非单词边界 \\Bio\\B    [] 匹配来自字符集的任意单一字符 [aeiou] 可以匹配任一元音字母字符   [^] 匹配不在字符集中的任意单一字符 [^aeiou] 可以匹配任一非元音字母字符   * 匹配0次或多次 \\w*    + 匹配1次或多次 \\w+    ? 匹配0次或1次 \\w?    {N} 匹配N次 \\w{3}    {M,} 匹配至少M次 \\w{3,}    {M,N} 匹配至少M次至多N次 \\w{3,6}    | 分支 foo|bar 可以匹配foo或者bar   (?#) 注释     (exp) 匹配exp并捕获到自动命名的组中     (?\u0026nbsp;\u0026lt;name\u0026gt;exp) 匹配exp并捕获到名为name的组中     (?:exp) 匹配exp但是不捕获匹配的文本     (?=exp) 匹配exp前面的位置 \\b\\w+(?=ing) 可以匹配I\u0026rsquo;m dancing中的danc   (?\u0026lt;=exp) 匹配exp后面的位置 (?\u0026lt;=\\bdanc)\\w+\\b 可以匹配I love dancing and reading中的第一个ing   (?!exp) 匹配后面不是exp的位置     (?\u0026lt;!exp) 匹配前面不是exp的位置     *? 重复任意次，但尽可能少重复 a.*b\na.*?b 将正则表达式应用于aabab，前者会匹配整个字符串aabab，后者会匹配aab和ab两个字符串   +? 重复1次或多次，但尽可能少重复     ?? 重复0次或1次，但尽可能少重复     {M,N}? 重复M到N次，但尽可能少重复     {M,}? 重复M次以上，但尽可能少重复       说明： 如果需要匹配的字符是正则表达式中的特殊字符，那么可以使用\\进行转义处理，例如想匹配小数点可以写成\\.就可以了，因为直接写.会匹配任意字符；同理，想匹配圆括号必须写成\\(和\\)，否则圆括号被视为正则表达式中的分组。\n Python对正则表达式的支持 Python提供了re模块来支持正则表达式相关操作，下面是re模块中的核心函数。\n   函数 说明     compile(pattern, flags=0) 编译正则表达式返回正则表达式对象   match(pattern, string, flags=0) 用正则表达式匹配字符串 成功返回匹配对象 否则返回None   search(pattern, string, flags=0) 搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回None   split(pattern, string, maxsplit=0, flags=0) 用正则表达式指定的模式分隔符拆分字符串 返回列表   sub(pattern, repl, string, count=0, flags=0) 用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用count指定替换的次数   fullmatch(pattern, string, flags=0) match函数的完全匹配（从字符串开头到结尾）版本   findall(pattern, string, flags=0) 查找字符串所有与正则表达式匹配的模式 返回字符串的列表   finditer(pattern, string, flags=0) 查找字符串所有与正则表达式匹配的模式 返回一个迭代器   purge() 清除隐式编译的正则表达式的缓存   re.I / re.IGNORECASE 忽略大小写匹配标记   re.M / re.MULTILINE 多行匹配标记     说明： 上面提到的re模块中的这些函数，实际开发中也可以用正则表达式对象的方法替代对这些函数的使用，如果一个正则表达式需要重复的使用，那么先通过compile函数编译正则表达式并创建出正则表达式对象无疑是更为明智的选择。\n 下面我们通过一系列的例子来告诉大家在Python中如何使用正则表达式。\n例子1：验证输入用户名和QQ号是否有效并给出对应的提示信息。 \u0026#34;\u0026#34;\u0026#34; 验证输入用户名和QQ号是否有效并给出对应的提示信息 要求：用户名必须由字母、数字或下划线构成且长度在6~20个字符之间，QQ号是5~12的数字且首位不能为0 \u0026#34;\u0026#34;\u0026#34; import re def main(): username = input(\u0026#39;请输入用户名: \u0026#39;) qq = input(\u0026#39;请输入QQ号: \u0026#39;) # match函数的第一个参数是正则表达式字符串或正则表达式对象 # 第二个参数是要跟正则表达式做匹配的字符串对象 m1 = re.match(r\u0026#39;^[0-9a-zA-Z_]{6,20}$\u0026#39;, username) if not m1: print(\u0026#39;请输入有效的用户名.\u0026#39;) m2 = re.match(r\u0026#39;^[1-9]\\d{4,11}$\u0026#39;, qq) if not m2: print(\u0026#39;请输入有效的QQ号.\u0026#39;) if m1 and m2: print(\u0026#39;你输入的信息是有效的!\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: main()  提示： 上面在书写正则表达式时使用了“原始字符串”的写法（在字符串前面加上了r），所谓“原始字符串”就是字符串中的每个字符都是它原始的意义，说得更直接一点就是字符串中没有所谓的转义字符啦。因为正则表达式中有很多元字符和需要进行转义的地方，如果不使用原始字符串就需要将反斜杠写作\\\\，例如表示数字的\\d得书写成\\\\d，这样不仅写起来不方便，阅读的时候也会很吃力。\n 例子2：从一段文字中提取出国内手机号码。 下面这张图是截止到2017年底，国内三家运营商推出的手机号段。\nimport re def main(): # 创建正则表达式对象 使用了前瞻和回顾来保证手机号前后不应该出现数字 pattern = re.compile(r\u0026#39;(?\u0026lt;=\\D)1[34578]\\d{9}(?=\\D)\u0026#39;) sentence = \u0026#39;\u0026#39;\u0026#39; 重要的事情说8130123456789遍，我的手机号是13512346789这个靓号， 不是15600998765，也是110或119，王大锤的手机号才是15600998765。 \u0026#39;\u0026#39;\u0026#39; # 查找所有匹配并保存到一个列表中 mylist = re.findall(pattern, sentence) print(mylist) print(\u0026#39;--------华丽的分隔线--------\u0026#39;) # 通过迭代器取出匹配对象并获得匹配的内容 for temp in pattern.finditer(sentence): print(temp.group()) print(\u0026#39;--------华丽的分隔线--------\u0026#39;) # 通过search函数指定搜索位置找出所有匹配 m = pattern.search(sentence) while m: print(m.group()) m = pattern.search(sentence, m.end()) if __name__ == \u0026#39;__main__\u0026#39;: main()  说明： 上面匹配国内手机号的正则表达式并不够好，因为像14开头的号码只有145或147，而上面的正则表达式并没有考虑这种情况，要匹配国内手机号，更好的正则表达式的写法是：(?\u0026lt;=\\D)(1[38]\\d{9}|14[57]\\d{8}|15[0-35-9]\\d{8}|17[678]\\d{8})(?=\\D)，国内最近好像有19和16开头的手机号了，但是这个暂时不在我们考虑之列。\n 例子3：替换字符串中的不良内容 import re def main(): sentence = \u0026#39;你丫是傻叉吗? 我操你大爷的. Fuck you.\u0026#39; purified = re.sub(\u0026#39;[操肏艹]|fuck|shit|傻[比屄逼叉缺吊屌]|煞笔\u0026#39;, \u0026#39;*\u0026#39;, sentence, flags=re.IGNORECASE) print(purified) # 你丫是*吗? 我*你大爷的. * you. if __name__ == \u0026#39;__main__\u0026#39;: main()  说明： re模块的正则表达式相关函数中都有一个flags参数，它代表了正则表达式的匹配标记，可以通过该标记来指定匹配时是否忽略大小写、是否进行多行匹配、是否显示调试信息等。如果需要为flags参数指定多个值，可以使用按位或运算符进行叠加，如flags=re.I | re.M。\n 例子4：拆分长字符串 import re def main(): poem = \u0026#39;窗前明月光，疑是地上霜。举头望明月，低头思故乡。\u0026#39; sentence_list = re.split(r\u0026#39;[，。, .]\u0026#39;, poem) while \u0026#39;\u0026#39; in sentence_list: sentence_list.remove(\u0026#39;\u0026#39;) print(sentence_list) # [\u0026#39;窗前明月光\u0026#39;, \u0026#39;疑是地上霜\u0026#39;, \u0026#39;举头望明月\u0026#39;, \u0026#39;低头思故乡\u0026#39;] if __name__ == \u0026#39;__main__\u0026#39;: main() 后话 如果要从事爬虫类应用的开发，那么正则表达式一定是一个非常好的助手，因为它可以帮助我们迅速的从网页代码中发现某种我们指定的模式并提取出我们需要的信息，当然对于初学者来收，要编写一个正确的适当的正则表达式可能并不是一件容易的事情（当然有些常用的正则表达式可以直接在网上找找），所以实际开发爬虫应用的时候，有很多人会选择Beautiful Soup或Lxml来进行匹配和信息的提取，前者简单方便但是性能较差，后者既好用性能也好，但是安装稍嫌麻烦，这些内容我们会在后期的爬虫专题中为大家介绍。\n"},{"idx":23,"href":"/python100days/docs/Day01-15/13-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/","title":"13 进程和线程","content":" 进程和线程 今天我们使用的计算机早已进入多CPU或多核时代，而我们使用的操作系统都是支持“多任务”的操作系统，这使得我们可以同时运行多个程序，也可以将一个程序分解为若干个相对独立的子任务，让多个子任务并发的执行，从而缩短程序的执行时间，同时也让用户获得更好的体验。因此在当下不管是用什么编程语言进行开发，实现让程序同时执行多个任务也就是常说的“并发编程”，应该是程序员必备技能之一。为此，我们需要先讨论两个概念，一个叫进程，一个叫线程。\n概念 进程就是操作系统中执行的一个程序，操作系统以进程为单位分配存储空间，每个进程都有自己的地址空间、数据栈以及其他用于跟踪进程执行的辅助数据，操作系统管理所有进程的执行，为它们合理的分配资源。进程可以通过fork或spawn的方式来创建新的进程来执行其他的任务，不过新的进程也有自己独立的内存空间，因此必须通过进程间通信机制（IPC，Inter-Process Communication）来实现数据共享，具体的方式包括管道、信号、套接字、共享内存区等。\n一个进程还可以拥有多个并发的执行线索，简单的说就是拥有多个可以获得CPU调度的执行单元，这就是所谓的线程。由于线程在同一个进程下，它们可以共享相同的上下文，因此相对于进程而言，线程间的信息共享和通信更加容易。当然在单核CPU系统中，真正的并发是不可能的，因为在某个时刻能够获得CPU的只有唯一的一个线程，多个线程共享了CPU的执行时间。使用多线程实现并发编程为程序带来的好处是不言而喻的，最主要的体现在提升程序的性能和改善用户体验，今天我们使用的软件几乎都用到了多线程技术，这一点可以利用系统自带的进程监控工具（如macOS中的“活动监视器”、Windows中的“任务管理器”）来证实，如下图所示。\n当然多线程也并不是没有坏处，站在其他进程的角度，多线程的程序对其他程序并不友好，因为它占用了更多的CPU执行时间，导致其他程序无法获得足够的CPU执行时间；另一方面，站在开发者的角度，编写和调试多线程的程序都对开发者有较高的要求，对于初学者来说更加困难。\nPython既支持多进程又支持多线程，因此使用Python实现并发编程主要有3种方式：多进程、多线程、多进程+多线程。\nPython中的多进程 Unix和Linux操作系统上提供了fork()系统调用来创建进程，调用fork()函数的是父进程，创建出的是子进程，子进程是父进程的一个拷贝，但是子进程拥有自己的PID。fork()函数非常特殊它会返回两次，父进程中可以通过fork()函数的返回值得到子进程的PID，而子进程中的返回值永远都是0。Python的os模块提供了fork()函数。由于Windows系统没有fork()调用，因此要实现跨平台的多进程编程，可以使用multiprocessing模块的Process类来创建子进程，而且该模块还提供了更高级的封装，例如批量启动进程的进程池（Pool）、用于进程间通信的队列（Queue）和管道（Pipe）等。\n下面用一个下载文件的例子来说明使用多进程和不使用多进程到底有什么差别，先看看下面的代码。\nfrom random import randint from time import time, sleep def download_task(filename): print(\u0026#39;开始下载%s...\u0026#39; % filename) time_to_download = randint(5, 10) sleep(time_to_download) print(\u0026#39;%s下载完成! 耗费了%d秒\u0026#39; % (filename, time_to_download)) def main(): start = time() download_task(\u0026#39;Python从入门到住院.pdf\u0026#39;) download_task(\u0026#39;Peking Hot.avi\u0026#39;) end = time() print(\u0026#39;总共耗费了%.2f秒.\u0026#39; % (end - start)) if __name__ == \u0026#39;__main__\u0026#39;: main() 下面是运行程序得到的一次运行结果。\n开始下载Python从入门到住院.pdf... Python从入门到住院.pdf下载完成! 耗费了6秒 开始下载Peking Hot.avi... Peking Hot.avi下载完成! 耗费了7秒 总共耗费了13.01秒. 从上面的例子可以看出，如果程序中的代码只能按顺序一点点的往下执行，那么即使执行两个毫不相关的下载任务，也需要先等待一个文件下载完成后才能开始下一个下载任务，很显然这并不合理也没有效率。接下来我们使用多进程的方式将两个下载任务放到不同的进程中，代码如下所示。\nfrom multiprocessing import Process from os import getpid from random import randint from time import time, sleep def download_task(filename): print(\u0026#39;启动下载进程，进程号[%d].\u0026#39; % getpid()) print(\u0026#39;开始下载%s...\u0026#39; % filename) time_to_download = randint(5, 10) sleep(time_to_download) print(\u0026#39;%s下载完成! 耗费了%d秒\u0026#39; % (filename, time_to_download)) def main(): start = time() p1 = Process(target=download_task, args=(\u0026#39;Python从入门到住院.pdf\u0026#39;, )) p1.start() p2 = Process(target=download_task, args=(\u0026#39;Peking Hot.avi\u0026#39;, )) p2.start() p1.join() p2.join() end = time() print(\u0026#39;总共耗费了%.2f秒.\u0026#39; % (end - start)) if __name__ == \u0026#39;__main__\u0026#39;: main() 在上面的代码中，我们通过Process类创建了进程对象，通过target参数我们传入一个函数来表示进程启动后要执行的代码，后面的args是一个元组，它代表了传递给函数的参数。Process对象的start方法用来启动进程，而join方法表示等待进程执行结束。运行上面的代码可以明显发现两个下载任务“同时”启动了，而且程序的执行时间将大大缩短，不再是两个任务的时间总和。下面是程序的一次执行结果。\n启动下载进程，进程号[1530]. 开始下载Python从入门到住院.pdf... 启动下载进程，进程号[1531]. 开始下载Peking Hot.avi... Peking Hot.avi下载完成! 耗费了7秒 Python从入门到住院.pdf下载完成! 耗费了10秒 总共耗费了10.01秒. 我们也可以使用subprocess模块中的类和函数来创建和启动子进程，然后通过管道来和子进程通信，这些内容我们不在此进行讲解，有兴趣的读者可以自己了解这些知识。接下来我们将重点放在如何实现两个进程间的通信。我们启动两个进程，一个输出Ping，一个输出Pong，两个进程输出的Ping和Pong加起来一共10个。听起来很简单吧，但是如果这样写可是错的哦。\nfrom multiprocessing import Process from time import sleep counter = 0 def sub_task(string): global counter while counter \u0026lt; 10: print(string, end=\u0026#39;\u0026#39;, flush=True) counter += 1 sleep(0.01) def main(): Process(target=sub_task, args=(\u0026#39;Ping\u0026#39;, )).start() Process(target=sub_task, args=(\u0026#39;Pong\u0026#39;, )).start() if __name__ == \u0026#39;__main__\u0026#39;: main() 看起来没毛病，但是最后的结果是Ping和Pong各输出了10个，Why？当我们在程序中创建进程的时候，子进程复制了父进程及其所有的数据结构，每个子进程有自己独立的内存空间，这也就意味着两个子进程中各有一个counter变量，所以结果也就可想而知了。要解决这个问题比较简单的办法是使用multiprocessing模块中的Queue类，它是可以被多个进程共享的队列，底层是通过管道和[信号量（semaphore）]()机制来实现的，有兴趣的读者可以自己尝试一下。\nPython中的多线程 在Python早期的版本中就引入了thread模块（现在名为_thread）来实现多线程编程，然而该模块过于底层，而且很多功能都没有提供，因此目前的多线程开发我们推荐使用threading模块，该模块对多线程编程提供了更好的面向对象的封装。我们把刚才下载文件的例子用多线程的方式来实现一遍。\nfrom random import randint from threading import Thread from time import time, sleep def download(filename): print(\u0026#39;开始下载%s...\u0026#39; % filename) time_to_download = randint(5, 10) sleep(time_to_download) print(\u0026#39;%s下载完成! 耗费了%d秒\u0026#39; % (filename, time_to_download)) def main(): start = time() t1 = Thread(target=download, args=(\u0026#39;Python从入门到住院.pdf\u0026#39;,)) t1.start() t2 = Thread(target=download, args=(\u0026#39;Peking Hot.avi\u0026#39;,)) t2.start() t1.join() t2.join() end = time() print(\u0026#39;总共耗费了%.3f秒\u0026#39; % (end - start)) if __name__ == \u0026#39;__main__\u0026#39;: main() 我们可以直接使用threading模块的Thread类来创建线程，但是我们之前讲过一个非常重要的概念叫“继承”，我们可以从已有的类创建新类，因此也可以通过继承Thread类的方式来创建自定义的线程类，然后再创建线程对象并启动线程。代码如下所示。\nfrom random import randint from threading import Thread from time import time, sleep class DownloadTask(Thread): def __init__(self, filename): super().__init__() self._filename = filename def run(self): print(\u0026#39;开始下载%s...\u0026#39; % self._filename) time_to_download = randint(5, 10) sleep(time_to_download) print(\u0026#39;%s下载完成! 耗费了%d秒\u0026#39; % (self._filename, time_to_download)) def main(): start = time() t1 = DownloadTask(\u0026#39;Python从入门到住院.pdf\u0026#39;) t1.start() t2 = DownloadTask(\u0026#39;Peking Hot.avi\u0026#39;) t2.start() t1.join() t2.join() end = time() print(\u0026#39;总共耗费了%.2f秒.\u0026#39; % (end - start)) if __name__ == \u0026#39;__main__\u0026#39;: main() 因为多个线程可以共享进程的内存空间，因此要实现多个线程间的通信相对简单，大家能想到的最直接的办法就是设置一个全局变量，多个线程共享这个全局变量即可。但是当多个线程共享同一个变量（我们通常称之为“资源”）的时候，很有可能产生不可控的结果从而导致程序失效甚至崩溃。如果一个资源被多个线程竞争使用，那么我们通常称之为“临界资源”，对“临界资源”的访问需要加上保护，否则资源会处于“混乱”的状态。下面的例子演示了100个线程向同一个银行账户转账（转入1元钱）的场景，在这个例子中，银行账户就是一个临界资源，在没有保护的情况下我们很有可能会得到错误的结果。\nfrom time import sleep from threading import Thread class Account(object): def __init__(self): self._balance = 0 def deposit(self, money): # 计算存款后的余额 new_balance = self._balance + money # 模拟受理存款业务需要0.01秒的时间 sleep(0.01) # 修改账户余额 self._balance = new_balance @property def balance(self): return self._balance class AddMoneyThread(Thread): def __init__(self, account, money): super().__init__() self._account = account self._money = money def run(self): self._account.deposit(self._money) def main(): account = Account() threads = [] # 创建100个存款的线程向同一个账户中存钱 for _ in range(100): t = AddMoneyThread(account, 1) threads.append(t) t.start() # 等所有存款的线程都执行完毕 for t in threads: t.join() print(\u0026#39;账户余额为: ￥%d元\u0026#39; % account.balance) if __name__ == \u0026#39;__main__\u0026#39;: main() 运行上面的程序，结果让人大跌眼镜，100个线程分别向账户中转入1元钱，结果居然远远小于100元。之所以出现这种情况是因为我们没有对银行账户这个“临界资源”加以保护，多个线程同时向账户中存钱时，会一起执行到new_balance = self._balance + money这行代码，多个线程得到的账户余额都是初始状态下的0，所以都是0上面做了+1的操作，因此得到了错误的结果。在这种情况下，“锁”就可以派上用场了。我们可以通过“锁”来保护“临界资源”，只有获得“锁”的线程才能访问“临界资源”，而其他没有得到“锁”的线程只能被阻塞起来，直到获得“锁”的线程释放了“锁”，其他线程才有机会获得“锁”，进而访问被保护的“临界资源”。下面的代码演示了如何使用“锁”来保护对银行账户的操作，从而获得正确的结果。\nfrom time import sleep from threading import Thread, Lock class Account(object): def __init__(self): self._balance = 0 self._lock = Lock() def deposit(self, money): # 先获取锁才能执行后续的代码 self._lock.acquire() try: new_balance = self._balance + money sleep(0.01) self._balance = new_balance finally: # 在finally中执行释放锁的操作保证正常异常锁都能释放 self._lock.release() @property def balance(self): return self._balance class AddMoneyThread(Thread): def __init__(self, account, money): super().__init__() self._account = account self._money = money def run(self): self._account.deposit(self._money) def main(): account = Account() threads = [] for _ in range(100): t = AddMoneyThread(account, 1) threads.append(t) t.start() for t in threads: t.join() print(\u0026#39;账户余额为: ￥%d元\u0026#39; % account.balance) if __name__ == \u0026#39;__main__\u0026#39;: main() 比较遗憾的一件事情是Python的多线程并不能发挥CPU的多核特性，这一点只要启动几个执行死循环的线程就可以得到证实了。之所以如此，是因为Python的解释器有一个“全局解释器锁”（GIL）的东西，任何线程执行前必须先获得GIL锁，然后每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行，这是一个历史遗留问题，但是即便如此，就如我们之前举的例子，使用多线程在提升执行效率和改善用户体验方面仍然是有积极意义的。\n多进程还是多线程 无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢？我们打个比方，假设你不幸正在准备中考，每天晚上需要做语文、数学、英语、物理、化学这5科的作业，每项作业耗时1小时。如果你先花1小时做语文作业，做完了，再花1小时做数学作业，这样，依次全部做完，一共花5小时，这种方式称为单任务模型。如果你打算切换到多任务模型，可以先做1分钟语文，再切换到数学作业，做1分钟，再切换到英语，以此类推，只要切换速度足够快，这种方式就和单核CPU执行多任务是一样的了，以旁观者的角度来看，你就正在同时写5科作业。\n但是，切换作业是有代价的，比如从语文切到数学，要先收拾桌子上的语文书本、钢笔（这叫保存现场），然后，打开数学课本、找出圆规直尺（这叫准备新环境），才能开始做数学作业。操作系统在切换进程或者线程时也是一样的，它需要先保存当前执行的现场环境（CPU寄存器状态、内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等），才能开始执行。这个切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。所以，多任务一旦多到一个限度，反而会使得系统性能急剧下降，最终导致所有任务都做不好。\n是否采用多任务的第二个考虑是任务的类型，可以把任务分为计算密集型和I/O密集型。计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如对视频进行编码解码或者格式转换等等，这种任务全靠CPU的运算能力，虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低。计算密集型任务由于主要消耗CPU资源，这类任务用Python这样的脚本语言去执行效率通常很低，最能胜任这类任务的是C语言，我们之前提到了Python中有嵌入C/C++代码的机制。\n除了计算密集型任务，其他的涉及到网络、存储介质I/O的任务都可以视为I/O密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待I/O操作完成（因为I/O的速度远远低于CPU和内存的速度）。对于I/O密集型任务，如果启动多任务，就可以减少I/O等待时间从而让CPU高效率的运转。有一大类的任务都属于I/O密集型任务，这其中包括了我们很快会涉及到的网络应用和Web应用。\n 说明： 上面的内容和例子来自于廖雪峰官方网站的《Python教程》，因为对作者文中的某些观点持有不同的看法，对原文的文字描述做了适当的调整。\n 单线程+异步I/O 现代操作系统对I/O操作的改进中最为重要的就是支持异步I/O。如果充分利用操作系统提供的异步I/O支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型。Nginx就是支持异步I/O的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。用Node.js开发的服务器端程序也使用了这种工作模式，这也是当下实现多任务编程的一种趋势。\n在Python语言中，单线程+异步I/O的编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。协程最大的优势就是极高的执行效率，因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销。协程的第二个优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不用加锁，只需要判断状态就好了，所以执行效率比多线程高很多。如果想要充分利用CPU的多核特性，最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。关于这方面的内容，我稍后会做一个专题来进行讲解。\n应用案例 例子1：将耗时间的任务放到线程中以获得更好的用户体验。 如下所示的界面中，有“下载”和“关于”两个按钮，用休眠的方式模拟点击“下载”按钮会联网下载文件需要耗费10秒的时间，如果不使用“多线程”，我们会发现，当点击“下载”按钮后整个程序的其他部分都被这个耗时间的任务阻塞而无法执行了，这显然是非常糟糕的用户体验，代码如下所示。\nimport time import tkinter import tkinter.messagebox def download(): # 模拟下载任务需要花费10秒钟时间 time.sleep(10) tkinter.messagebox.showinfo(\u0026#39;提示\u0026#39;, \u0026#39;下载完成!\u0026#39;) def show_about(): tkinter.messagebox.showinfo(\u0026#39;关于\u0026#39;, \u0026#39;作者: 骆昊(v1.0)\u0026#39;) def main(): top = tkinter.Tk() top.title(\u0026#39;单线程\u0026#39;) top.geometry(\u0026#39;200x150\u0026#39;) top.wm_attributes(\u0026#39;-topmost\u0026#39;, True) panel = tkinter.Frame(top) button1 = tkinter.Button(panel, text=\u0026#39;下载\u0026#39;, command=download) button1.pack(side=\u0026#39;left\u0026#39;) button2 = tkinter.Button(panel, text=\u0026#39;关于\u0026#39;, command=show_about) button2.pack(side=\u0026#39;right\u0026#39;) panel.pack(side=\u0026#39;bottom\u0026#39;) tkinter.mainloop() if __name__ == \u0026#39;__main__\u0026#39;: main() 如果使用多线程将耗时间的任务放到一个独立的线程中执行，这样就不会因为执行耗时间的任务而阻塞了主线程，修改后的代码如下所示。\nimport time import tkinter import tkinter.messagebox from threading import Thread def main(): class DownloadTaskHandler(Thread): def run(self): time.sleep(10) tkinter.messagebox.showinfo(\u0026#39;提示\u0026#39;, \u0026#39;下载完成!\u0026#39;) # 启用下载按钮 button1.config(state=tkinter.NORMAL) def download(): # 禁用下载按钮 button1.config(state=tkinter.DISABLED) # 通过daemon参数将线程设置为守护线程(主程序退出就不再保留执行) # 在线程中处理耗时间的下载任务 DownloadTaskHandler(daemon=True).start() def show_about(): tkinter.messagebox.showinfo(\u0026#39;关于\u0026#39;, \u0026#39;作者: 骆昊(v1.0)\u0026#39;) top = tkinter.Tk() top.title(\u0026#39;单线程\u0026#39;) top.geometry(\u0026#39;200x150\u0026#39;) top.wm_attributes(\u0026#39;-topmost\u0026#39;, 1) panel = tkinter.Frame(top) button1 = tkinter.Button(panel, text=\u0026#39;下载\u0026#39;, command=download) button1.pack(side=\u0026#39;left\u0026#39;) button2 = tkinter.Button(panel, text=\u0026#39;关于\u0026#39;, command=show_about) button2.pack(side=\u0026#39;right\u0026#39;) panel.pack(side=\u0026#39;bottom\u0026#39;) tkinter.mainloop() if __name__ == \u0026#39;__main__\u0026#39;: main() 例子2：使用多进程对复杂任务进行“分而治之”。 我们来完成1~100000000求和的计算密集型任务，这个问题本身非常简单，有点循环的知识就能解决，代码如下所示。\nfrom time import time def main(): total = 0 number_list = [x for x in range(1, 100000001)] start = time() for number in number_list: total += number print(total) end = time() print(\u0026#39;Execution time: %.3fs\u0026#39; % (end - start)) if __name__ == \u0026#39;__main__\u0026#39;: main() 在上面的代码中，我故意先去创建了一个列表容器然后填入了100000000个数，这一步其实是比较耗时间的，所以为了公平起见，当我们将这个任务分解到8个进程中去执行的时候，我们暂时也不考虑列表切片操作花费的时间，只是把做运算和合并运算结果的时间统计出来，代码如下所示。\nfrom multiprocessing import Process, Queue from random import randint from time import time def task_handler(curr_list, result_queue): total = 0 for number in curr_list: total += number result_queue.put(total) def main(): processes = [] number_list = [x for x in range(1, 100000001)] result_queue = Queue() index = 0 # 启动8个进程将数据切片后进行运算 for _ in range(8): p = Process(target=task_handler, args=(number_list[index:index + 12500000], result_queue)) index += 12500000 processes.append(p) p.start() # 开始记录所有进程执行完成花费的时间 start = time() for p in processes: p.join() # 合并执行结果 total = 0 while not result_queue.empty(): total += result_queue.get() print(total) end = time() print(\u0026#39;Execution time: \u0026#39;, (end - start), \u0026#39;s\u0026#39;, sep=\u0026#39;\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: main() 比较两段代码的执行结果（在我目前使用的MacBook上，上面的代码需要大概6秒左右的时间，而下面的代码只需要不到1秒的时间，再强调一次我们只是比较了运算的时间，不考虑列表创建及切片操作花费的时间），使用多进程后由于获得了更多的CPU执行时间以及更好的利用了CPU的多核特性，明显的减少了程序的执行时间，而且计算量越大效果越明显。当然，如果愿意还可以将多个进程部署在不同的计算机上，做成分布式进程，具体的做法就是通过multiprocessing.managers模块中提供的管理器将Queue对象通过网络共享出来（注册到网络上让其他计算机可以访问），这部分内容也留到爬虫的专题再进行讲解。\n"},{"idx":24,"href":"/python100days/docs/Day01-15/14-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E5%92%8C%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/","title":"14 网络编程入门和网络应用开发","content":" 网络编程入门 计算机网络基础 计算机网络是独立自主的计算机互联而成的系统的总称，组建计算机网络最主要的目的是实现多台计算机之间的通信和资源共享。今天计算机网络中的设备和计算机网络的用户已经多得不可计数，而计算机网络也可以称得上是一个“复杂巨系统”，对于这样的系统，我们不可能用一两篇文章把它讲清楚，有兴趣的读者可以自行阅读Andrew S.Tanenbaum老师的经典之作《计算机网络》或Kurose和Ross老师合著的《计算机网络:自顶向下方法》来了解计算机网络的相关知识。\n计算机网络发展史  1960s - 美国国防部ARPANET项目问世，奠定了分组交换网络的基础。   1980s - 国际标准化组织（ISO）发布OSI/RM，奠定了网络技术标准化的基础。   1990s - 英国人蒂姆·伯纳斯-李发明了图形化的浏览器，浏览器的简单易用性使得计算机网络迅速被普及。  在没有浏览器的年代，上网是这样的。\n有了浏览器以后，上网是这样的。\nTCP/IP模型 实现网络通信的基础是网络通信协议，这些协议通常是由互联网工程任务组 （IETF）制定的。所谓“协议”就是通信计算机双方必须共同遵从的一组约定，例如怎样建立连接、怎样互相识别等，网络协议的三要素是：语法、语义和时序。构成我们今天使用的Internet的基础的是TCP/IP协议族，所谓协议族就是一系列的协议及其构成的通信模型，我们通常也把这套东西称为TCP/IP模型。与国际标准化组织发布的OSI/RM这个七层模型不同，TCP/IP是一个四层模型，也就是说，该模型将我们使用的网络从逻辑上分解为四个层次，自底向上依次是：网络接口层、网络层、传输层和应用层，如下图所示。\nIP通常被翻译为网际协议，它服务于网络层，主要实现了寻址和路由的功能。接入网络的每一台主机都需要有自己的IP地址，IP地址就是主机在计算机网络上的身份标识。当然由于IPv4地址的匮乏，我们平常在家里、办公室以及其他可以接入网络的公共区域上网时获得的IP地址并不是全球唯一的IP地址，而是一个局域网（LAN）中的内部IP地址，通过网络地址转换（NAT）服务我们也可以实现对网络的访问。计算机网络上有大量的被我们称为“路由器”的网络中继设备，它们会存储转发我们发送到网络上的数据分组，让从源头发出的数据最终能够找到传送到目的地通路，这项功能就是所谓的路由。\nTCP全称传输控制协议，它是基于IP提供的寻址和路由服务而建立起来的负责实现端到端可靠传输的协议，之所以将TCP称为可靠的传输协议是因为TCP向调用者承诺了三件事情：\n 数据不传丢不传错（利用握手、校验和重传机制可以实现）。 流量控制（通过滑动窗口匹配数据发送者和接收者之间的传输速度）。 拥塞控制（通过RTT时间以及对滑动窗口的控制缓解网络拥堵）。  网络应用模式  C/S模式和B/S模式。这里的C指的是Client（客户端），通常是一个需要安装到某个宿主操作系统上的应用程序；而B指的是Browser（浏览器），它几乎是所有图形化操作系统都默认安装了的一个应用软件；通过C或B都可以实现对S（服务器）的访问。关于二者的比较和讨论在网络上有一大堆的文章，在此我们就不再浪费笔墨了。 去中心化的网络应用模式。不管是B/S还是C/S都需要服务器的存在，服务器就是整个应用模式的中心，而去中心化的网络应用通常没有固定的服务器或者固定的客户端，所有应用的使用者既可以作为资源的提供者也可以作为资源的访问者。  基于HTTP协议的网络资源访问 HTTP（超文本传输协议） HTTP是超文本传输协议（Hyper-Text Transfer Proctol）的简称，维基百科上对HTTP的解释是：超文本传输协议是一种用于分布式、协作式和超媒体信息系统的应用层协议，它是万维网数据通信的基础，设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法，通过HTTP或者HTTPS（超文本传输安全协议）请求的资源由URI（统一资源标识符）来标识。关于HTTP的更多内容，我们推荐阅读阮一峰老师的《HTTP 协议入门》，简单的说，通过HTTP我们可以获取网络上的（基于字符的）资源，开发中经常会用到的网络API（有的地方也称之为网络数据接口）就是基于HTTP来实现数据传输的。\nJSON格式 JSON（JavaScript Object Notation）是一种轻量级的数据交换语言，该语言以易于让人阅读的文字（纯文本）为基础，用来传输由属性值或者序列性的值组成的数据对象。尽管JSON是最初只是Javascript中一种创建对象的字面量语法，但它在当下更是一种独立于语言的数据格式，很多编程语言都支持JSON格式数据的生成和解析，Python内置的json模块也提供了这方面的功能。由于JSON是纯文本，它和XML一样都适用于异构系统之间的数据交换，而相较于XML，JSON显得更加的轻便和优雅。下面是表达同样信息的XML和JSON，而JSON的优势是相当直观的。\nXML的例子：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;message\u0026gt; \u0026lt;from\u0026gt;Alice\u0026lt;/from\u0026gt; \u0026lt;to\u0026gt;Bob\u0026lt;/to\u0026gt; \u0026lt;content\u0026gt;Will you marry me?\u0026lt;/content\u0026gt; \u0026lt;/message\u0026gt; JSON的例子：\n{ \u0026#34;from\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;to\u0026#34;: \u0026#34;Bob\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;Will you marry me?\u0026#34; } requests库 requests是一个基于HTTP协议来使用网络的第三库，其官方网站有这样的一句介绍它的话：“Requests是唯一的一个非转基因的Python HTTP库，人类可以安全享用。”简单的说，使用requests库可以非常方便的使用HTTP，避免安全缺陷、冗余代码以及“重复发明轮子”（行业黑话，通常用在软件工程领域表示重新创造一个已有的或是早已被优化過的基本方法）。前面的文章中我们已经使用过这个库，下面我们还是通过requests来实现一个访问网络数据接口并从中获取美女图片下载链接然后下载美女图片到本地的例子程序，程序中使用了天行数据提供的网络API。\n我们可以先通过pip安装requests及其依赖库。\npip install requests 如果使用PyCharm作为开发工具，可以直接在代码中书写import requests，然后通过代码修复功能来自动下载安装requests。\nfrom time import time from threading import Thread import requests # 继承Thread类创建自定义的线程类 class DownloadHanlder(Thread): def __init__(self, url): super().__init__() self.url = url def run(self): filename = self.url[self.url.rfind(\u0026#39;/\u0026#39;) + 1:] resp = requests.get(self.url) with open(\u0026#39;/Users/Hao/\u0026#39; + filename, \u0026#39;wb\u0026#39;) as f: f.write(resp.content) def main(): # 通过requests模块的get函数获取网络资源 # 下面的代码中使用了天行数据接口提供的网络API # 要使用该数据接口需要在天行数据的网站上注册 # 然后用自己的Key替换掉下面代码的中APIKey即可 resp = requests.get( \u0026#39;http://api.tianapi.com/meinv/?key=APIKey\u0026amp;num=10\u0026#39;) # 将服务器返回的JSON格式的数据解析为字典 data_model = resp.json() for mm_dict in data_model[\u0026#39;newslist\u0026#39;]: url = mm_dict[\u0026#39;picUrl\u0026#39;] # 通过多线程的方式实现图片下载 DownloadHanlder(url).start() if __name__ == \u0026#39;__main__\u0026#39;: main() 基于传输层协议的套接字编程 套接字这个词对很多不了解网络编程的人来说显得非常晦涩和陌生，其实说得通俗点，套接字就是一套用C语言写成的应用程序开发库，主要用于实现进程间通信和网络编程，在网络应用开发中被广泛使用。在Python中也可以基于套接字来使用传输层提供的传输服务，并基于此开发自己的网络应用。实际开发中使用的套接字可以分为三类：流套接字（TCP套接字）、数据报套接字和原始套接字。\nTCP套接字 所谓TCP套接字就是使用TCP协议提供的传输服务来实现网络通信的编程接口。在Python中可以通过创建socket对象并指定type属性为SOCK_STREAM来使用TCP套接字。由于一台主机可能拥有多个IP地址，而且很有可能会配置多个不同的服务，所以作为服务器端的程序，需要在创建套接字对象后将其绑定到指定的IP地址和端口上。这里的端口并不是物理设备而是对IP地址的扩展，用于区分不同的服务，例如我们通常将HTTP服务跟80端口绑定，而MySQL数据库服务默认绑定在3306端口，这样当服务器收到用户请求时就可以根据端口号来确定到底用户请求的是HTTP服务器还是数据库服务器提供的服务。端口的取值范围是0~65535，而1024以下的端口我们通常称之为“著名端口”（留给像FTP、HTTP、SMTP等“著名服务”使用的端口，有的地方也称之为“周知端口”），自定义的服务通常不使用这些端口，除非自定义的是HTTP或FTP这样的著名服务。\n下面的代码实现了一个提供时间日期的服务器。\nfrom socket import socket, SOCK_STREAM, AF_INET from datetime import datetime def main(): # 1.创建套接字对象并指定使用哪种传输服务 # family=AF_INET - IPv4地址 # family=AF_INET6 - IPv6地址 # type=SOCK_STREAM - TCP套接字 # type=SOCK_DGRAM - UDP套接字 # type=SOCK_RAW - 原始套接字 server = socket(family=AF_INET, type=SOCK_STREAM) # 2.绑定IP地址和端口(端口用于区分不同的服务) # 同一时间在同一个端口上只能绑定一个服务否则报错 server.bind((\u0026#39;192.168.1.2\u0026#39;, 6789)) # 3.开启监听 - 监听客户端连接到服务器 # 参数512可以理解为连接队列的大小 server.listen(512) print(\u0026#39;服务器启动开始监听...\u0026#39;) while True: # 4.通过循环接收客户端的连接并作出相应的处理(提供服务) # accept方法是一个阻塞方法如果没有客户端连接到服务器代码不会向下执行 # accept方法返回一个元组其中的第一个元素是客户端对象 # 第二个元素是连接到服务器的客户端的地址(由IP和端口两部分构成) client, addr = server.accept() print(str(addr) + \u0026#39;连接到了服务器.\u0026#39;) # 5.发送数据 client.send(str(datetime.now()).encode(\u0026#39;utf-8\u0026#39;)) # 6.断开连接 client.close() if __name__ == \u0026#39;__main__\u0026#39;: main() 运行服务器程序后我们可以通过Windows系统的telnet来访问该服务器，结果如下图所示。\ntelnet 192.168.1.2 6789 当然我们也可以通过Python的程序来实现TCP客户端的功能，相较于实现服务器程序，实现客户端程序就简单多了，代码如下所示。\nfrom socket import socket def main(): # 1.创建套接字对象默认使用IPv4和TCP协议 client = socket() # 2.连接到服务器(需要指定IP地址和端口) client.connect((\u0026#39;192.168.1.2\u0026#39;, 6789)) # 3.从服务器接收数据 print(client.recv(1024).decode(\u0026#39;utf-8\u0026#39;)) client.close() if __name__ == \u0026#39;__main__\u0026#39;: main() 需要注意的是，上面的服务器并没有使用多线程或者异步I/O的处理方式，这也就意味着当服务器与一个客户端处于通信状态时，其他的客户端只能排队等待。很显然，这样的服务器并不能满足我们的需求，我们需要的服务器是能够同时接纳和处理多个用户请求的。下面我们来设计一个使用多线程技术处理多个用户请求的服务器，该服务器会向连接到服务器的客户端发送一张图片。\n服务器端代码：\nfrom socket import socket, SOCK_STREAM, AF_INET from base64 import b64encode from json import dumps from threading import Thread def main(): # 自定义线程类 class FileTransferHandler(Thread): def __init__(self, cclient): super().__init__() self.cclient = cclient def run(self): my_dict = {} my_dict[\u0026#39;filename\u0026#39;] = \u0026#39;guido.jpg\u0026#39; # JSON是纯文本不能携带二进制数据 # 所以图片的二进制数据要处理成base64编码 my_dict[\u0026#39;filedata\u0026#39;] = data # 通过dumps函数将字典处理成JSON字符串 json_str = dumps(my_dict) # 发送JSON字符串 self.cclient.send(json_str.encode(\u0026#39;utf-8\u0026#39;)) self.cclient.close() # 1.创建套接字对象并指定使用哪种传输服务 server = socket() # 2.绑定IP地址和端口(区分不同的服务) server.bind((\u0026#39;192.168.1.2\u0026#39;, 5566)) # 3.开启监听 - 监听客户端连接到服务器 server.listen(512) print(\u0026#39;服务器启动开始监听...\u0026#39;) with open(\u0026#39;guido.jpg\u0026#39;, \u0026#39;rb\u0026#39;) as f: # 将二进制数据处理成base64再解码成字符串 data = b64encode(f.read()).decode(\u0026#39;utf-8\u0026#39;) while True: client, addr = server.accept() # 启动一个线程来处理客户端的请求 FileTransferHandler(client).start() if __name__ == \u0026#39;__main__\u0026#39;: main() 客户端代码：\nfrom socket import socket from json import loads from base64 import b64decode def main(): client = socket() client.connect((\u0026#39;192.168.1.2\u0026#39;, 5566)) # 定义一个保存二进制数据的对象 in_data = bytes() # 由于不知道服务器发送的数据有多大每次接收1024字节 data = client.recv(1024) while data: # 将收到的数据拼接起来 in_data += data data = client.recv(1024) # 将收到的二进制数据解码成JSON字符串并转换成字典 # loads函数的作用就是将JSON字符串转成字典对象 my_dict = loads(in_data.decode(\u0026#39;utf-8\u0026#39;)) filename = my_dict[\u0026#39;filename\u0026#39;] filedata = my_dict[\u0026#39;filedata\u0026#39;].encode(\u0026#39;utf-8\u0026#39;) with open(\u0026#39;/Users/Hao/\u0026#39; + filename, \u0026#39;wb\u0026#39;) as f: # 将base64格式的数据解码成二进制数据并写入文件 f.write(b64decode(filedata)) print(\u0026#39;图片已保存.\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: main() 在这个案例中，我们使用了JSON作为数据传输的格式（通过JSON格式对传输的数据进行了序列化和反序列化的操作），但是JSON并不能携带二进制数据，因此对图片的二进制数据进行了Base64编码的处理。Base64是一种用64个字符表示所有二进制数据的编码方式，通过将二进制数据每6位一组的方式重新组织，刚好可以使用0~9的数字、大小写字母以及“+”和“/”总共64个字符表示从000000到111111的64种状态。维基百科上有关于Base64编码的详细讲解，不熟悉Base64的读者可以自行阅读。\n 说明： 上面的代码主要为了讲解网络编程的相关内容因此并没有对异常状况进行处理，请读者自行添加异常处理代码来增强程序的健壮性。\n UDP套接字 传输层除了有可靠的传输协议TCP之外，还有一种非常轻便的传输协议叫做用户数据报协议，简称UDP。TCP和UDP都是提供端到端传输服务的协议，二者的差别就如同打电话和发短信的区别，后者不对传输的可靠性和可达性做出任何承诺从而避免了TCP中握手和重传的开销，所以在强调性能和而不是数据完整性的场景中（例如传输网络音视频数据），UDP可能是更好的选择。可能大家会注意到一个现象，就是在观看网络视频时，有时会出现卡顿，有时会出现花屏，这无非就是部分数据传丢或传错造成的。在Python中也可以使用UDP套接字来创建网络应用，对此我们不进行赘述，有兴趣的读者可以自行研究。\n网络应用开发 发送电子邮件 在即时通信软件如此发达的今天，电子邮件仍然是互联网上使用最为广泛的应用之一，公司向应聘者发出录用通知、网站向用户发送一个激活账号的链接、银行向客户推广它们的理财产品等几乎都是通过电子邮件来完成的，而这些任务应该都是由程序自动完成的。\n就像我们可以用HTTP（超文本传输协议）来访问一个网站一样，发送邮件要使用SMTP（简单邮件传输协议），SMTP也是一个建立在TCP（传输控制协议）提供的可靠数据传输服务的基础上的应用级协议，它规定了邮件的发送者如何跟发送邮件的服务器进行通信的细节，而Python中的smtplib模块将这些操作简化成了几个简单的函数。\n下面的代码演示了如何在Python发送邮件。\nfrom smtplib import SMTP from email.header import Header from email.mime.text import MIMEText def main(): # 请自行修改下面的邮件发送者和接收者 sender = \u0026#39;abcdefg@126.com\u0026#39; receivers = [\u0026#39;uvwxyz@qq.com\u0026#39;, \u0026#39;uvwxyz@126.com\u0026#39;] message = MIMEText(\u0026#39;用Python发送邮件的示例代码.\u0026#39;, \u0026#39;plain\u0026#39;, \u0026#39;utf-8\u0026#39;) message[\u0026#39;From\u0026#39;] = Header(\u0026#39;王大锤\u0026#39;, \u0026#39;utf-8\u0026#39;) message[\u0026#39;To\u0026#39;] = Header(\u0026#39;骆昊\u0026#39;, \u0026#39;utf-8\u0026#39;) message[\u0026#39;Subject\u0026#39;] = Header(\u0026#39;示例代码实验邮件\u0026#39;, \u0026#39;utf-8\u0026#39;) smtper = SMTP(\u0026#39;smtp.126.com\u0026#39;) # 请自行修改下面的登录口令 smtper.login(sender, \u0026#39;secretpass\u0026#39;) smtper.sendmail(sender, receivers, message.as_string()) print(\u0026#39;邮件发送完成!\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: main() 如果要发送带有附件的邮件，那么可以按照下面的方式进行操作。\nfrom smtplib import SMTP from email.header import Header from email.mime.text import MIMEText from email.mime.image import MIMEImage from email.mime.multipart import MIMEMultipart import urllib def main(): # 创建一个带附件的邮件消息对象 message = MIMEMultipart() # 创建文本内容 text_content = MIMEText(\u0026#39;附件中有本月数据请查收\u0026#39;, \u0026#39;plain\u0026#39;, \u0026#39;utf-8\u0026#39;) message[\u0026#39;Subject\u0026#39;] = Header(\u0026#39;本月数据\u0026#39;, \u0026#39;utf-8\u0026#39;) # 将文本内容添加到邮件消息对象中 message.attach(text_content) # 读取文件并将文件作为附件添加到邮件消息对象中 with open(\u0026#39;/Users/Hao/Desktop/hello.txt\u0026#39;, \u0026#39;rb\u0026#39;) as f: txt = MIMEText(f.read(), \u0026#39;base64\u0026#39;, \u0026#39;utf-8\u0026#39;) txt[\u0026#39;Content-Type\u0026#39;] = \u0026#39;text/plain\u0026#39; txt[\u0026#39;Content-Disposition\u0026#39;] = \u0026#39;attachment; filename=hello.txt\u0026#39; message.attach(txt) # 读取文件并将文件作为附件添加到邮件消息对象中 with open(\u0026#39;/Users/Hao/Desktop/汇总数据.xlsx\u0026#39;, \u0026#39;rb\u0026#39;) as f: xls = MIMEText(f.read(), \u0026#39;base64\u0026#39;, \u0026#39;utf-8\u0026#39;) xls[\u0026#39;Content-Type\u0026#39;] = \u0026#39;application/vnd.ms-excel\u0026#39; xls[\u0026#39;Content-Disposition\u0026#39;] = \u0026#39;attachment; filename=month-data.xlsx\u0026#39; message.attach(xls) # 创建SMTP对象 smtper = SMTP(\u0026#39;smtp.126.com\u0026#39;) # 开启安全连接 # smtper.starttls() sender = \u0026#39;abcdefg@126.com\u0026#39; receivers = [\u0026#39;uvwxyz@qq.com\u0026#39;] # 登录到SMTP服务器 # 请注意此处不是使用密码而是邮件客户端授权码进行登录 # 对此有疑问的读者可以联系自己使用的邮件服务器客服 smtper.login(sender, \u0026#39;secretpass\u0026#39;) # 发送邮件 smtper.sendmail(sender, receivers, message.as_string()) # 与邮件服务器断开连接 smtper.quit() print(\u0026#39;发送完成!\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: main() 发送短信 发送短信也是项目中常见的功能，网站的注册码、验证码、营销信息基本上都是通过短信来发送给用户的。在下面的代码中我们使用了互亿无线短信平台（该平台为注册用户提供了50条免费短信以及常用开发语言发送短信的demo，可以登录该网站并在用户自服务页面中对短信进行配置）提供的API接口实现了发送短信的服务，当然国内的短信平台很多，读者可以根据自己的需要进行选择（通常会考虑费用预算、短信达到率、使用的难易程度等指标），如果需要在商业项目中使用短信服务建议购买短信平台提供的套餐服务。\nimport urllib.parse import http.client import json def main(): host = \u0026#34;106.ihuyi.com\u0026#34; sms_send_uri = \u0026#34;/webservice/sms.php?method=Submit\u0026#34; # 下面的参数需要填入自己注册的账号和对应的密码 params = urllib.parse.urlencode({\u0026#39;account\u0026#39;: \u0026#39;你自己的账号\u0026#39;, \u0026#39;password\u0026#39; : \u0026#39;你自己的密码\u0026#39;, \u0026#39;content\u0026#39;: \u0026#39;您的验证码是：147258。请不要把验证码泄露给其他人。\u0026#39;, \u0026#39;mobile\u0026#39;: \u0026#39;接收者的手机号\u0026#39;, \u0026#39;format\u0026#39;:\u0026#39;json\u0026#39; }) print(params) headers = {\u0026#39;Content-type\u0026#39;: \u0026#39;application/x-www-form-urlencoded\u0026#39;, \u0026#39;Accept\u0026#39;: \u0026#39;text/plain\u0026#39;} conn = http.client.HTTPConnection(host, port=80, timeout=30) conn.request(\u0026#39;POST\u0026#39;, sms_send_uri, params, headers) response = conn.getresponse() response_str = response.read() jsonstr = response_str.decode(\u0026#39;utf-8\u0026#39;) print(json.loads(jsonstr)) conn.close() if __name__ == \u0026#39;__main__\u0026#39;: main()"},{"idx":25,"href":"/python100days/docs/Day01-15/15-%E5%9B%BE%E5%83%8F%E5%92%8C%E5%8A%9E%E5%85%AC%E6%96%87%E6%A1%A3%E5%A4%84%E7%90%86/","title":"15 图像和办公文档处理","content":" 图像和办公文档处理 用程序来处理图像和办公文档经常出现在实际开发中，Python的标准库中虽然没有直接支持这些操作的模块，但我们可以通过Python生态圈中的第三方模块来完成这些操作。\n操作图像 计算机图像相关知识  颜色。如果你有使用颜料画画的经历，那么一定知道混合红、黄、蓝三种颜料可以得到其他的颜色，事实上这三种颜色就是被我们称为美术三原色的东西，它们是不能再分解的基本颜色。在计算机中，我们可以将红、绿、蓝三种色光以不同的比例叠加来组合成其他的颜色，因此这三种颜色就是色光三原色，所以我们通常会将一个颜色表示为一个RGB值或RGBA值（其中的A表示Alpha通道，它决定了透过这个图像的像素，也就是透明度）。  | 名称 | RGBA值 | 名称 | RGBA值 | | :\u0026mdash;: | :\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;: | :\u0026mdash;-: | :\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-: | | White | (255, 255, 255, 255) | Red | (255, 0, 0, 255) | | Green | (0, 255, 0, 255) | Blue | (0, 0, 255, 255) | | Gray | (128, 128, 128, 255) | Yellow | (255, 255, 0, 255) | | Black | (0, 0, 0, 255) | Purple | (128, 0, 128, 255) |\n 像素。对于一个由数字序列表示的图像来说，最小的单位就是图像上单一颜色的小方格，这些小方块都有一个明确的位置和被分配的色彩数值，而这些一小方格的颜色和位置决定了该图像最终呈现出来的样子，它们是不可分割的单位，我们通常称之为像素（pixel）。每一个图像都包含了一定量的像素，这些像素决定图像在屏幕上所呈现的大小。  用Pillow操作图像 Pillow是由从著名的Python图像处理库PIL发展出来的一个分支，通过Pillow可以实现图像压缩和图像处理等各种操作。可以使用下面的命令来安装Pillow。\npip install pillow Pillow中最为重要的是Image类，读取和处理图像都要通过这个类来完成。\n\u0026gt;\u0026gt;\u0026gt; from PIL import Image \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; image = Image.open(\u0026#39;Day01-15/res/guido.jpg\u0026#39;) \u0026gt;\u0026gt;\u0026gt; image.format, image.size, image.mode (\u0026#39;JPEG\u0026#39;, (500, 750), \u0026#39;RGB\u0026#39;) \u0026gt;\u0026gt;\u0026gt; image.show()  剪裁图像\n\u0026gt;\u0026gt;\u0026gt; image = Image.open(\u0026#39;Day01-15/res/guido.jpg\u0026#39;) \u0026gt;\u0026gt;\u0026gt; rect = 80, 20, 310, 360 \u0026gt;\u0026gt;\u0026gt; image.crop(rect).show()   生成缩略图\n\u0026gt;\u0026gt;\u0026gt; image = Image.open(\u0026#39;Day01-15/res/guido.jpg\u0026#39;) \u0026gt;\u0026gt;\u0026gt; size = 128, 128 \u0026gt;\u0026gt;\u0026gt; image.thumbnail(size) \u0026gt;\u0026gt;\u0026gt; image.show()   缩放和黏贴图像\n\u0026gt;\u0026gt;\u0026gt; image1 = Image.open(\u0026#39;Day01-15/res/luohao.png\u0026#39;) \u0026gt;\u0026gt;\u0026gt; image2 = Image.open(\u0026#39;Day01-15/res/guido.jpg\u0026#39;) \u0026gt;\u0026gt;\u0026gt; rect = 80, 20, 310, 360 \u0026gt;\u0026gt;\u0026gt; guido_head = image2.crop(rect) \u0026gt;\u0026gt;\u0026gt; width, height = guido_head.size \u0026gt;\u0026gt;\u0026gt; image1.paste(guido_head.resize((int(width / 1.5), int(height / 1.5))), (172, 40))   旋转和翻转\n\u0026gt;\u0026gt;\u0026gt; image = Image.open(\u0026#39;Day01-15/res/guido.png\u0026#39;) \u0026gt;\u0026gt;\u0026gt; image.rotate(180).show() \u0026gt;\u0026gt;\u0026gt; image.transpose(Image.FLIP_LEFT_RIGHT).show()   操作像素\n\u0026gt;\u0026gt;\u0026gt; image = Image.open(\u0026#39;Day01-15/res/guido.jpg\u0026#39;) \u0026gt;\u0026gt;\u0026gt; for x in range(80, 310): ... for y in range(20, 360): ... image.putpixel((x, y), (128, 128, 128)) ... \u0026gt;\u0026gt;\u0026gt; image.show()   滤镜效果\n\u0026gt;\u0026gt;\u0026gt; from PIL import Image, ImageFilter \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; image = Image.open(\u0026#39;Day01-15/res/guido.jpg\u0026#39;) \u0026gt;\u0026gt;\u0026gt; image.filter(ImageFilter.CONTOUR).show()  处理Excel电子表格 Python的openpyxl模块让我们可以在Python程序中读取和修改Excel电子表格，当然实际工作中，我们可能会用LibreOffice Calc和OpenOffice Calc来处理Excel的电子表格文件，这就意味着openpyxl模块也能处理来自这些软件生成的电子表格。关于openpyxl的使用手册和使用文档可以查看它的官方文档。\n处理Word文档 利用python-docx模块，Pytho 可以创建和修改Word文档，当然这里的Word文档不仅仅是指通过微软的Office软件创建的扩展名为docx的文档，LibreOffice Writer和OpenOffice Writer都是免费的字处理软件。\n处理PDF文档 PDF是Portable Document Format的缩写，使用.pdf作为文件扩展名。接下来我们就研究一下如何通过Python实现从PDF读取文本内容和从已有的文档生成新的PDF文件。\n"},{"idx":26,"href":"/python100days/docs/Day16-20/16-20-Python%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/","title":"16 20 Python语言进阶","content":" Python语言进阶  数据结构和算法\n 算法：解决问题的方法和步骤\n 评价算法的好坏：渐近时间复杂度和渐近空间复杂度。\n 渐近时间复杂度的大O标记：\n - 常量时间复杂度 - 布隆过滤器 / 哈希存储 - 对数时间复杂度 - 折半查找（二分查找） - 线性时间复杂度 - 顺序查找 / 桶排序 - 对数线性时间复杂度 - 高级排序算法（归并排序、快速排序） - 平方时间复杂度 - 简单排序算法（选择排序、插入排序、冒泡排序） - 立方时间复杂度 - Floyd算法 / 矩阵乘法运算 - 几何级数时间复杂度 - 汉诺塔 - 阶乘时间复杂度 - 旅行经销商问题 - NP    排序算法（选择、冒泡和归并）和查找算法（顺序和折半）\ndef select_sort(origin_items, comp=lambda x, y: x \u0026lt; y): \u0026#34;\u0026#34;\u0026#34;简单选择排序\u0026#34;\u0026#34;\u0026#34; items = origin_items[:] for i in range(len(items) - 1): min_index = i for j in range(i + 1, len(items)): if comp(items[j], items[min_index]): min_index = j items[i], items[min_index] = items[min_index], items[i] return itemsdef bubble_sort(origin_items, comp=lambda x, y: x \u0026gt; y): \u0026#34;\u0026#34;\u0026#34;高质量冒泡排序(搅拌排序)\u0026#34;\u0026#34;\u0026#34; items = origin_items[:] for i in range(len(items) - 1): swapped = False for j in range(i, len(items) - 1 - i): if comp(items[j], items[j + 1]): items[j], items[j + 1] = items[j + 1], items[j] swapped = True if swapped: swapped = False for j in range(len(items) - 2 - i, i, -1): if comp(items[j - 1], items[j]): items[j], items[j - 1] = items[j - 1], items[j] swapped = True if not swapped: break return itemsdef merge_sort(items, comp=lambda x, y: x \u0026lt;= y): \u0026#34;\u0026#34;\u0026#34;归并排序(分治法)\u0026#34;\u0026#34;\u0026#34; if len(items) \u0026lt; 2: return items[:] mid = len(items) // 2 left = merge_sort(items[:mid], comp) right = merge_sort(items[mid:], comp) return merge(left, right, comp) def merge(items1, items2, comp): \u0026#34;\u0026#34;\u0026#34;合并(将两个有序的列表合并成一个有序的列表)\u0026#34;\u0026#34;\u0026#34; items = [] index1, index2 = 0, 0 while index1 \u0026lt; len(items1) and index2 \u0026lt; len(items2): if comp(items1[index1], items2[index2]): items.append(items1[index1]) index1 += 1 else: items.append(items2[index2]) index2 += 1 items += items1[index1:] items += items2[index2:] return itemsdef seq_search(items, key): \u0026#34;\u0026#34;\u0026#34;顺序查找\u0026#34;\u0026#34;\u0026#34; for index, item in enumerate(items): if item == key: return index return -1def bin_search(items, key): \u0026#34;\u0026#34;\u0026#34;折半查找\u0026#34;\u0026#34;\u0026#34; start, end = 0, len(items) - 1 while start \u0026lt;= end: mid = (start + end) // 2 if key \u0026gt; items[mid]: start = mid + 1 elif key \u0026lt; items[mid]: end = mid - 1 else: return mid return -1 使用生成式（推导式）语法\nprices = { \u0026#39;AAPL\u0026#39;: 191.88, \u0026#39;GOOG\u0026#39;: 1186.96, \u0026#39;IBM\u0026#39;: 149.24, \u0026#39;ORCL\u0026#39;: 48.44, \u0026#39;ACN\u0026#39;: 166.89, \u0026#39;FB\u0026#39;: 208.09, \u0026#39;SYMC\u0026#39;: 21.29 } # 用股票价格大于100元的股票构造一个新的字典 prices2 = {key: value for key, value in prices.items() if value \u0026gt; 100} print(prices2)   说明：生成式（推导式）可以用来生成列表、集合和字典。\n  嵌套的列表\nnames = [\u0026#39;关羽\u0026#39;, \u0026#39;张飞\u0026#39;, \u0026#39;赵云\u0026#39;, \u0026#39;马超\u0026#39;, \u0026#39;黄忠\u0026#39;] courses = [\u0026#39;语文\u0026#39;, \u0026#39;数学\u0026#39;, \u0026#39;英语\u0026#39;] # 录入五个学生三门课程的成绩 # 错误 - 参考http://pythontutor.com/visualize.html#mode=edit # scores = [[None] * len(courses)] * len(names) scores = [[None] * len(courses) for _ in range(len(names))] for row, name in enumerate(names): for col, course in enumerate(courses): scores[row][col] = float(input(f\u0026#39;请输入{name}的{course}成绩: \u0026#39;)) print(scores)  Python Tutor - VISUALIZE CODE AND GET LIVE HELP\n heapq、itertools等的用法\n\u0026#34;\u0026#34;\u0026#34; 从列表中找出最大的或最小的N个元素 堆结构(大根堆/小根堆) \u0026#34;\u0026#34;\u0026#34; import heapq list1 = [34, 25, 12, 99, 87, 63, 58, 78, 88, 92] list2 = [ {\u0026#39;name\u0026#39;: \u0026#39;IBM\u0026#39;, \u0026#39;shares\u0026#39;: 100, \u0026#39;price\u0026#39;: 91.1}, {\u0026#39;name\u0026#39;: \u0026#39;AAPL\u0026#39;, \u0026#39;shares\u0026#39;: 50, \u0026#39;price\u0026#39;: 543.22}, {\u0026#39;name\u0026#39;: \u0026#39;FB\u0026#39;, \u0026#39;shares\u0026#39;: 200, \u0026#39;price\u0026#39;: 21.09}, {\u0026#39;name\u0026#39;: \u0026#39;HPQ\u0026#39;, \u0026#39;shares\u0026#39;: 35, \u0026#39;price\u0026#39;: 31.75}, {\u0026#39;name\u0026#39;: \u0026#39;YHOO\u0026#39;, \u0026#39;shares\u0026#39;: 45, \u0026#39;price\u0026#39;: 16.35}, {\u0026#39;name\u0026#39;: \u0026#39;ACME\u0026#39;, \u0026#39;shares\u0026#39;: 75, \u0026#39;price\u0026#39;: 115.65} ] print(heapq.nlargest(3, list1)) print(heapq.nsmallest(3, list1)) print(heapq.nlargest(2, list2, key=lambda x: x[\u0026#39;price\u0026#39;])) print(heapq.nlargest(2, list2, key=lambda x: x[\u0026#39;shares\u0026#39;]))\u0026#34;\u0026#34;\u0026#34; 迭代工具 - 排列 / 组合 / 笛卡尔积 \u0026#34;\u0026#34;\u0026#34; import itertools itertools.permutations(\u0026#39;ABCD\u0026#39;) itertools.combinations(\u0026#39;ABCDE\u0026#39;, 3) itertools.product(\u0026#39;ABCD\u0026#39;, \u0026#39;123\u0026#39;) collections模块下的工具类\n\u0026#34;\u0026#34;\u0026#34; 找出序列中出现次数最多的元素 \u0026#34;\u0026#34;\u0026#34; from collections import Counter words = [ \u0026#39;look\u0026#39;, \u0026#39;into\u0026#39;, \u0026#39;my\u0026#39;, \u0026#39;eyes\u0026#39;, \u0026#39;look\u0026#39;, \u0026#39;into\u0026#39;, \u0026#39;my\u0026#39;, \u0026#39;eyes\u0026#39;, \u0026#39;the\u0026#39;, \u0026#39;eyes\u0026#39;, \u0026#39;the\u0026#39;, \u0026#39;eyes\u0026#39;, \u0026#39;the\u0026#39;, \u0026#39;eyes\u0026#39;, \u0026#39;not\u0026#39;, \u0026#39;around\u0026#39;, \u0026#39;the\u0026#39;, \u0026#39;eyes\u0026#39;, \u0026#34;don\u0026#39;t\u0026#34;, \u0026#39;look\u0026#39;, \u0026#39;around\u0026#39;, \u0026#39;the\u0026#39;, \u0026#39;eyes\u0026#39;, \u0026#39;look\u0026#39;, \u0026#39;into\u0026#39;, \u0026#39;my\u0026#39;, \u0026#39;eyes\u0026#39;, \u0026#34;you\u0026#39;re\u0026#34;, \u0026#39;under\u0026#39; ] counter = Counter(words) print(counter.most_common(3)) 常用算法：\n 穷举法 - 又称为暴力破解法，对所有的可能性进行验证，直到找到正确答案。 贪婪法 - 在对问题求解时，总是做出在当前看来 最好的选择，不追求最优解，快速找到满意解。 分治法 - 把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题，直到可以直接求解的程度，最后将子问题的解进行合并得到原问题的解。 回溯法 - 回溯法又称为试探法，按选优条件向前搜索，当搜索到某一步发现原先选择并不优或达不到目标时，就退回一步重新选择。 动态规划 - 基本思想也是将待求解问题分解成若干个子问题，先求解并保存这些子问题的解，避免产生大量的重复运算。   穷举法例子：百钱百鸡和五人分鱼。\n# 公鸡5元一只 母鸡3元一只 小鸡1元三只 # 用100元买100只鸡 问公鸡/母鸡/小鸡各多少只 for x in range(20): for y in range(33): z = 100 - x - y if 5 * x + 3 * y + z // 3 == 100 and z % 3 == 0: print(x, y, z) # A、B、C、D、E五人在某天夜里合伙捕鱼 最后疲惫不堪各自睡觉 # 第二天A第一个醒来 他将鱼分为5份 扔掉多余的1条 拿走自己的一份 # B第二个醒来 也将鱼分为5份 扔掉多余的1条 拿走自己的一份 # 然后C、D、E依次醒来也按同样的方式分鱼 问他们至少捕了多少条鱼 fish = 6 while True: total = fish enough = True for _ in range(5): if (total - 1) % 5 == 0: total = (total - 1) // 5 * 4 else: enough = False break if enough: print(fish) break fish += 5 贪婪法例子：假设小偷有一个背包，最多能装20公斤赃物，他闯入一户人家，发现如下表所示的物品。很显然，他不能把所有物品都装进背包，所以必须确定拿走哪些物品，留下哪些物品。\n| 名称 | 价格（美元） | 重量（kg） | | :\u0026mdash;-: | :\u0026mdash;\u0026mdash;\u0026mdash;-: | :\u0026mdash;\u0026mdash;\u0026ndash;: | | 电脑 | 200 | 20 | | 收音机 | 20 | 4 | | 钟 | 175 | 10 | | 花瓶 | 50 | 2 | | 书 | 10 | 1 | | 油画 | 90 | 9 |\n\u0026#34;\u0026#34;\u0026#34; 贪婪法：在对问题求解时，总是做出在当前看来是最好的选择，不追求最优解，快速找到满意解。 输入： 20 6 电脑 200 20 收音机 20 4 钟 175 10 花瓶 50 2 书 10 1 油画 90 9 \u0026#34;\u0026#34;\u0026#34; class Thing(object): \u0026#34;\u0026#34;\u0026#34;物品\u0026#34;\u0026#34;\u0026#34; def __init__(self, name, price, weight): self.name = name self.price = price self.weight = weight @property def value(self): \u0026#34;\u0026#34;\u0026#34;价格重量比\u0026#34;\u0026#34;\u0026#34; return self.price / self.weight def input_thing(): \u0026#34;\u0026#34;\u0026#34;输入物品信息\u0026#34;\u0026#34;\u0026#34; name_str, price_str, weight_str = input().split() return name_str, int(price_str), int(weight_str) def main(): \u0026#34;\u0026#34;\u0026#34;主函数\u0026#34;\u0026#34;\u0026#34; max_weight, num_of_things = map(int, input().split()) all_things = [] for _ in range(num_of_things): all_things.append(Thing(*input_thing())) all_things.sort(key=lambda x: x.value, reverse=True) total_weight = 0 total_price = 0 for thing in all_things: if total_weight + thing.weight \u0026lt;= max_weight: print(f\u0026#39;小偷拿走了{thing.name}\u0026#39;) total_weight += thing.weight total_price += thing.price print(f\u0026#39;总价值: {total_price}美元\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: main() 分治法例子：快速排序。\n\u0026#34;\u0026#34;\u0026#34; 快速排序 - 选择枢轴对元素进行划分，左边都比枢轴小右边都比枢轴大 \u0026#34;\u0026#34;\u0026#34; def quick_sort(origin_items, comp=lambda x, y: x \u0026lt;= y): items = origin_items[:] _quick_sort(items, 0, len(items) - 1, comp) return items def _quick_sort(items, start, end, comp): if start \u0026lt; end: pos = _partition(items, start, end, comp) _quick_sort(items, start, pos - 1, comp) _quick_sort(items, pos + 1, end, comp) def _partition(items, start, end, comp): pivot = items[end] i = start - 1 for j in range(start, end): if comp(items[j], pivot): i += 1 items[i], items[j] = items[j], items[i] items[i + 1], items[end] = items[end], items[i + 1] return i + 1 回溯法例子：骑士巡逻。\n\u0026#34;\u0026#34;\u0026#34; 递归回溯法：叫称为试探法，按选优条件向前搜索，当搜索到某一步，发现原先选择并不优或达不到目标时，就退回一步重新选择，比较经典的问题包括骑士巡逻、八皇后和迷宫寻路等。 \u0026#34;\u0026#34;\u0026#34; import sys import time SIZE = 5 total = 0 def print_board(board): for row in board: for col in row: print(str(col).center(4), end=\u0026#39;\u0026#39;) print() def patrol(board, row, col, step=1): if row \u0026gt;= 0 and row \u0026lt; SIZE and \\ col \u0026gt;= 0 and col \u0026lt; SIZE and \\ board[row][col] == 0: board[row][col] = step if step == SIZE * SIZE: global total total += 1 print(f\u0026#39;第{total}种走法: \u0026#39;) print_board(board) patrol(board, row - 2, col - 1, step + 1) patrol(board, row - 1, col - 2, step + 1) patrol(board, row + 1, col - 2, step + 1) patrol(board, row + 2, col - 1, step + 1) patrol(board, row + 2, col + 1, step + 1) patrol(board, row + 1, col + 2, step + 1) patrol(board, row - 1, col + 2, step + 1) patrol(board, row - 2, col + 1, step + 1) board[row][col] = 0 def main(): board = [[0] * SIZE for _ in range(SIZE)] patrol(board, SIZE - 1, SIZE - 1) if __name__ == \u0026#39;__main__\u0026#39;: main() 动态规划例子1：[斐波拉切数列]()。（不使用动态规划将会是几何级数复杂度）\n\u0026#34;\u0026#34;\u0026#34; 动态规划 - 适用于有重叠子问题和最优子结构性质的问题 使用动态规划方法所耗时间往往远少于朴素解法(用空间换取时间) \u0026#34;\u0026#34;\u0026#34; def fib(num, temp={}): \u0026#34;\u0026#34;\u0026#34;用递归计算Fibonacci数\u0026#34;\u0026#34;\u0026#34; if num in (1, 2): return 1 try: return temp[num] except KeyError: temp[num] = fib(num - 1) + fib(num - 2) return temp[num] 动态规划例子2：子列表元素之和的最大值。（使用动态规划可以避免二重循环）\n 说明：子列表指的是列表中索引（下标）连续的元素构成的列表；列表中的元素是int类型，可能包含正整数、0、负整数；程序输入列表中的元素，输出子列表元素求和的最大值，例如：\n输入：1 -2 3 5 -3 2\n输出：8\n输入：0 -2 3 5 -1 2\n输出：9\n输入：-9 -2 -3 -5 -3\n输出：-2\n def main(): items = list(map(int, input().split())) size = len(items) overall, partial = {}, {} overall[size - 1] = partial[size - 1] = items[size - 1] for i in range(size - 2, -1, -1): partial[i] = max(items[i], partial[i + 1] + items[i]) overall[i] = max(partial[i], overall[i + 1]) print(overall[0]) if __name__ == \u0026#39;__main__\u0026#39;: main() 函数的使用方式\n 将函数视为“一等公民”\n 函数可以赋值给变量 函数可以作为函数的参数 函数可以作为函数的返回值  高阶函数的用法（filter、map以及它们的替代品）\nitems1 = list(map(lambda x: x ** 2, filter(lambda x: x % 2, range(1, 10)))) items2 = [x ** 2 for x in range(1, 10) if x % 2] 位置参数、可变参数、关键字参数、命名关键字参数\n 参数的元信息（代码可读性问题）\n 匿名函数和内联函数的用法（lambda函数）\n 闭包和作用域问题\n Python搜索变量的LEGB顺序（Local \u0026ndash;\u0026gt; Embedded \u0026ndash;\u0026gt; Global \u0026ndash;\u0026gt; Built-in）\n global和nonlocal关键字的作用\n   global：声明或定义全局变量（要么直接使用现有的全局作用域的变量，要么定义一个变量放到全局作用域）。\nnonlocal：声明使用嵌套作用域的变量（嵌套作用域必须存在该变量，否则报错）。\n 装饰器函数（使用装饰器和取消装饰器）  例子：输出函数执行时间的装饰器。\ndef record_time(func): \u0026#34;\u0026#34;\u0026#34;自定义装饰函数的装饰器\u0026#34;\u0026#34;\u0026#34; @wraps(func) def wrapper(*args, **kwargs): start = time() result = func(*args, **kwargs) print(f\u0026#39;{func.__name__}: {time() - start}秒\u0026#39;) return result return wrapper 如果装饰器不希望跟print函数耦合，可以编写带参数的装饰器。\nfrom functools import wraps from time import time def record(output): \u0026#34;\u0026#34;\u0026#34;自定义带参数的装饰器\u0026#34;\u0026#34;\u0026#34; def decorate(func): @wraps(func) def wrapper(*args, **kwargs): start = time() result = func(*args, **kwargs) output(func.__name__, time() - start) return result return wrapper return decoratefrom functools import wraps from time import time class Record(): \u0026#34;\u0026#34;\u0026#34;自定义装饰器类(通过__call__魔术方法使得对象可以当成函数调用)\u0026#34;\u0026#34;\u0026#34; def __init__(self, output): self.output = output def __call__(self, func): @wraps(func) def wrapper(*args, **kwargs): start = time() result = func(*args, **kwargs) self.output(func.__name__, time() - start) return result return wrapper  说明：由于对带装饰功能的函数添加了@wraps装饰器，可以通过func.__wrapped__方式获得被装饰之前的函数或类来取消装饰器的作用。\n 例子：用装饰器来实现单例模式。\nfrom functools import wraps def singleton(cls): \u0026#34;\u0026#34;\u0026#34;装饰类的装饰器\u0026#34;\u0026#34;\u0026#34; instances = {} @wraps(cls) def wrapper(*args, **kwargs): if cls not in instances: instances[cls] = cls(*args, **kwargs) return instances[cls] return wrapper @singleton class President(): \u0026#34;\u0026#34;\u0026#34;总统(单例类)\u0026#34;\u0026#34;\u0026#34; pass  说明：上面的代码中用到了闭包（closure），不知道你是否已经意识到了。还没有一个小问题就是，上面的代码并没有实现线程安全的单例，如果要实现线程安全的单例应该怎么做呢？\n from functools import wraps from threading import Lock def singleton(cls): \u0026#34;\u0026#34;\u0026#34;线程安全的单例装饰器\u0026#34;\u0026#34;\u0026#34; instances = {} locker = Lock() @wraps(cls) def wrapper(*args, **kwargs): if cls not in instances: with locker: if cls not in instances: instances[cls] = cls(*args, **kwargs) return instances[cls] return wrapper 面向对象相关知识\n 三大支柱：封装、继承、多态  例子：工资结算系统。\n\u0026#34;\u0026#34;\u0026#34; 月薪结算系统 - 部门经理每月15000 程序员每小时200 销售员1800底薪加销售额5%提成 \u0026#34;\u0026#34;\u0026#34; from abc import ABCMeta, abstractmethod class Employee(metaclass=ABCMeta): \u0026#34;\u0026#34;\u0026#34;员工(抽象类)\u0026#34;\u0026#34;\u0026#34; def __init__(self, name): self.name = name @abstractmethod def get_salary(self): \u0026#34;\u0026#34;\u0026#34;结算月薪(抽象方法)\u0026#34;\u0026#34;\u0026#34; pass class Manager(Employee): \u0026#34;\u0026#34;\u0026#34;部门经理\u0026#34;\u0026#34;\u0026#34; def get_salary(self): return 15000.0 class Programmer(Employee): \u0026#34;\u0026#34;\u0026#34;程序员\u0026#34;\u0026#34;\u0026#34; def __init__(self, name, working_hour=0): self.working_hour = working_hour super().__init__(name) def get_salary(self): return 200.0 * self.working_hour class Salesman(Employee): \u0026#34;\u0026#34;\u0026#34;销售员\u0026#34;\u0026#34;\u0026#34; def __init__(self, name, sales=0.0): self.sales = sales super().__init__(name) def get_salary(self): return 1800.0 + self.sales * 0.05 class EmployeeFactory(): \u0026#34;\u0026#34;\u0026#34;创建员工的工厂（工厂模式 - 通过工厂实现对象使用者和对象之间的解耦合）\u0026#34;\u0026#34;\u0026#34; @staticmethod def create(emp_type, *args, **kwargs): \u0026#34;\u0026#34;\u0026#34;创建员工\u0026#34;\u0026#34;\u0026#34; emp_type = emp_type.upper() emp = None if emp_type == \u0026#39;M\u0026#39;: emp = Manager(*args, **kwargs) elif emp_type == \u0026#39;P\u0026#39;: emp = Programmer(*args, **kwargs) elif emp_type == \u0026#39;S\u0026#39;: emp = Salesman(*args, **kwargs) return emp def main(): \u0026#34;\u0026#34;\u0026#34;主函数\u0026#34;\u0026#34;\u0026#34; emps = [ EmployeeFactory.create(\u0026#39;M\u0026#39;, \u0026#39;曹操\u0026#39;), EmployeeFactory.create(\u0026#39;P\u0026#39;, \u0026#39;荀彧\u0026#39;, 120), EmployeeFactory.create(\u0026#39;P\u0026#39;, \u0026#39;郭嘉\u0026#39;, 85), EmployeeFactory.create(\u0026#39;S\u0026#39;, \u0026#39;典韦\u0026#39;, 123000), ] for emp in emps: print(\u0026#39;%s: %.2f元\u0026#39; % (emp.name, emp.get_salary())) if __name__ == \u0026#39;__main__\u0026#39;: main()  类与类之间的关系\n is-a关系：继承 has-a关系：关联 / 聚合 / 合成 use-a关系：依赖   例子：扑克游戏。\n\u0026#34;\u0026#34;\u0026#34; 经验：符号常量总是优于字面常量，枚举类型是定义符号常量的最佳选择 \u0026#34;\u0026#34;\u0026#34; from enum import Enum, unique import random @unique class Suite(Enum): \u0026#34;\u0026#34;\u0026#34;花色\u0026#34;\u0026#34;\u0026#34; SPADE, HEART, CLUB, DIAMOND = range(4) def __lt__(self, other): return self.value \u0026lt; other.value class Card(): \u0026#34;\u0026#34;\u0026#34;牌\u0026#34;\u0026#34;\u0026#34; def __init__(self, suite, face): \u0026#34;\u0026#34;\u0026#34;初始化方法\u0026#34;\u0026#34;\u0026#34; self.suite = suite self.face = face def show(self): \u0026#34;\u0026#34;\u0026#34;显示牌面\u0026#34;\u0026#34;\u0026#34; suites = [\u0026#39;♠️\u0026#39;, \u0026#39;♥️\u0026#39;, \u0026#39;♣️\u0026#39;, \u0026#39;♦️\u0026#39;] faces = [\u0026#39;\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;10\u0026#39;, \u0026#39;J\u0026#39;, \u0026#39;Q\u0026#39;, \u0026#39;K\u0026#39;] return f\u0026#39;{suites[self.suite.value]} {faces[self.face]}\u0026#39; def __str__(self): return self.show() def __repr__(self): return self.show() class Poker(): \u0026#34;\u0026#34;\u0026#34;扑克\u0026#34;\u0026#34;\u0026#34; def __init__(self): self.index = 0 self.cards = [Card(suite, face) for suite in Suite for face in range(1, 14)] def shuffle(self): \u0026#34;\u0026#34;\u0026#34;洗牌（随机乱序）\u0026#34;\u0026#34;\u0026#34; random.shuffle(self.cards) self.index = 0 def deal(self): \u0026#34;\u0026#34;\u0026#34;发牌\u0026#34;\u0026#34;\u0026#34; card = self.cards[self.index] self.index += 1 return card @property def has_more(self): return self.index \u0026lt; len(self.cards) class Player(): \u0026#34;\u0026#34;\u0026#34;玩家\u0026#34;\u0026#34;\u0026#34; def __init__(self, name): self.name = name self.cards = [] def get_one(self, card): \u0026#34;\u0026#34;\u0026#34;摸一张牌\u0026#34;\u0026#34;\u0026#34; self.cards.append(card) def sort(self, comp=lambda card: (card.suite, card.face)): \u0026#34;\u0026#34;\u0026#34;整理手上的牌\u0026#34;\u0026#34;\u0026#34; self.cards.sort(key=comp) def main(): \u0026#34;\u0026#34;\u0026#34;主函数\u0026#34;\u0026#34;\u0026#34; poker = Poker() poker.shuffle() players = [Player(\u0026#39;东邪\u0026#39;), Player(\u0026#39;西毒\u0026#39;), Player(\u0026#39;南帝\u0026#39;), Player(\u0026#39;北丐\u0026#39;)] while poker.has_more: for player in players: player.get_one(poker.deal()) for player in players: player.sort() print(player.name, end=\u0026#39;: \u0026#39;) print(player.cards) if __name__ == \u0026#39;__main__\u0026#39;: main()  说明：上面的代码中使用了Emoji字符来表示扑克牌的四种花色，在某些不支持Emoji字符的系统上可能无法显示。\n  对象的复制（深复制/深拷贝/深度克隆和浅复制/浅拷贝/影子克隆）\n 垃圾回收、循环引用和弱引用\n  Python使用了自动化内存管理，这种管理机制以引用计数为基础，同时也引入了标记-清除和分代收集两种机制为辅的策略。\ntypedef struct_object { /* 引用计数 */ int ob_refcnt; /* 对象指针 */ struct_typeobject *ob_type; } PyObject;/* 增加引用计数的宏定义 */ #define Py_INCREF(op) ((op)-\u0026gt;ob_refcnt++)  /* 减少引用计数的宏定义 */ #define Py_DECREF(op) \\ //减少计数  if (--(op)-\u0026gt;ob_refcnt != 0) \\ ; \\ else \\ __Py_Dealloc((PyObject *)(op)) 导致引用计数+1的情况：\n 对象被创建，例如a = 23 对象被引用，例如b = a 对象被作为参数，传入到一个函数中，例如f(a) 对象作为一个元素，存储在容器中，例如list1 = [a, a]  导致引用计数-1的情况：\n 对象的别名被显式销毁，例如del a 对象的别名被赋予新的对象，例如a = 24 一个对象离开它的作用域，例如f函数执行完毕时，f函数中的局部变量（全局变量不会） 对象所在的容器被销毁，或从容器中删除对象  引用计数可能会导致循环引用问题，而循环引用会导致内存泄露，如下面的代码所示。为了解决这个问题，Python中引入了“标记-清除”和“分代收集”。在创建一个对象的时候，对象被放在第一代中，如果在第一代的垃圾检查中对象存活了下来，该对象就会被放到第二代中，同理在第二代的垃圾检查中对象存活下来，该对象就会被放到第三代中。\n# 循环引用会导致内存泄露 - Python除了引用技术还引入了标记清理和分代回收 # 在Python 3.6以前如果重写__del__魔术方法会导致循环引用处理失效 # 如果不想造成循环引用可以使用弱引用 list1 = [] list2 = [] list1.append(list2) list2.append(list1) 以下情况会导致垃圾回收：\n 调用gc.collect() gc模块的计数器达到阀值 程序退出  如果循环引用中两个对象都定义了__del__方法，gc模块不会销毁这些不可达对象，因为gc模块不知道应该先调用哪个对象的__del__方法，这个问题在Python 3.6中得到了解决。\n也可以通过weakref模块构造弱引用的方式来解决循环引用的问题。\n 魔法属性和方法（请参考《Python魔法方法指南》）  有几个小问题请大家思考：\n 自定义的对象能不能使用运算符做运算？ 自定义的对象能不能放到set中？能去重吗？ 自定义的对象能不能作为dict的键？ 自定义的对象能不能使用上下文语法？\n 混入（Mixin）\n  例子：自定义字典限制只有在指定的key不存在时才能在字典中设置键值对。\nclass SetOnceMappingMixin(): \u0026#34;\u0026#34;\u0026#34;自定义混入类\u0026#34;\u0026#34;\u0026#34; __slots__ = () def __setitem__(self, key, value): if key in self: raise KeyError(str(key) + \u0026#39; already set\u0026#39;) return super().__setitem__(key, value) class SetOnceDict(SetOnceMappingMixin, dict): \u0026#34;\u0026#34;\u0026#34;自定义字典\u0026#34;\u0026#34;\u0026#34; pass my_dict= SetOnceDict() try: my_dict[\u0026#39;username\u0026#39;] = \u0026#39;jackfrued\u0026#39; my_dict[\u0026#39;username\u0026#39;] = \u0026#39;hellokitty\u0026#39; except KeyError: pass print(my_dict)  元编程和元类  例子：用元类实现单例模式。\nimport threading class SingletonMeta(type): \u0026#34;\u0026#34;\u0026#34;自定义元类\u0026#34;\u0026#34;\u0026#34; def __init__(cls, *args, **kwargs): cls.__instance = None cls.__lock = threading.Lock() super().__init__(*args, **kwargs) def __call__(cls, *args, **kwargs): if cls.__instance is None: with cls.__lock: if cls.__instance is None: cls.__instance = super().__call__(*args, **kwargs) return cls.__instance class President(metaclass=SingletonMeta): \u0026#34;\u0026#34;\u0026#34;总统(单例类)\u0026#34;\u0026#34;\u0026#34; pass  面向对象设计原则\n 单一职责原则 （SRP）- 一个类只做该做的事情（类的设计要高内聚） 开闭原则 （OCP）- 软件实体应该对扩展开发对修改关闭 依赖倒转原则（DIP）- 面向抽象编程（在弱类型语言中已经被弱化） 里氏替换原则（LSP） - 任何时候可以用子类对象替换掉父类对象 接口隔离原则（ISP）- 接口要小而专不要大而全（Python中没有接口的概念） 合成聚合复用原则（CARP） - 优先使用强关联关系而不是继承关系复用代码 最少知识原则（迪米特法则，LoD）- 不要给没有必然联系的对象发消息    说明：上面加粗的字母放在一起称为面向对象的SOLID原则。\n  GoF设计模式\n 创建型模式：单例、工厂、建造者、原型 结构型模式：适配器、门面（外观）、代理 行为型模式：迭代器、观察者、状态、策略   例子：可插拔的哈希算法。\nclass StreamHasher(): \u0026#34;\u0026#34;\u0026#34;哈希摘要生成器(策略模式)\u0026#34;\u0026#34;\u0026#34; def __init__(self, alg=\u0026#39;md5\u0026#39;, size=4096): self.size = size alg = alg.lower() self.hasher = getattr(__import__(\u0026#39;hashlib\u0026#39;), alg.lower())() def __call__(self, stream): return self.to_digest(stream) def to_digest(self, stream): \u0026#34;\u0026#34;\u0026#34;生成十六进制形式的摘要\u0026#34;\u0026#34;\u0026#34; for buf in iter(lambda: stream.read(self.size), b\u0026#39;\u0026#39;): self.hasher.update(buf) return self.hasher.hexdigest() def main(): \u0026#34;\u0026#34;\u0026#34;主函数\u0026#34;\u0026#34;\u0026#34; hasher1 = StreamHasher() with open(\u0026#39;Python-3.7.1.tgz\u0026#39;, \u0026#39;rb\u0026#39;) as stream: print(hasher1.to_digest(stream)) hasher2 = StreamHasher(\u0026#39;sha1\u0026#39;) with open(\u0026#39;Python-3.7.1.tgz\u0026#39;, \u0026#39;rb\u0026#39;) as stream: print(hasher2(stream)) if __name__ == \u0026#39;__main__\u0026#39;: main() 迭代器和生成器\n 和迭代器相关的魔术方法（__iter__和__next__）\n 两种创建生成器的方式（生成器表达式和yield关键字）\ndef fib(num): \u0026#34;\u0026#34;\u0026#34;生成器\u0026#34;\u0026#34;\u0026#34; a, b = 0, 1 for _ in range(num): a, b = b, a + b yield a class Fib(object): \u0026#34;\u0026#34;\u0026#34;迭代器\u0026#34;\u0026#34;\u0026#34; def __init__(self, num): self.num = num self.a, self.b = 0, 1 self.idx = 0 def __iter__(self): return self def __next__(self): if self.idx \u0026lt; self.num: self.a, self.b = self.b, self.a + self.b self.idx += 1 return self.a raise StopIteration()  并发编程\n  Python中实现并发编程的三种方案：多线程、多进程和异步I/O。并发编程的好处在于可以提升程序的执行效率以及改善用户体验；坏处在于并发的程序不容易开发和调试，同时对其他程序来说它并不友好。\n 多线程：Python中提供了Thread类并辅以Lock、Condition、Event、Semaphore和Barrier。Python中有GIL来防止多个线程同时执行本地字节码，这个锁对于CPython是必须的，因为CPython的内存管理并不是线程安全的，因为GIL的存在多线程并不能发挥CPU的多核特性。\n\u0026#34;\u0026#34;\u0026#34; 面试题：进程和线程的区别和联系？ 进程 - 操作系统分配内存的基本单位 - 一个进程可以包含一个或多个线程 线程 - 操作系统分配CPU的基本单位 并发编程（concurrent programming） 1. 提升执行性能 - 让程序中没有因果关系的部分可以并发的执行 2. 改善用户体验 - 让耗时间的操作不会造成程序的假死 \u0026#34;\u0026#34;\u0026#34; import glob import os import threading from PIL import Image PREFIX = \u0026#39;thumbnails\u0026#39; def generate_thumbnail(infile, size, format=\u0026#39;PNG\u0026#39;): \u0026#34;\u0026#34;\u0026#34;生成指定图片文件的缩略图\u0026#34;\u0026#34;\u0026#34; file, ext = os.path.splitext(infile) file = file[file.rfind(\u0026#39;/\u0026#39;) + 1:] outfile = f\u0026#39;{PREFIX}/{file}_{size[0]}_{size[1]}.{ext}\u0026#39; img = Image.open(infile) img.thumbnail(size, Image.ANTIALIAS) img.save(outfile, format) def main(): \u0026#34;\u0026#34;\u0026#34;主函数\u0026#34;\u0026#34;\u0026#34; if not os.path.exists(PREFIX): os.mkdir(PREFIX) for infile in glob.glob(\u0026#39;images/*.png\u0026#39;): for size in (32, 64, 128): # 创建并启动线程 threading.Thread( target=generate_thumbnail, args=(infile, (size, size)) ).start() if __name__ == \u0026#39;__main__\u0026#39;: main() 多个线程竞争资源的情况\n\u0026#34;\u0026#34;\u0026#34; 多线程程序如果没有竞争资源处理起来通常也比较简单 当多个线程竞争临界资源的时候如果缺乏必要的保护措施就会导致数据错乱 说明：临界资源就是被多个线程竞争的资源 \u0026#34;\u0026#34;\u0026#34; import time import threading from concurrent.futures import ThreadPoolExecutor class Account(object): \u0026#34;\u0026#34;\u0026#34;银行账户\u0026#34;\u0026#34;\u0026#34; def __init__(self): self.balance = 0.0 self.lock = threading.Lock() def deposit(self, money): # 通过锁保护临界资源 with self.lock: new_balance = self.balance + money time.sleep(0.001) self.balance = new_balance class AddMoneyThread(threading.Thread): \u0026#34;\u0026#34;\u0026#34;自定义线程类\u0026#34;\u0026#34;\u0026#34; def __init__(self, account, money): self.account = account self.money = money # 自定义线程的初始化方法中必须调用父类的初始化方法 super().__init__() def run(self): # 线程启动之后要执行的操作 self.account.deposit(self.money) def main(): \u0026#34;\u0026#34;\u0026#34;主函数\u0026#34;\u0026#34;\u0026#34; account = Account() # 创建线程池 pool = ThreadPoolExecutor(max_workers=10) futures = [] for _ in range(100): # 创建线程的第1种方式 # threading.Thread( # target=account.deposit, args=(1, ) # ).start() # 创建线程的第2种方式 # AddMoneyThread(account, 1).start() # 创建线程的第3种方式 # 调用线程池中的线程来执行特定的任务 future = pool.submit(account.deposit, 1) futures.append(future) # 关闭线程池 pool.shutdown() for future in futures: future.result() print(account.balance) if __name__ == \u0026#39;__main__\u0026#39;: main() 修改上面的程序，启动5个线程向账户中存钱，5个线程从账户中取钱，取钱时如果余额不足就暂停线程进行等待。为了达到上述目标，需要对存钱和取钱的线程进行调度，在余额不足时取钱的线程暂停并释放锁，而存钱的线程将钱存入后要通知取钱的线程，使其从暂停状态被唤醒。可以使用threading模块的Condition来实现线程调度，该对象也是基于锁来创建的，代码如下所示：\n\u0026#34;\u0026#34;\u0026#34; 多个线程竞争一个资源 - 保护临界资源 - 锁（Lock/RLock） 多个线程竞争多个资源（线程数\u0026gt;资源数） - 信号量（Semaphore） 多个线程的调度 - 暂停线程执行/唤醒等待中的线程 - Condition \u0026#34;\u0026#34;\u0026#34; from concurrent.futures import ThreadPoolExecutor from random import randint from time import sleep import threading class Account(): \u0026#34;\u0026#34;\u0026#34;银行账户\u0026#34;\u0026#34;\u0026#34; def __init__(self, balance=0): self.balance = balance lock = threading.Lock() self.condition = threading.Condition(lock) def withdraw(self, money): \u0026#34;\u0026#34;\u0026#34;取钱\u0026#34;\u0026#34;\u0026#34; with self.condition: while money \u0026gt; self.balance: self.condition.wait() new_balance = self.balance - money sleep(0.001) self.balance = new_balance def deposit(self, money): \u0026#34;\u0026#34;\u0026#34;存钱\u0026#34;\u0026#34;\u0026#34; with self.condition: new_balance = self.balance + money sleep(0.001) self.balance = new_balance self.condition.notify_all() def add_money(account): while True: money = randint(5, 10) account.deposit(money) print(threading.current_thread().name, \u0026#39;:\u0026#39;, money, \u0026#39;====\u0026gt;\u0026#39;, account.balance) sleep(0.5) def sub_money(account): while True: money = randint(10, 30) account.withdraw(money) print(threading.current_thread().name, \u0026#39;:\u0026#39;, money, \u0026#39;\u0026lt;====\u0026#39;, account.balance) sleep(1) def main(): account = Account() with ThreadPoolExecutor(max_workers=10) as pool: for _ in range(5): pool.submit(add_money, account) pool.submit(sub_money, account) if __name__ == \u0026#39;__main__\u0026#39;: main() 多进程：多进程可以有效的解决GIL的问题，实现多进程主要的类是Process，其他辅助的类跟threading模块中的类似，进程间共享数据可以使用管道、套接字等，在multiprocessing模块中有一个Queue类，它基于管道和锁机制提供了多个进程共享的队列。下面是官方文档上关于多进程和进程池的一个示例。\n\u0026#34;\u0026#34;\u0026#34; 多进程和进程池的使用 多线程因为GIL的存在不能够发挥CPU的多核特性 对于计算密集型任务应该考虑使用多进程 time python3 example22.py real 0m11.512s user 0m39.319s sys 0m0.169s 使用多进程后实际执行时间为11.512秒，而用户时间39.319秒约为实际执行时间的4倍 这就证明我们的程序通过多进程使用了CPU的多核特性，而且这台计算机配置了4核的CPU \u0026#34;\u0026#34;\u0026#34; import concurrent.futures import math PRIMES = [ 1116281, 1297337, 104395303, 472882027, 533000389, 817504243, 982451653, 112272535095293, 112582705942171, 112272535095293, 115280095190773, 115797848077099, 1099726899285419 ] * 5 def is_prime(n): \u0026#34;\u0026#34;\u0026#34;判断素数\u0026#34;\u0026#34;\u0026#34; if n % 2 == 0: return False sqrt_n = int(math.floor(math.sqrt(n))) for i in range(3, sqrt_n + 1, 2): if n % i == 0: return False return True def main(): \u0026#34;\u0026#34;\u0026#34;主函数\u0026#34;\u0026#34;\u0026#34; with concurrent.futures.ProcessPoolExecutor() as executor: for number, prime in zip(PRIMES, executor.map(is_prime, PRIMES)): print(\u0026#39;%dis prime: %s\u0026#39; % (number, prime)) if __name__ == \u0026#39;__main__\u0026#39;: main()  说明：多线程和多进程的比较。\n以下情况需要使用多线程：\n 程序需要维护许多共享的状态（尤其是可变状态），Python中的列表、字典、集合都是线程安全的，所以使用线程而不是进程维护共享状态的代价相对较小。 程序会花费大量时间在I/O操作上，没有太多并行计算的需求且不需占用太多的内存。  以下情况需要使用多进程：\n 程序执行计算密集型任务（如：字节码操作、数据处理、科学计算）。 程序的输入可以并行的分成块，并且可以将运算结果合并。 程序在内存使用方面没有任何限制且不强依赖于I/O操作（如：读写文件、套接字等）。   异步处理：从调度程序的任务队列中挑选任务，该调度程序以交叉的形式执行这些任务，我们并不能保证任务将以某种顺序去执行，因为执行顺序取决于队列中的一项任务是否愿意将CPU处理时间让位给另一项任务。异步任务通常通过多任务协作处理的方式来实现，由于执行时间和顺序的不确定，因此需要通过回调式编程或者future对象来获取任务执行的结果。Python 3通过asyncio模块和await和async关键字（在Python 3.7中正式被列为关键字）来支持异步处理。\n\u0026#34;\u0026#34;\u0026#34; 异步I/O - async / await \u0026#34;\u0026#34;\u0026#34; import asyncio def num_generator(m, n): \u0026#34;\u0026#34;\u0026#34;指定范围的数字生成器\u0026#34;\u0026#34;\u0026#34; yield from range(m, n + 1) async def prime_filter(m, n): \u0026#34;\u0026#34;\u0026#34;素数过滤器\u0026#34;\u0026#34;\u0026#34; primes = [] for i in num_generator(m, n): flag = True for j in range(2, int(i ** 0.5 + 1)): if i % j == 0: flag = False break if flag: print(\u0026#39;Prime =\u0026gt;\u0026#39;, i) primes.append(i) await asyncio.sleep(0.001) return tuple(primes) async def square_mapper(m, n): \u0026#34;\u0026#34;\u0026#34;平方映射器\u0026#34;\u0026#34;\u0026#34; squares = [] for i in num_generator(m, n): print(\u0026#39;Square =\u0026gt;\u0026#39;, i * i) squares.append(i * i) await asyncio.sleep(0.001) return squares def main(): \u0026#34;\u0026#34;\u0026#34;主函数\u0026#34;\u0026#34;\u0026#34; loop = asyncio.get_event_loop() future = asyncio.gather(prime_filter(2, 100), square_mapper(1, 100)) future.add_done_callback(lambda x: print(x.result())) loop.run_until_complete(future) loop.close() if __name__ == \u0026#39;__main__\u0026#39;: main()  说明：上面的代码使用get_event_loop函数获得系统默认的事件循环，通过gather函数可以获得一个future对象，future对象的add_done_callback可以添加执行完成时的回调函数，loop对象的run_until_complete方法可以等待通过future对象获得协程执行结果。\n Python中有一个名为aiohttp的三方库，它提供了异步的HTTP客户端和服务器，这个三方库可以跟asyncio模块一起工作，并提供了对Future对象的支持。Python 3.6中引入了async和await来定义异步执行的函数以及创建异步上下文，在Python 3.7中它们正式成为了关键字。下面的代码异步的从5个URL中获取页面并通过正则表达式的命名捕获组提取了网站的标题。\nimport asyncio import re import aiohttp PATTERN = re.compile(r\u0026#39;\\\u0026lt;title\\\u0026gt;(?P\u0026lt;title\u0026gt;.*)\\\u0026lt;\\/title\\\u0026gt;\u0026#39;) async def fetch_page(session, url): async with session.get(url, ssl=False) as resp: return await resp.text() async def show_title(url): async with aiohttp.ClientSession() as session: html = await fetch_page(session, url) print(PATTERN.search(html).group(\u0026#39;title\u0026#39;)) def main(): urls = (\u0026#39;https://www.python.org/\u0026#39;, \u0026#39;https://git-scm.com/\u0026#39;, \u0026#39;https://www.jd.com/\u0026#39;, \u0026#39;https://www.taobao.com/\u0026#39;, \u0026#39;https://www.douban.com/\u0026#39;) loop = asyncio.get_event_loop() tasks = [show_title(url) for url in urls] loop.run_until_complete(asyncio.wait(tasks)) loop.close() if __name__ == \u0026#39;__main__\u0026#39;: main()  说明：异步I/O与多进程的比较。\n当程序不需要真正的并发性或并行性，而是更多的依赖于异步处理和回调时，asyncio就是一种很好的选择。如果程序中有大量的等待与休眠时，也应该考虑asyncio，它很适合编写没有实时数据处理需求的Web应用服务器。\n Python还有很多用于处理并行任务的三方库，例如：joblib、PyMP等。实际开发中，要提升系统的可扩展性和并发性通常有垂直扩展（增加单个节点的处理能力）和水平扩展（将单个节点变成多个节点）两种做法。可以通过消息队列来实现应用程序的解耦合，消息队列相当于是多线程同步队列的扩展版本，不同机器上的应用程序相当于就是线程，而共享的分布式消息队列就是原来程序中的Queue。消息队列（面向消息的中间件）的最流行和最标准化的实现是AMQP（高级消息队列协议），AMQP源于金融行业，提供了排队、路由、可靠传输、安全等功能，最著名的实现包括：Apache的ActiveMQ、RabbitMQ等。\n要实现任务的异步化，可以使用名为Celery的三方库。Celery是Python编写的分布式任务队列，它使用分布式消息进行工作，可以基于RabbitMQ或Redis来作为后端的消息代理。\n  "},{"idx":27,"href":"/python100days/docs/Day21-30/21-30-Web%E5%89%8D%E7%AB%AF%E6%A6%82%E8%BF%B0/","title":"21 30 Web前端概述","content":" Web前端概述  说明：本文使用的部分插图来自*Jon Duckett先生的HTML and CSS: Design and Build Websites*一书，这是一本非常棒的前端入门书，有兴趣的读者可以在亚马逊或者其他网站上找到该书的购买链接。\n HTML简史  1991年10月：一个非正式CERN（欧洲核子研究中心）文件首次公开18个HTML标签，这个文件的作者是物理学家蒂姆·伯纳斯-李，因此他是万维网的发明者，也是万维网联盟的主席。 1995年11月：HTML 2.0标准发布（RFC 1866）。 1997年1月：HTML 3.2作为W3C推荐标准发布。 1997年12月：HTML 4.0作为W3C推荐标准发布。 1999年12月：HTML4.01作为W3C推荐标准发布。 2008年1月：HTML5由W3C作为工作草案发布。 2011年5月：W3C将HTML5推进至“最终征求”（Last Call）阶段。 2012年12月：W3C指定HTML5作为“候选推荐”阶段。 2014年10月：HTML5作为稳定W3C推荐标准发布，这意味着HTML5的标准化已经完成。  HTML5新特性  引入原生多媒体支持（audio和video标签） 引入可编程内容（canvas标签） 引入语义Web（article、aside、details、figure、footer、header、nav、section、summary等标签） 引入新的表单控件（日历、邮箱、搜索、滑条等） 引入对离线存储更好的支持（localStorage和sessionStorage） 引入对定位、拖放、WebSocket、后台任务等的支持  使用标签承载内容 结构  html  head title meta body   文本  标题（heading）和段落（paragraph）  h1 ~ h6 p  上标（superscript）和下标（subscript）  sup sub  空白（白色空间折叠） 折行（break）和水平标尺（horizontal ruler）  br hr  语义化标签  加粗和强调 - strong 引用 - blockquote 缩写词和首字母缩写词 - abbr / acronym 引文 - cite 所有者联系信息 - address 内容的修改 - ins / del   列表（list）  有序列表（ordered list）- ol / li 无序列表（unordered list）- ul / li 定义列表（definition list）- dl / dt / dd  链接（anchor）  页面链接 锚链接 功能链接  图像（image）  图像存储位置   图像及其宽高\n 选择正确的图像格式\n JPEG GIF PNG  矢量图\n 语义化标签 - figure / figcaption\n  表格（table）  基本的表格结构 - table / tr / td / th 表格的标题 - caption 跨行和跨列 - rowspan属性 / colspan属性 长表格 - thead / tbody / tfoot  表单（form）  重要属性 - action / method / enctype 表单控件（input）- type属性  文本框 - text / 密码框 - password / 数字框 - number 邮箱 - email / 电话 - tel / 日期 - date / 滑条 - range / URL - url / 搜索 - search 单选按钮 - radio / 复选按钮 - checkbox 文件上传 - file / 隐藏域 - hidden 提交按钮 - submit / 图像按钮 - image / 重置按钮 - reset  下拉列表 - select / option 文本域（多行文本）- textarea 组合表单元素 - fieldset / legend  音视频（audio / video）  视频格式和播放器 视频托管服务 添加视频的准备工作 video标签和属性 - autoplay / controls / loop / muted / preload / src audio标签和属性 - autoplay / controls / loop / muted / preload / src / width / height / poster  窗口（frame）  框架集（过时，不建议使用） - frameset / frame\n 内嵌窗口 - iframe\n  其他  文档类型\n\u0026lt;!doctype html\u0026gt;\u0026lt;!DOCTYPE HTML PUBLIC \u0026#34;-//W3C//DTD HTML 4.01//EN\u0026#34; \u0026#34;http://www.w3.org/TR/html4/strict.dtd\u0026#34;\u0026gt;\u0026lt;!DOCTYPE HTML PUBLIC \u0026#34;-//W3C//DTD HTML 4.01 Transitional//EN\u0026#34; \u0026#34;http://www.w3.org/TR/html4/loose.dtd\u0026#34;\u0026gt; 注释\n\u0026lt;!-- 这是一段注释，注释不能够嵌套 --\u0026gt; 属性\n id：唯一标识 class：元素所属的类，用于区分不同的元素 title：元素的额外信息（鼠标悬浮时会显示工具提示文本） tabindex：Tab键切换顺序 contenteditable：元素是否可编辑 draggable：元素是否可拖拽  块级元素 / 行级元素\n 字符实体（实体替换符）\n  使用CSS渲染页面 简介  CSS的作用\n CSS的工作原理\n 规则、属性和值\n   常用选择器  颜色（color）  如何指定颜色 颜色术语和颜色对比 背景色  文本（text / font）  文本的大小和字型(font-size / font-family)   粗细、样式、拉伸和装饰(font-weight / font-style / font-stretch / text-decoration)   行间距(line-height)、字母间距(letter-spacing)和单词间距(word-spacing)\n 对齐(text-align)方式和缩进(text-ident)\n 链接样式（:link / :visited / :active / :hover）\n CSS3新属性\n 阴影效果 - text-shadow 首字母和首行文本(:first-letter / :first-line) 响应用户   盒子（box model）  盒子大小的控制（width / height）   盒子的边框、外边距和内边距（border / margin / padding）   盒子的显示和隐藏（display / visibility）\n CSS3新属性\n 边框图像（border-image） 投影（border-shadow） 圆角（border-radius）   列表、表格和表单  列表的项目符号（list-style） 表格的边框和背景（border-collapse） 表单控件的外观 表单控件的对齐 浏览器的开发者工具  图像  控制图像的大小（display: inline-block） 对齐图像 背景图像（background / background-image / background-repeat / background-position）  布局  控制元素的位置（position / z-index）  普通流 相对定位 绝对定位 固定定位 浮动元素（float / clear）  网站布局\n HTML5布局   适配屏幕尺寸\n 固定宽度布局 流体布局 布局网格   使用JavaScript控制行为 JavaScript基本语法  语句和注释 变量和数据类型  声明和赋值 简单数据类型和复杂数据类型 变量的命名规则  表达式和运算符  赋值运算符 算术运算符 比较运算符 逻辑运算符  分支结构  if...else... switch...cas...default...  循环结构  for循环 while循环 do...while循环  数组  创建数组 操作数组中的元素  函数  声明函数 调用函数 参数和返回值 匿名函数 立即调用函数   面向对象  对象的概念 创建对象的字面量语法 访问成员运算符 创建对象的构造函数语法  this关键字  添加和删除属性  delete关键字  标准对象  Number / String / Boolean / Symbol / Array / Function Date / Error / Math / RegEx / Object / Map / Set JSON / Promise / Generator / Reflect / Proxy   BOM  window对象的属性和方法 history对象  forward() / back() / go()  location对象 navigator对象 screen对象  DOM  DOM树 访问元素  getElementById() / querySelector() getElementsByClassName() / getElementsByTagName() / querySelectorAll() parentNode / previousSibling / nextSibling / children / firstChild / lastChild  操作元素  nodeValue innerHTML / textContent / createElement() / createTextNode() / appendChild() / insertBefore() / removeChild() className / id / hasAttribute() / getAttribute() / setAttribute() / removeAttribute()  事件处理  事件类型 UI事件：load / unload / error / resize / scroll 键盘事件：keydown / keyup / keypress 鼠标事件：click / dbclick / mousedown / mouseup / mousemove / mouseover / mouseout 焦点事件：focus / blur 表单事件：input / change / submit / reset / cut / copy / paste / select 事件绑定 HTML事件处理程序（不推荐使用，因为要做到标签与代码分离） 传统的DOM事件处理程序（只能附加一个回调函数） 事件监听器（旧的浏览器中不被支持） 事件流：事件捕获 / 事件冒泡 事件对象（低版本IE中的window.event） target（有些浏览器使用srcElement） type cancelable preventDefault() stopPropagation()（低版本IE中的cancelBubble） 鼠标事件 - 事件发生的位置 屏幕位置：screenX和screenY 页面位置：pageX和pageY 客户端位置：clientX和clientY 键盘事件 - 哪个键被按下了 keyCode属性（有些浏览器使用which） String.fromCharCode(event.keyCode) HTML5事件 DOMContentLoaded hashchange beforeunload   JavaScript API  客户端存储 - localStorage和sessionStorage\nlocalStorage.colorSetting = \u0026#39;#a4509b\u0026#39;; localStorage[\u0026#39;colorSetting\u0026#39;] = \u0026#39;#a4509b\u0026#39;; localStorage.setItem(\u0026#39;colorSetting\u0026#39;, \u0026#39;#a4509b\u0026#39;);  获取位置信息 - geolocation\nnavigator.geolocation.getCurrentPosition(function(pos) { console.log(pos.coords.latitude) console.log(pos.coords.longitude) })  从服务器获取数据 - Fetch API\n 绘制图形 - \u0026lt;canvas\u0026gt;的API\n 音视频 - \u0026lt;audio\u0026gt;和\u0026lt;video\u0026gt;的API\n  使用jQuery jQuery概述  Write Less Do More（用更少的代码来完成更多的工作） 使用CSS选择器来查找元素（更简单更方便） 使用jQuery方法来操作元素（解决浏览器兼容性问题、应用于所有元素并施加多个方法）  引入jQuery  下载jQuery的开发版和压缩版 从CDN加载jQuery\n\u0026lt;script src=\u0026#34;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; window.jQuery || document.write(\u0026#39;\u0026lt;script src=\u0026#34;js/jquery-3.3.1.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026#39;) \u0026lt;/script\u0026gt;  查找元素  选择器  * / element / #id / .class / selector1, selector2 ancestor descendant / parent\u0026gt;child / previous+next / previous~siblings  筛选器  基本筛选器：:not(selector) / :first / :last / :even / :odd / :eq(index) / :gt(index) / :lt(index) / :animated / :focus 内容筛选器：:contains(\u0026lsquo;…\u0026rsquo;) / :empty / :parent / :has(selector) 可见性筛选器：:hidden / :visible 子节点筛选器：:nth-child(expr) / :first-child / :last-child / :only-child 属性筛选器：[attribute] / [attribute=\u0026lsquo;value\u0026rsquo;] / [attribute!=\u0026lsquo;value\u0026rsquo;] / [attribute^=\u0026lsquo;value\u0026rsquo;] / [attribute$=\u0026lsquo;value\u0026rsquo;] / [attribute|=\u0026lsquo;value\u0026rsquo;] / [attribute~=\u0026lsquo;value\u0026rsquo;]  表单：:input / :text / :password / :radio / :checkbox / :submit / :image / :reset / :button / :file / :selected / :enabled / :disabled / :checked  执行操作  内容操作  获取/修改内容：html() / text() / replaceWith() / remove() 获取/设置元素：before() / after() / prepend() / append() / remove() / clone() / unwrap() / detach() / empty() / add() 获取/修改属性：attr() / removeAttr() / addClass() / removeClass() / css() 获取/设置表单值：val()  查找操作  查找方法：find() / parent() / children() / siblings() / next() / nextAll() / prev() / prevAll() 筛选器：filter() / not() / has() / is() / contains() 索引编号：eq()  尺寸和位置  尺寸相关：height() / width() / innerHeight() / innerWidth() / outerWidth() / outerHeight() 位置相关：offset() / position() / scrollLeft() / scrollTop()  特效和动画  基本动画：show() / hide() / toggle() 消失出现：fadeIn() / fadeOut() / fadeTo() / fadeToggle() 滑动效果：slideDown() / slideUp() / slideToggle() 自定义：delay() / stop() / animate()  事件  文档加载：ready() / load() 用户交互：on() / off()   链式操作 检测页面是否可用 \u0026lt;script\u0026gt; $(document).ready(function() { }); \u0026lt;/script\u0026gt;\u0026lt;script\u0026gt; $(function() { }); \u0026lt;/script\u0026gt; jQuery插件  jQuery Validation jQuery Treeview jQuery Autocomplete jQuery UI  避免和其他库的冲突 先引入其他库再引入jQuery的情况。\n\u0026lt;script src=\u0026#34;other.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;jquery.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; jQuery.noConflict(); jQuery(function() { jQuery(\u0026#39;div\u0026#39;).hide(); }); \u0026lt;/script\u0026gt; 先引入jQuery再引入其他库的情况。\n\u0026lt;script src=\u0026#34;jquery.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;other.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; jQuery(function() { jQuery(\u0026#39;div\u0026#39;).hide(); }); \u0026lt;/script\u0026gt; 使用Ajax Ajax是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。\n 原生的Ajax 基于jQuery的Ajax  加载内容 提交表单   前端框架 渐进式框架 - Vue.js 前后端分离开发（前端渲染）必选框架。\n快速上手  引入Vue的JavaScript文件，我们仍然推荐从CDN服务器加载它。\n\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 数据绑定（声明式渲染 ）。\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;{{ product }}库存信息\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { product: \u0026#39;iPhone X\u0026#39; } }); \u0026lt;/script\u0026gt; 条件与循环。\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;库存信息\u0026lt;/h1\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;product in products\u0026#34;\u0026gt; {{ product.name }} - {{ product.quantity }} \u0026lt;span v-if=\u0026#34;product.quantity === 0\u0026#34;\u0026gt; 已经售罄 \u0026lt;/span\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { products: [ {\u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;iPhone X\u0026#34;, \u0026#34;quantity\u0026#34;: 20}, {\u0026#34;id\u0026#34;: 2, \u0026#34;name\u0026#34;: \u0026#34;华为 Mate20\u0026#34;, \u0026#34;quantity\u0026#34;: 0}, {\u0026#34;id\u0026#34;: 3, \u0026#34;name\u0026#34;: \u0026#34;小米 Mix3\u0026#34;, \u0026#34;quantity\u0026#34;: 50} ] } }); \u0026lt;/script\u0026gt; 计算属性。\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;库存信息\u0026lt;/h1\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;product in products\u0026#34;\u0026gt; {{ product.name }} - {{ product.quantity }} \u0026lt;span v-if=\u0026#34;product.quantity === 0\u0026#34;\u0026gt; 已经售罄 \u0026lt;/span\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;h2\u0026gt;库存总量：{{ totalQuantity }}台\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { products: [ {\u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;iPhone X\u0026#34;, \u0026#34;quantity\u0026#34;: 20}, {\u0026#34;id\u0026#34;: 2, \u0026#34;name\u0026#34;: \u0026#34;华为 Mate20\u0026#34;, \u0026#34;quantity\u0026#34;: 0}, {\u0026#34;id\u0026#34;: 3, \u0026#34;name\u0026#34;: \u0026#34;小米 Mix3\u0026#34;, \u0026#34;quantity\u0026#34;: 50} ] }, computed: { totalQuantity() { return this.products.reduce((sum, product) =\u0026gt; { return sum + product.quantity }, 0); } } }); \u0026lt;/script\u0026gt; 处理事件。\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;库存信息\u0026lt;/h1\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;product in products\u0026#34;\u0026gt; {{ product.name }} - {{ product.quantity }} \u0026lt;span v-if=\u0026#34;product.quantity === 0\u0026#34;\u0026gt; 已经售罄 \u0026lt;/span\u0026gt; \u0026lt;button @click=\u0026#34;product.quantity += 1\u0026#34;\u0026gt; 增加库存 \u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;h2\u0026gt;库存总量：{{ totalQuantity }}台\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { products: [ {\u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;iPhone X\u0026#34;, \u0026#34;quantity\u0026#34;: 20}, {\u0026#34;id\u0026#34;: 2, \u0026#34;name\u0026#34;: \u0026#34;华为 Mate20\u0026#34;, \u0026#34;quantity\u0026#34;: 0}, {\u0026#34;id\u0026#34;: 3, \u0026#34;name\u0026#34;: \u0026#34;小米 Mix3\u0026#34;, \u0026#34;quantity\u0026#34;: 50} ] }, computed: { totalQuantity() { return this.products.reduce((sum, product) =\u0026gt; { return sum + product.quantity }, 0); } } }); \u0026lt;/script\u0026gt; 用户输入。\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;库存信息\u0026lt;/h1\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;product in products\u0026#34;\u0026gt; {{ product.name }} - \u0026lt;input type=\u0026#34;number\u0026#34; v-model.number=\u0026#34;product.quantity\u0026#34; min=\u0026#34;0\u0026#34;\u0026gt; \u0026lt;span v-if=\u0026#34;product.quantity === 0\u0026#34;\u0026gt; 已经售罄 \u0026lt;/span\u0026gt; \u0026lt;button @click=\u0026#34;product.quantity += 1\u0026#34;\u0026gt; 增加库存 \u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;h2\u0026gt;库存总量：{{ totalQuantity }}台\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { products: [ {\u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;iPhone X\u0026#34;, \u0026#34;quantity\u0026#34;: 20}, {\u0026#34;id\u0026#34;: 2, \u0026#34;name\u0026#34;: \u0026#34;华为 Mate20\u0026#34;, \u0026#34;quantity\u0026#34;: 0}, {\u0026#34;id\u0026#34;: 3, \u0026#34;name\u0026#34;: \u0026#34;小米 Mix3\u0026#34;, \u0026#34;quantity\u0026#34;: 50} ] }, computed: { totalQuantity() { return this.products.reduce((sum, product) =\u0026gt; { return sum + product.quantity }, 0); } } }); \u0026lt;/script\u0026gt; 通过网络加载JSON数据。\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;库存信息\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;product in products\u0026#34;\u0026gt; {{ product.name }} - {{ product.quantity }} \u0026lt;span v-if=\u0026#34;product.quantity === 0\u0026#34;\u0026gt; 已经售罄 \u0026lt;/span\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { products: [] }， created() { fetch(\u0026#39;https://jackfrued.top/api/products\u0026#39;) .then(response =\u0026gt; response.json()) .then(json =\u0026gt; { this.products = json }); } }); \u0026lt;/script\u0026gt;  使用脚手架 - vue-cli Vue为商业项目开发提供了非常便捷的脚手架工具vue-cli，通过工具可以省去手工配置开发环境、测试环境和运行环境的步骤，让开发者只需要关注要解决的问题。\n 安装脚手架。 创建项目。 安装依赖包。 运行项目。  UI框架 - Element 基于Vue 2.0的桌面端组件库，用于构造用户界面，支持响应式布局。\n 引入Element的CSS和JavaScript文件。\n\u0026lt;!-- 引入样式 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://unpkg.com/element-ui/lib/theme-chalk/index.css\u0026#34;\u0026gt; \u0026lt;!-- 引入组件库 --\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/element-ui/lib/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 一个简单的例子。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://unpkg.com/element-ui/lib/theme-chalk/index.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;el-button @click=\u0026#34;visible = true\u0026#34;\u0026gt;点我\u0026lt;/el-button\u0026gt; \u0026lt;el-dialog :visible.sync=\u0026#34;visible\u0026#34; title=\u0026#34;Hello world\u0026#34;\u0026gt; \u0026lt;p\u0026gt;开始使用Element吧\u0026lt;/p\u0026gt; \u0026lt;/el-dialog\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/vue/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/element-ui/lib/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#39;#app\u0026#39;, data: { visible: false, } }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 使用组件。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://unpkg.com/element-ui/lib/theme-chalk/index.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;el-table :data=\u0026#34;tableData\u0026#34; stripe style=\u0026#34;width: 100%\u0026#34;\u0026gt; \u0026lt;el-table-column prop=\u0026#34;date\u0026#34; label=\u0026#34;日期\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;name\u0026#34; label=\u0026#34;姓名\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;address\u0026#34; label=\u0026#34;地址\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/vue/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/element-ui/lib/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#39;#app\u0026#39;, data: { tableData: [ { date: \u0026#39;2016-05-02\u0026#39;, name: \u0026#39;王一霸\u0026#39;, address: \u0026#39;上海市普陀区金沙江路 1518 弄\u0026#39; }, { date: \u0026#39;2016-05-04\u0026#39;, name: \u0026#39;刘二狗\u0026#39;, address: \u0026#39;上海市普陀区金沙江路 1517 弄\u0026#39; }, { date: \u0026#39;2016-05-01\u0026#39;, name: \u0026#39;杨三萌\u0026#39;, address: \u0026#39;上海市普陀区金沙江路 1519 弄\u0026#39; }, { date: \u0026#39;2016-05-03\u0026#39;, name: \u0026#39;陈四吹\u0026#39;, address: \u0026#39;上海市普陀区金沙江路 1516 弄\u0026#39; } ] } }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt;  报表框架 - ECharts 百度出品的开源可视化库，常用于生成各种类型的报表。\n基于弹性盒子的CSS框架 - Bulma Bulma是一个基于Flexbox的现代化的CSS框架，其初衷就是移动优先（Mobile First），模块化设计，可以轻松用来实现各种简单或者复杂的内容布局，即使不懂CSS的开发者也能够使用它定制出漂亮的页面。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Bulma\u0026lt;/title\u0026gt; \u0026lt;link href=\u0026#34;https://cdn.bootcss.com/bulma/0.7.4/css/bulma.min.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; div { margin-top: 10px; } .column { color: #fff; background-color: #063; margin: 10px 10px; text-align: center; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;columns\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;column\u0026#34;\u0026gt;1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;column\u0026#34;\u0026gt;2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;column\u0026#34;\u0026gt;3\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;column\u0026#34;\u0026gt;4\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;a class=\u0026#34;button is-primary\u0026#34;\u0026gt;Primary\u0026lt;/a\u0026gt; \u0026lt;a class=\u0026#34;button is-link\u0026#34;\u0026gt;Link\u0026lt;/a\u0026gt; \u0026lt;a class=\u0026#34;button is-info\u0026#34;\u0026gt;Info\u0026lt;/a\u0026gt; \u0026lt;a class=\u0026#34;button is-success\u0026#34;\u0026gt;Success\u0026lt;/a\u0026gt; \u0026lt;a class=\u0026#34;button is-warning\u0026#34;\u0026gt;Warning\u0026lt;/a\u0026gt; \u0026lt;a class=\u0026#34;button is-danger\u0026#34;\u0026gt;Danger\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;progress class=\u0026#34;progress is-danger is-medium\u0026#34; max=\u0026#34;100\u0026#34;\u0026gt;60%\u0026lt;/progress\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;table class=\u0026#34;table is-hoverable\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;One\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Two\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Three\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Four\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Five\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Six\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Seven\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Eight\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Nine\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Ten\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Eleven\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Twelve\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 响应式布局框架 - Bootstrap 用于快速开发Web应用程序的前端框架，支持响应式布局。\n 特点\n 支持主流的浏览器和移动设备 容易上手 响应式设计  内容\n 网格系统 封装的CSS 现成的组件 JavaScript插件  可视化\n  "},{"idx":28,"href":"/python100days/docs/Day31-35/31-35-%E7%8E%A9%E8%BD%ACLinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","title":"31 35 玩转 Linux操作系统","content":" 玩转Linux操作系统  说明：本文中对Linux命令的讲解都是基于名为CentOS的Linux发行版本，我自己使用的是阿里云服务器，系统版本为CentOS Linux release 7.6.1810。不同的Linux发行版本在Shell命令和工具程序上会有一些差别，但是这些差别是很小的。\n 操作系统发展史 只有硬件没有软件的计算机系统被称之为“裸机”，我们很难用“裸机”来完成计算机日常的工作（如存储和运算），所以必须用特定的软件来控制硬件的工作。最靠近计算机硬件的软件是系统软件，其中最为重要的就是“操作系统”。“操作系统”是控制和管理整个计算机硬件和软件资源、实现资源分配和任务调配、为系统用户以及其他软件提供接口和环境的程序的集合。\n没有操作系统（手工操作） 在计算机诞生之初没有操作系统的年代，人们先把程序纸带（或卡片）装上计算机，然后启动输入机把程序送入计算机，接着通过控制台开关启动程序运行。当程序执行完毕，打印机输出计算的结果，用户卸下并取走纸带（或卡片）。第二个用户上机，重复同样的步骤。在整个过程中用户独占机器，CPU等待手工操作，资源利用率极低。\n批处理系统 首先启动计算机上的一个监督程序，在监督程序的控制下，计算机能够自动的、成批的处理一个或多个用户的作业。完成一批作业后，监督程度又从输入机读取作业存入磁带机。按照上面的步骤重复处理任务。监督程序不停的处理各个作业，实现了作业的自动转接，减少了作业的建立时间和手工操作时间，提高了计算机资源的利用率。 批处理系统又可以分为单道批处理系统、多道批处理系统、联机批处理系统、脱机批处理系统。\n分时系统和实时系统 分时系统是把处理器的运行时间分成很短的时间片，按时间片轮流把处理机分配给各联机作业使用。 若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时中断，把处理机让给另一作业使用，等待下一轮调度时再继续其运行。由于计算机速度很快，作业运行轮转得很快，给每个用户的感觉是他独占了一台计算机。而每个用户可以通过自己的终端向系统发出各种操作控制命令，在充分的人机交互情况下，完成作业的运行。为了解决分时系统不能及时响应用户指令的情况，又出现了能够在在严格的时间范围内完成事件处理，及时响应随机外部事件的实时系统。\n通用操作系统  1960s：IBM的System/360系列的机器有了统一的操作系统OS/360。\n 1965年：AT\u0026amp;T的贝尔实验室加入GE和MIT的合作计划开始开发MULTICS。\n 1969年：MULTICS项目失败，Ken Tompson赋闲在家，为了玩“Space Travel”游戏用汇编语言在当时已经被淘汰的PDP-7上开发了Unics。\n   注：很难想象，Unix这么伟大的系统，居然是一个赋闲在家的程序员（关键是老婆回娘家还带上了孩子）在一台被淘汰的设备上为了玩游戏开发出来的。\n  1970年~1971年：Ken Tompson和Dennis Ritchie用B语言在PDP-11上重写了Unics，并在Brian Kernighan的建议下将其更名为Unix。   1972年~1973年：Dennis Ritchie发明了C语言来取代可移植性较差的B语言，并开启了用C语言重写Unix的工作。\n 1974年：Unix推出了里程碑意义的第5版，几乎完全用C语言来实现。\n 1979年：从Unix第7版开始，AT\u0026amp;T发布新的使用条款，将Unix私有化。\n 1987年：Andrew S. Tanenbaum教授为了能在课堂上为学生讲解操作系统运作的细节，决定在不使用任何AT\u0026amp;T的源代码前提下，自行开发与Unix兼容的操作系统以避免版权上的争议，该系统被命名为Minix。\n   1991年：Linus Torvalds就读于芬兰赫尔辛基大学期间，尝试在Minix上做一些开发工作，但因为Minix只是作为教学用途的操作系统，功能并不强大，为了方便在学校的新闻组和邮件系统中读写和下载文件，Linus编写了磁盘驱动程序和文件系统，这些东西形成了Linux系统内核的雏形。  下图是Unix操作系统家族的图谱。\nLinux概述 Linux是一个通用操作系统。一个操作系统要负责任务调度、内存分配、处理外围设备I/O等操作。操作系统通常由内核（运行其他程序，管理像磁盘、打印机等硬件设备的核心程序）和系统程序（设备驱动、底层库、shell、服务程序等）两部分组成。\nLinux内核是芬兰人Linus Torvalds开发的，于1991年9月发布。而Linux操作系统作为Internet时代的产物，它是由全世界许多开发者共同合作开发的，是一个自由的操作系统（注意自由和免费并不是同一个概念，想了解二者的差别可以点击这里）。\nLinux系统优点  通用操作系统，不跟特定的硬件绑定。 用C语言编写，可移植性强，有内核编程接口。 支持多用户和多任务，支持安全的分层文件系统。 大量的实用程序，完善的网络功能以及强大的支持文档。 可靠的安全性和良好的稳定性，对开发者更友好。  Linux系统发行版本  Redhat Ubuntu CentOS Fedora Debian openSUSE  基础命令 Linux系统的命令通常都是如下所示的格式：\n命令名称 [命名参数] [命令对象]  获取登录信息 - w / who / last/ lastb。\n[root ~]# w 23:31:16 up 12:16, 2 users, load average: 0.00, 0.01, 0.05 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT root pts/0 182.139.66.250 23:03 4.00s 0.02s 0.00s w jackfrue pts/1 182.139.66.250 23:26 3:56 0.00s 0.00s -bash [root ~]# who root pts/0 2018-04-12 23:03 (182.139.66.250) jackfrued pts/1 2018-04-12 23:26 (182.139.66.250) [root ~]# who am i root pts/0 2018-04-12 23:03 (182.139.66.250) [root ~]# who mom likes root pts/0 2018-04-12 23:03 (182.139.66.250) [root ~]# last root pts/0 117.136.63.184 Sun May 26 18:57 still logged in reboot system boot 3.10.0-957.10.1. Mon May 27 02:52 - 19:10 (-7:-42) root pts/4 117.136.63.184 Sun May 26 18:51 - crash (08:01) root pts/4 117.136.63.184 Sun May 26 18:49 - 18:49 (00:00) root pts/3 117.136.63.183 Sun May 26 18:35 - crash (08:17) root pts/2 117.136.63.183 Sun May 26 18:34 - crash (08:17) root pts/0 117.136.63.183 Sun May 26 18:10 - crash (08:42)  查看自己使用的Shell - ps。\n  Shell也被称为“壳”或“壳程序”，它是用户与操作系统内核交流的翻译官，简单的说就是人与计算机交互的界面和接口。目前很多Linux系统默认的Shell都是bash（Bourne Again SHell），因为它可以使用tab键进行命令和路径补全、可以保存历史命令、可以方便的配置环境变量以及执行批处理操作。\n[root@izwz97tbgo9lkabnat2lo8z ~]# ps PID TTY TIME CMD 3531 pts/0 00:00:00 bash 3553 pts/0 00:00:00 ps  查看命令的说明和位置 - whatis / which / whereis。\n[root ~]# whatis ps ps (1) - report a snapshot of the current processes. [root ~]# whatis python python (1) - an interpreted, interactive, object-oriented programming language [root ~]# whereis ps ps: /usr/bin/ps /usr/share/man/man1/ps.1.gz [root ~]# whereis python python: /usr/bin/python /usr/bin/python2.7 /usr/lib/python2.7 /usr/lib64/python2.7 /etc/python /usr/include/python2.7 /usr/share/man/man1/python.1.gz [root ~]# which ps /usr/bin/ps [root ~]# which python /usr/bin/python 清除屏幕上显示的内容 - clear。\n 查看帮助文档 - man / info / help / apropos。\n[root@izwz97tbgo9lkabnat2lo8z ~]# ps --help Usage: ps [options] Try \u0026#39;ps --help \u0026lt;simple|list|output|threads|misc|all\u0026gt;\u0026#39; or \u0026#39;ps --help \u0026lt;s|l|o|t|m|a\u0026gt;\u0026#39; for additional help text. For more details see ps(1). [root@izwz97tbgo9lkabnat2lo8z ~]# man ps PS(1) User Commands PS(1) NAME ps - report a snapshot of the current processes. SYNOPSIS ps [options] DESCRIPTION ... 查看系统和主机名 - uname / hostname。\n[root@izwz97tbgo9lkabnat2lo8z ~]# uname Linux [root@izwz97tbgo9lkabnat2lo8z ~]# hostname izwz97tbgo9lkabnat2lo8z [root@iZwz97tbgo9lkabnat2lo8Z ~]# cat /etc/centos-release CentOS Linux release 7.6.1810 (Core)   说明：cat是连接文件内容并打印到标准输出的命令，后面会讲到该命令；/etc是Linux系统上的一个非常重要的目录，它保存了很多的配置文件；centos-release是该目录下的一个文件，因为我自己使用的Linux发行版本是CentOS 7.6，因此这里会有一个这样的文件。\n  时间和日期 - date / cal。\n[root@iZwz97tbgo9lkabnat2lo8Z ~]# date Wed Jun 20 12:53:19 CST 2018 [root@iZwz97tbgo9lkabnat2lo8Z ~]# cal June 2018 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 [root@iZwz97tbgo9lkabnat2lo8Z ~]# cal 5 2017 May 2017 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 重启和关机 - reboot / shutdown。\n[root ~]# shutdown -h +5 Shutdown scheduled for Sun 2019-05-26 19:34:27 CST, use \u0026#39;shutdown -c\u0026#39; to cancel. [root ~]# Broadcast message from root (Sun 2019-05-26 19:29:27 CST): The system is going down for power-off at Sun 2019-05-26 19:34:27 CST! [root ~]# shutdown -c Broadcast message from root (Sun 2019-05-26 19:30:22 CST): The system shutdown has been cancelled at Sun 2019-05-26 19:31:22 CST! [root ~]# shutdown -r 23:58 Shutdown scheduled for Sun 2019-05-26 23:58:00 CST, use \u0026#39;shutdown -c\u0026#39; to cancel. [root ~]# shutdown -c Broadcast message from root (Sun 2019-05-26 19:31:06 CST): The system shutdown has been cancelled at Sun 2019-05-26 19:32:06 CST!   说明：在执行shutdown命令时会向登录系统的用户发出警告，可以在命令后面跟上警告消息来替换默认的警告消息，也可以在-h参数后通过now来表示立刻关机。\n  退出登录 - exit / logout。\n 查看历史命令 - history。\n[root@iZwz97tbgo9lkabnat2lo8Z ~]# history ... 452 ls 453 cd Python-3.6.5/ 454 clear 455 history [root@iZwz97tbgo9lkabnat2lo8Z ~]# !454   说明：查看到历史命令之后，可以用!历史命令编号来重新执行该命令；通过history -c可以清除历史命令。\n 实用程序 文件和文件夹操作  创建/删除空目录 - mkdir / rmdir。\n[root ~]# mkdir abc [root ~]# mkdir -p xyz/abc [root ~]# rmdir abc 创建/删除文件 - touch / rm。\n[root ~]# touch readme.txt [root ~]# touch error.txt [root ~]# rm error.txt rm: remove regular empty file ‘error.txt’? y [root ~]# rm -rf xyz  touch命令用于创建空白文件或修改文件时间。在Linux系统中一个文件有三种时间：  更改内容的时间 - mtime。 更改权限的时间 - ctime。 最后访问时间 - atime。  rm的几个重要参数：  -i：交互式删除，每个删除项都会进行询问。 -r：删除目录并递归的删除目录中的文件和目录。 -f：强制删除，忽略不存在的文件，没有任何提示。   切换和查看当前工作目录 - cd / pwd。\n   说明：cd命令后面可以跟相对路径（以当前路径作为参照）或绝对路径（以/开头）来切换到指定的目录，也可以用cd ..来返回上一级目录。请大家想一想，如果要返回到上上一级目录应该给cd命令加上什么样的参数呢？\n  查看目录内容 - ls。\n -l：以长格式查看文件和目录。 -a：显示以点开头的文件和目录（隐藏文件）。 -R：遇到目录要进行递归展开（继续列出目录下面的文件和目录）。 -d：只列出目录，不列出其他内容。 -S / -t：按大小/时间排序。  查看文件内容 - cat / tac / head / tail / more / less / rev / od。\n[root ~]# wget http://www.sohu.com/ -O sohu.html --2018-06-20 18:42:34-- http://www.sohu.com/ Resolving www.sohu.com (www.sohu.com)... 14.18.240.6 Connecting to www.sohu.com (www.sohu.com)|14.18.240.6|:80... connected. HTTP request sent, awaiting response... 200 OK Length: 212527 (208K) [text/html] Saving to: ‘sohu.html’ 100%[==================================================\u0026gt;] 212,527 --.-K/s in 0.03s 2018-06-20 18:42:34 (7.48 MB/s) - ‘sohu.html’ saved [212527/212527] [root ~]# cat sohu.html ... [root ~]# head -10 sohu.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;搜狐\u0026lt;/title\u0026gt; \u0026lt;meta name=\u0026#34;Keywords\u0026#34; content=\u0026#34;搜狐,门户网站,新媒体,网络媒体,新闻,财经,体育,娱乐,时尚,汽车,房产,科技,图片,论坛,微博,博客,视频,电影,电视剧\u0026#34;/\u0026gt; \u0026lt;meta name=\u0026#34;Description\u0026#34; content=\u0026#34;搜狐网为用户提供24小时不间断的最新资讯，及搜索、邮件等网络服务。内容包括全球热点事件、突发新闻、时事评论、热播影视剧、体育赛事、行业动态、生活服务信息，以及论坛、博客、微博、我的搜狐等互动空间。\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;shenma-site-verification\u0026#34; content=\u0026#34;1237e4d02a3d8d73e96cbd97b699e9c3_1504254750\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;/\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=Edge,chrome=1\u0026#34;/\u0026gt; [root ~]# tail -2 sohu.html \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; [root ~]# less sohu.html ... [root ~]# cat -n sohu.html | more ...   说明：上面用到了一个名为wget的命令，它是一个网络下载器程序，可以从指定的URL下载资源。\n  拷贝/移动文件 - cp / mv。\n[root ~]# mkdir backup [root ~]# cp sohu.html backup/ [root ~]# cd backup [root backup]# ls sohu.html [root backup]# mv sohu.html sohu_index.html [root backup]# ls sohu_index.html 文件重命名 - rename。\n[root@iZwz97tbgo9lkabnat2lo8Z ~]# rename .htm .html *.htm 查找文件和查找内容 - find / grep。\n[root@iZwz97tbgo9lkabnat2lo8Z ~]# find / -name \u0026#34;*.html\u0026#34; /root/sohu.html /root/backup/sohu_index.html [root@izwz97tbgo9lkabnat2lo8z ~]# find . -atime 7 -type f -print [root@izwz97tbgo9lkabnat2lo8z ~]# find . -type f -size +2k [root@izwz97tbgo9lkabnat2lo8z ~]# find . -type f -name \u0026#34;*.swp\u0026#34; -delete [root@iZwz97tbgo9lkabnat2lo8Z ~]# grep \u0026#34;\u0026lt;script\u0026gt;\u0026#34; sohu.html -n 20:\u0026lt;script\u0026gt; [root@iZwz97tbgo9lkabnat2lo8Z ~]# grep -E \\\u0026lt;\\/?script.*\\\u0026gt; sohu.html -n 20:\u0026lt;script\u0026gt; 22:\u0026lt;/script\u0026gt; 24:\u0026lt;script src=\u0026#34;//statics.itc.cn/web/v3/static/js/es5-shim-08e41cfc3e.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 25:\u0026lt;script src=\u0026#34;//statics.itc.cn/web/v3/static/js/es5-sham-1d5fa1124b.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 26:\u0026lt;script src=\u0026#34;//statics.itc.cn/web/v3/static/js/html5shiv-21fc8c2ba6.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 29:\u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; 52:\u0026lt;/script\u0026gt; ...   说明：grep在搜索字符串时可以使用正则表达式，如果需要使用正则表达式可以用grep -E或者直接使用egrep。\n  创建链接和查看链接 - ln / readlink。\n[root@iZwz97tbgo9lkabnat2lo8Z ~]# ls -l sohu.html -rw-r--r-- 1 root root 212131 Jun 20 19:15 sohu.html [root@iZwz97tbgo9lkabnat2lo8Z ~]# ln /root/sohu.html /root/backup/sohu_backup [root@iZwz97tbgo9lkabnat2lo8Z ~]# ls -l sohu.html -rw-r--r-- 2 root root 212131 Jun 20 19:15 sohu.html [root@iZwz97tbgo9lkabnat2lo8Z ~]# ln /root/sohu.html /root/backup/sohu_backup2 [root@iZwz97tbgo9lkabnat2lo8Z ~]# ls -l sohu.html -rw-r--r-- 3 root root 212131 Jun 20 19:15 sohu.html [root@iZwz97tbgo9lkabnat2lo8Z ~]# ln -s /etc/centos-release sysinfo [root@iZwz97tbgo9lkabnat2lo8Z ~]# ls -l sysinfo lrwxrwxrwx 1 root root 19 Jun 20 19:21 sysinfo -\u0026gt; /etc/centos-release [root@iZwz97tbgo9lkabnat2lo8Z ~]# cat sysinfo CentOS Linux release 7.4.1708 (Core) [root@iZwz97tbgo9lkabnat2lo8Z ~]# cat /etc/centos-release CentOS Linux release 7.4.1708 (Core)   说明：链接可以分为硬链接和软链接（符号链接）。硬链接可以认为是一个指向文件数据的指针，就像Python中对象的引用计数，每添加一个硬链接，文件的对应链接数就增加1，只有当文件的链接数为0时，文件所对应的存储空间才有可能被其他文件覆盖。我们平常删除文件时其实并没有删除硬盘上的数据，我们删除的只是一个指针，或者说是数据的一条使用记录，所以类似于“文件粉碎机”之类的软件在“粉碎”文件时除了删除文件指针，还会在文件对应的存储区域填入数据来保证文件无法再恢复。软链接类似于Windows系统下的快捷方式，当软链接链接的文件被删除时，软链接也就失效了。\n  压缩/解压缩和归档/解归档 - gzip / gunzip / xz。\n[root@iZwz97tbgo9lkabnat2lo8Z ~]# wget http://download.redis.io/releases/redis-4.0.10.tar.gz --2018-06-20 19:29:59-- http://download.redis.io/releases/redis-4.0.10.tar.gz Resolving download.redis.io (download.redis.io)... 109.74.203.151 Connecting to download.redis.io (download.redis.io)|109.74.203.151|:80... connected. HTTP request sent, awaiting response... 200 OK Length: 1738465 (1.7M) [application/x-gzip] Saving to: ‘redis-4.0.10.tar.gz’ 100%[==================================================\u0026gt;] 1,738,465 70.1KB/s in 74s 2018-06-20 19:31:14 (22.9 KB/s) - ‘redis-4.0.10.tar.gz’ saved [1738465/1738465] [root@iZwz97tbgo9lkabnat2lo8Z ~]# ls redis* redis-4.0.10.tar.gz [root@iZwz97tbgo9lkabnat2lo8Z ~]# gunzip redis-4.0.10.tar.gz [root@iZwz97tbgo9lkabnat2lo8Z ~]# ls redis* redis-4.0.10.tar 归档和解归档 - tar。\n[root@iZwz97tbgo9lkabnat2lo8Z ~]# tar -xvf redis-4.0.10.tar redis-4.0.10/ redis-4.0.10/.gitignore redis-4.0.10/00-RELEASENOTES redis-4.0.10/BUGS redis-4.0.10/CONTRIBUTING redis-4.0.10/COPYING redis-4.0.10/INSTALL redis-4.0.10/MANIFESTO redis-4.0.10/Makefile redis-4.0.10/README.md redis-4.0.10/deps/ redis-4.0.10/deps/Makefile redis-4.0.10/deps/README.md ...   说明：归档（也称为创建归档）和解归档都使用tar命令，通常创建归档需要-cvf三个参数，其中c表示创建（create），v表示显示创建归档详情（verbose），f表示指定归档的文件（file）；解归档需要加上-xvf参数，其中x表示抽取（extract），其他两个参数跟创建归档相同。\n  将标准输入转成命令行参数 - xargs。  下面的命令会将查找当前路径下的html文件，然后通过xargs将这些文件作为参数传给rm命令，实现查找并删除文件的操作。\n[root@iZwz97tbgo9lkabnat2lo8Z ~]# find . -type f -name \u0026#34;*.html\u0026#34; | xargs rm -f 下面的命令将a.txt文件中的多行内容变成一行输出到b.txt文件中，其中\u0026lt;表示从a.txt中读取输入，\u0026gt;表示将命令的执行结果输出到b.txt中。\n[root@iZwz97tbgo9lkabnat2lo8Z ~]# xargs \u0026lt; a.txt \u0026gt; b.txt  说明：这个命令就像上面演示的那样常在管道（实现进程间通信的一种方式）和重定向（重新指定输入输出的位置）操作中用到，后面的内容中会讲到管道操作和输入输出重定向操作。\n  显示文件或目录 - basename / dirname。\n 其他相关工具。\n sort - 对内容排序 uniq - 去掉相邻重复内容 tr - 替换指定内容为新内容 cut / paste - 剪切/黏贴内容 split - 拆分文件 file - 判断文件类型 wc - 统计文件行数、单词数、字节数 iconv - 编码转换\n[root ~]# cat foo.txt grape apple pitaya [root ~]# cat bar.txt 100 200 300 400 [root ~]# paste foo.txt bar.txt grape 100 apple 200 pitaya 300 400 [root ~]# paste foo.txt bar.txt \u0026gt; hello.txt [root ~]# cut -b 4-8 hello.txt pe 10 le 20 aya 3 0 [root ~]# cat hello.txt | tr \u0026#39;\\t\u0026#39; \u0026#39;,\u0026#39; grape,100 apple,200 pitaya,300 ,400 [root ~]# split -l 100 sohu.html hello [root ~]# wget https://www.baidu.com/img/bd_logo1.png [root ~]# file bd_logo1.png bd_logo1.png: PNG image data, 540 x 258, 8-bit colormap, non-interlaced [root ~]# wc sohu.html 2979 6355 212527 sohu.html [root ~]# wc -l sohu.html 2979 sohu.html [root ~]# wget http://www.qq.com -O qq.html [root ~]# iconv -f gb2312 -t utf-8 qq.html   管道和重定向  管道的使用 - |。  例子：查找当前目录下文件个数。\n[root ~]# find ./ | wc -l 6152 例子：列出当前路径下的文件和文件夹，给每一项加一个编号。\n[root ~]# ls | cat -n 1 dump.rdb 2 mongodb-3.6.5 3 Python-3.6.5 4 redis-3.2.11 5 redis.conf 例子：查找record.log中包含AAA，但不包含BBB的记录的总数\n[root ~]# cat record.log | grep AAA | grep -v BBB | wc -l  输出重定向和错误重定向 - \u0026gt; / \u0026gt;\u0026gt; / 2\u0026gt;。\n[root ~]# cat readme.txt banana apple grape apple grape watermelon pear pitaya [root ~]# cat readme.txt | sort | uniq \u0026gt; result.txt [root ~]# cat result.txt apple banana grape pear pitaya watermelon 输入重定向 - \u0026lt;。\n[root ~]# echo \u0026#39;hello, world!\u0026#39; \u0026gt; hello.txt [root ~]# wall \u0026lt; hello.txt [root ~]# Broadcast message from root (Wed Jun 20 19:43:05 2018): hello, world! [root ~]# echo \u0026#39;I will show you some code.\u0026#39; \u0026gt;\u0026gt; hello.txt [root ~]# wall \u0026lt; hello.txt [root ~]# Broadcast message from root (Wed Jun 20 19:43:55 2018): hello, world! I will show you some code. 多重定向 - tee。\n  下面的命令除了在终端显示命令ls的结果之外，还会追加输出到ls.txt文件中。\n[root ~]# ls | tee -a ls.txt 别名  alias\n[root ~]# alias ll=\u0026#39;ls -l\u0026#39; [root ~]# alias frm=\u0026#39;rm -rf\u0026#39; [root ~]# ll ... drwxr-xr-x 2 root root 4096 Jun 20 12:52 abc ... [root ~]# frm abc unalias\n[root ~]# unalias frm [root ~]# frm sohu.html -bash: frm: command not found  文本处理  字符流编辑器 - sed。  sed是操作、过滤和转换文本内容的工具。假设有一个名为fruit.txt的文件，内容如下所示。\n[root ~]# cat -n fruit.txt 1 banana 2 grape 3 apple 4 watermelon 5 orange 接下来，我们在第2行后面添加一个pitaya。\n[root ~]# sed \u0026#39;2a pitaya\u0026#39; fruit.txt banana grape pitaya apple watermelon orange  注意：刚才的命令和之前我们讲过的很多命令一样并没有改变fruit.txt文件，而是将添加了新行的内容输出到终端中，如果想保存到fruit.txt中，可以使用输出重定向操作。\n 在第2行前面插入一个waxberry。\n[root ~]# sed \u0026#39;2i waxberry\u0026#39; fruit.txt banana waxberry grape apple watermelon orange 删除第3行。\n[root ~]# sed \u0026#39;3d\u0026#39; fruit.txt banana grape watermelon orange 删除第2行到第4行。\n[root ~]# sed \u0026#39;2,4d\u0026#39; fruit.txt banana orange 将文本中的字符a替换为@。\n[root ~]# sed \u0026#39;s#a#@#\u0026#39; fruit.txt b@nana gr@pe @pple w@termelon or@nge 将文本中的字符a替换为@，使用全局模式。\n[root ~]# sed \u0026#39;s#a#@#g\u0026#39; fruit.txt b@n@n@ gr@pe @pple w@termelon or@nge  模式匹配和处理语言 - awk。  awk是一种编程语言，也是Linux系统中处理文本最为强大的工具，它的作者之一和现在的维护者就是之前提到过的Brian Kernighan（ken和dmr最亲密的伙伴）。通过该命令可以从文本中提取出指定的列、用正则表达式从文本中取出我们想要的内容、显示指定的行以及进行统计和运算，总之它非常强大。\n假设有一个名为fruit2.txt的文件，内容如下所示。\n[root ~]# cat fruit2.txt 1 banana 120 2 grape 500 3 apple 1230 4 watermelon 80 5 orange 400 显示文件的第3行。\n[root ~]# awk \u0026#39;NR==3\u0026#39; fruit2.txt 3 apple 1230 显示文件的第2列。\n[root ~]# awk \u0026#39;{print $2}\u0026#39; fruit2.txt banana grape apple watermelon orange 显示文件的最后一列。\n[root ~]# awk \u0026#39;{print $NF}\u0026#39; fruit2.txt 120 500 1230 80 400 输出末尾数字大于等于300的行。\n[root ~]# awk \u0026#39;{if($3 \u0026gt;= 300) {print $0}}\u0026#39; fruit2.txt 2 grape 500 3 apple 1230 5 orange 400 上面展示的只是awk命令的冰山一角，更多的内容留给读者自己在实践中去探索。\n用户管理  创建和删除用户 - useradd / userdel。\n[root home]# useradd hellokitty [root home]# userdel hellokitty  -d - 创建用户时为用户指定用户主目录 -g - 创建用户时指定用户所属的用户组  创建和删除用户组 - groupadd / groupdel。\n   说明：用户组主要是为了方便对一个组里面所有用户的管理。\n  修改密码 - passwd。\n[root ~]# passwd hellokitty New password: Retype new password: passwd: all authentication tokens updated successfully.   说明：输入密码和确认密码没有回显且必须一气呵成的输入完成（不能使用退格键），密码和确认密码需要一致。如果使用passwd命令时没有指定命令作用的对象，则表示要修改当前用户的密码。如果想批量修改用户密码，可以使用chpasswd命令。\n  -l / -u - 锁定/解锁用户。 -d - 清除用户密码。 -e - 设置密码立即过期，用户登录时会强制要求修改密码。 -i - 设置密码过期多少天以后禁用该用户。   查看和修改密码有效期 - chage。  设置hellokitty用户100天后必须修改密码，过期前15天通知该用户，过期后15天禁用该用户。\nchage -M 100 -W 15 -I 15 hellokitty  切换用户 - su。\n[root ~]# su hellokitty [hellokitty root]$ 以管理员身份执行命令 - sudo。\n[hellokitty ~]$ ls /root ls: cannot open directory /root: Permission denied [hellokitty ~]$ sudo ls /root [sudo] password for hellokitty:   说明：如果希望用户能够以管理员身份执行命令，用户必须要出现在sudoers名单中，sudoers文件在 /etc目录下，如果希望直接编辑该文件也可以使用下面的命令。\n  编辑sudoers文件 - visudo。  这里使用的编辑器是vi，关于vi的知识在后面有讲解。该文件的部分内容如下所示：\n # Allow root to run any commands anywhere root ALL=(ALL) ALL # Allows members of the 'sys' group to run networking, software, # service management apps and more. # %sys ALL = NETWORKING, SOFTWARE, SERVICES, STORAGE, DELEGATING, PROCESSES, LOCATE, DRIVERS # Allows people in group wheel to run all commands %wheel ALL=(ALL) ALL # Same thing without a password # %wheel ALL=(ALL) NOPASSWD: ALL # Allows members of the users group to mount and unmount the # cdrom as root # %users ALL=/sbin/mount /mnt/cdrom, /sbin/umount /mnt/cdrom # Allows members of the users group to shutdown this system # %users localhost=/sbin/shutdown -h now   显示用户与用户组的信息 - id。\n 给其他用户发消息 -write / wall。\n  发送方：\n[root ~]# write hellokitty Dinner is on me. Call me at 6pm. 接收方：\n[hellokitty ~]$ Message from root on pts/0 at 17:41 ... Dinner is on me. Call me at 6pm. EOF  查看/设置是否接收其他用户发送的消息 - mesg。\n[hellokitty ~]$ mesg is y [hellokitty ~]$ mesg n [hellokitty ~]$ mesg is n  文件系统 文件和路径  命名规则：文件名的最大长度与文件系统类型有关，一般情况下，文件名不应该超过255个字符，虽然绝大多数的字符都可以用于文件名，但是最好使用英文大小写字母、数字、下划线、点这样的符号。文件名中虽然可以使用空格，但应该尽可能避免使用空格，否则在输入文件名时需要用将文件名放在双引号中或者通过\\对空格进行转义。 扩展名：在Linux系统下文件的扩展名是可选的，但是使用扩展名有助于对文件内容的理解。有些应用程序要通过扩展名来识别文件，但是更多的应用程序并不依赖文件的扩展名，就像file命令在识别文件时并不是依据扩展名来判定文件的类型。 隐藏文件：以点开头的文件在Linux系统中是隐藏文件（不可见文件）。  目录结构  /bin - 基本命令的二进制文件。 /boot - 引导加载程序的静态文件。 /dev - 设备文件。 /etc - 配置文件。 /home - 普通用户主目录的父目录。 /lib - 共享库文件。 /lib64 - 共享64位库文件。 /lost+found - 存放未链接文件。 /media - 自动识别设备的挂载目录。 /mnt - 临时挂载文件系统的挂载点。 /opt - 可选插件软件包安装位置。 /proc - 内核和进程信息。 /root - 超级管理员用户主目录。 /run - 存放系统运行时需要的东西。 /sbin - 超级用户的二进制文件。 /sys - 设备的伪文件系统。 /tmp - 临时文件夹。 /usr - 用户应用目录。 /var - 变量数据目录。  访问权限  chmod - 改变文件模式比特。\n[root ~]# ls -l ... -rw-r--r-- 1 root root 211878 Jun 19 16:06 sohu.html ... [root ~]# chmod g+w,o+w sohu.html [root ~]# ls -l ... -rw-rw-rw- 1 root root 211878 Jun 19 16:06 sohu.html ... [root ~]# chmod 644 sohu.html [root ~]# ls -l ... -rw-r--r-- 1 root root 211878 Jun 19 16:06 sohu.html ...   说明：通过上面的例子可以看出，用chmod改变文件模式比特有两种方式：一种是字符设定法，另一种是数字设定法。除了chmod之外，可以通过umask来设定哪些权限将在新文件的默认权限中被删除。\n 长格式查看目录或文件时显示结果及其对应权限的数值如下表所示。\n chown - 改变文件所有者。\n[root ~]# ls -l ... -rw-r--r-- 1 root root 54 Jun 20 10:06 readme.txt ... [root ~]# chown hellokitty readme.txt [root ~]# ls -l ... -rw-r--r-- 1 hellokitty root 54 Jun 20 10:06 readme.txt ... chgrp - 改变用户组。\n  磁盘管理  列出文件系统的磁盘使用状况 - df。\n[root ~]# df -h Filesystem Size Used Avail Use% Mounted on /dev/vda1 40G 5.0G 33G 14% / devtmpfs 486M 0 486M 0% /dev tmpfs 497M 0 497M 0% /dev/shm tmpfs 497M 356K 496M 1% /run tmpfs 497M 0 497M 0% /sys/fs/cgroup tmpfs 100M 0 100M 0% /run/user/0 磁盘分区表操作 - fdisk。\n[root ~]# fdisk -l Disk /dev/vda: 42.9 GB, 42949672960 bytes, 83886080 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk label type: dos Disk identifier: 0x000a42f4 Device Boot Start End Blocks Id System /dev/vda1 * 2048 83884031 41940992 83 Linux Disk /dev/vdb: 21.5 GB, 21474836480 bytes, 41943040 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes 磁盘分区工具 - parted。\n 格式化文件系统 - mkfs。\n[root ~]# mkfs -t ext4 -v /dev/sdb  -t - 指定文件系统的类型。 -c - 创建文件系统时检查磁盘损坏情况。 -v - 显示详细信息。  文件系统检查 - fsck。\n 转换或拷贝文件 - dd。\n 挂载/卸载 - mount / umount。\n 创建/激活/关闭交换分区 - mkswap / swapon / swapoff。\n   说明：执行上面这些命令会带有一定的风险，如果不清楚这些命令的用法，最好不用随意使用，在使用的过程中，最好对照参考资料进行操作，并在操作前确认是否要这么做。\n 编辑器 - vim  启动vim。可以通过vi或vim命令来启动vim，启动时可以指定文件名来打开一个文件，如果没有指定文件名，也可以在保存的时候指定文件名。\n[root ~]# vim guess.py 命令模式、编辑模式和末行模式：启动vim进入的是命令模式（也称为Normal模式），在命令模式下输入英文字母i会进入编辑模式（Insert模式），屏幕下方出现-- INSERT --提示；在编辑模式下按下Esc会回到命令模式，此时如果输入英文:会进入末行模式，在末行模式下输入q!可以在不保存当前工作的情况下强行退出vim；在命令模式下输入v会进入可视模式（Visual模式），可以用光标选择一个区域再完成对应的操作。\n 保存和退出vim：在命令模式下输入: 进入末行模式，输入wq可以实现保存退出；如果想放弃编辑的内容输入q!强行退出，这一点刚才已经提到过了；在命令模式下也可以直接输入ZZ实现保存退出。如果只想保存文件不退出，那么可以在末行模式下输入w；可以在w后面输入空格再指定要保存的文件名。\n 光标操作。\n 在命令模式下可以通过h、j、k、l来控制光标向左、下、上、右的方向移动，可以在字母前输入数字来表示移动的距离，例如：10h表示向左移动10个字符。 在命令模式下可以通过Ctrl+y和Ctrl+e来实现向上、向下滚动一行文本的操作，可以通过Ctrl+f和Ctrl+b来实现向前和向后翻页的操作。 在命令模式下可以通过输入英文字母G将光标移到文件的末尾，可以通过gg将光标移到文件的开始，也可以通过在G前输入数字来将光标移动到指定的行。  文本操作。\n 删除：在命令模式下可以用dd来删除整行；可以在dd前加数字来指定删除的行数；可以用d$来实现删除从光标处删到行尾的操作，也可以通过d0来实现从光标处删到行首的操作；如果想删除一个单词，可以使用dw；如果要删除全文，可以在输入:%d（其中:用来从命令模式进入末行模式）。 复制和粘贴：在命令模式下可以用yy来复制整行；可以在yy前加数字来指定复制的行数；可以通过p将复制的内容粘贴到光标所在的地方。 撤销和恢复：在命令模式下输入u可以撤销之前的操作；通过Ctrl+r可以恢复被撤销的操作。 对内容进行排序：在命令模式下输入%!sort。  查找和替换。\n 查找操作需要输入/进入末行模式并提供正则表达式来匹配与之对应的内容，例如：/doc.*\\.，输入n来向前搜索，也可以输入N来向后搜索。 替换操作需要输入:进入末行模式并指定搜索的范围、正则表达式以及替换后的内容和匹配选项，例如：:1,$s/doc.*/hello/gice，其中：  g - global：全局匹配。 i - ignore case：忽略大小写匹配。 c - confirm：替换时需要确认。 e - error：忽略错误。   参数设定：在输入:进入末行模式后可以对vim进行设定。\n 设置Tab键的空格数：set ts=4\n 设置显示/不显示行号：set nu / set nonu\n 设置启用/关闭高亮语法：syntax on / syntax off\n 设置显示标尺（光标所在的行和列）： set ruler\n 设置启用/关闭搜索结果高亮：set hls / set nohls\n   说明：如果希望上面的这些设定在每次启动vim时都能自动生效，需要将这些设定写到用户主目录下的.vimrc文件中。\n 高级技巧\n 比较多个文件。\n[root ~]# vim -d foo.txt bar.txt   打开多个文件。\n[root ~]# vim foo.txt bar.txt hello.txt  启动vim后只有一个窗口显示的是foo.txt，可以在末行模式中输入ls查看到打开的三个文件，也可以在末行模式中输入b \u0026lt;num\u0026gt;来显示另一个文件，例如可以用:b 2将bar.txt显示出来，可以用:b 3将hello.txt显示出来。\n 拆分和切换窗口。  可以在末行模式中输入sp或vs来实现对窗口的水平或垂直拆分，这样我们就可以同时打开多个编辑窗口，通过按两次Ctrl+w就可以实现编辑窗口的切换，在一个窗口中执行退出操作只会关闭对应的窗口，其他的窗口继续保留。\n 映射快捷键：在vim下可以将一些常用操作映射为快捷键来提升工作效率。  例子1：在命令模式下输入F4执行从第一行开始删除10000行代码的操作。   :map \u0026lt;F4\u0026gt; gg10000dd。\n例子2：在编辑模式下输入__main直接补全为if __name__ == '__main__':。\n:inoremap __main if __name__ == '__main__':\n 说明：上面例子2的inoremap中的i表示映射的键在编辑模式使用， nore表示不要递归，这一点非常重要，否则如果键对应的内容中又出现键本身，就会引发递归（相当于进入了死循环）。如果希望映射的快捷键每次启动vim时都能生效，需要将映射写到用户主目录下的.vimrc文件中。\n  录制宏。\n 在命令模式下输入qa开始录制宏（其中a是寄存器的名字，也可以是其他英文字母或0-9的数字）。\n 执行你的操作（光标操作、编辑操作等），这些操作都会被录制下来。\n 如果录制的操作已经完成了，按q结束录制。\n 通过@a（a是刚才使用的寄存器的名字）播放宏，如果要多次执行宏可以在前面加数字，例如100@a表示将宏播放100次。\n 可以试一试下面的例子来体验录制宏的操作，该例子来源于Harttle Land网站，该网站上提供了很多关于vim的使用技巧，有兴趣的可以了解一下。\n     软件安装和配置 使用包管理工具  yum - Yellowdog Updater Modified。  yum search：搜索软件包，例如yum search nginx。 yum list installed：列出已经安装的软件包，例如yum list installed | grep zlib。 yum install：安装软件包，例如yum install nginx。 yum remove：删除软件包，例如yum remove nginx。 yum update：更新软件包，例如yum update可以更新所有软件包，而yum update tar只会更新tar。 yum check-update：检查有哪些可以更新的软件包。 yum info：显示软件包的相关信息，例如yum info nginx。  rpm - Redhat Package Manager。  安装软件包：rpm -ivh \u0026lt;packagename\u0026gt;.rpm。 移除软件包：rpm -e \u0026lt;packagename\u0026gt;。 查询软件包：rpm -qa，例如可以用rpm -qa | grep mysql来检查是否安装了MySQL相关的软件包。   下面以Nginx为例，演示如何使用yum安装软件。\n[root ~]# yum -y install nginx ... Installed: nginx.x86_64 1:1.12.2-2.el7 Dependency Installed: nginx-all-modules.noarch 1:1.12.2-2.el7 nginx-mod-http-geoip.x86_64 1:1.12.2-2.el7 nginx-mod-http-image-filter.x86_64 1:1.12.2-2.el7 nginx-mod-http-perl.x86_64 1:1.12.2-2.el7 nginx-mod-http-xslt-filter.x86_64 1:1.12.2-2.el7 nginx-mod-mail.x86_64 1:1.12.2-2.el7 nginx-mod-stream.x86_64 1:1.12.2-2.el7 Complete! [root ~]# yum info nginx Loaded plugins: fastestmirror Loading mirror speeds from cached hostfile Installed Packages Name : nginx Arch : x86_64 Epoch : 1 Version : 1.12.2 Release : 2.el7 Size : 1.5 M Repo : installed From repo : epel Summary : A high performance web server and reverse proxy server URL : http://nginx.org/ License : BSD Description : Nginx is a web server and a reverse proxy server for HTTP, SMTP, POP3 and : IMAP protocols, with a strong focus on high concurrency, performance and low : memory usage. [root ~]# nginx -v nginx version: nginx/1.12.2 移除Nginx。\n[root ~]# yum -y remove nginx 下面以MySQL为例，演示如何使用rpm安装软件。要安装MySQL需要先到MySQL官方网站下载对应的RPM文件，当然要选择和你使用的Linux系统对应的版本。MySQL现在是Oracle公司旗下的产品，在MySQL被收购后，MySQL的作者重新制作了一个MySQL的分支MariaDB，可以通过yum进行安装。\n[root mysql]# ls mysql-community-client-5.7.22-1.el7.x86_64.rpm mysql-community-common-5.7.22-1.el7.x86_64.rpm mysql-community-libs-5.7.22-1.el7.x86_64.rpm mysql-community-server-5.7.22-1.el7.x86_64.rpm [root mysql]# yum -y remove mariadb-libs [root mysql]# yum -y install libaio [root mysql]#rpm -ivh mysql-community-common-5.7.26-1.el7.x86_64.rpm ... [root mysql]#rpm -ivh mysql-community-libs-5.7.26-1.el7.x86_64.rpm ... [root mysql]#rpm -ivh mysql-community-client-5.7.26-1.el7.x86_64.rpm ... [root mysql]#rpm -ivh mysql-community-server-5.7.26-1.el7.x86_64.rpm ...  说明：由于MySQL和MariaDB的底层依赖库是有冲突的，所以上面我们首先用yum移除了名为mariadb-libs的依赖库并安装了名为libaio支持异步I/O操作的依赖库。关于MySQL和MariaDB之间的关系，可以阅读维基百科上关于MariaDB的介绍。\n 移除安装的MySQL。\n[root ~]# rpm -qa | grep mysql | xargs rpm -e 下载解压配置环境变量 下面以安装MongoDB为例，演示这类软件应该如何安装。\n[root ~]# wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.6.5.tgz --2018-06-21 18:32:53-- https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.6.5.tgz Resolving fastdl.mongodb.org (fastdl.mongodb.org)... 52.85.83.16, 52.85.83.228, 52.85.83.186, ... Connecting to fastdl.mongodb.org (fastdl.mongodb.org)|52.85.83.16|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 100564462 (96M) [application/x-gzip] Saving to: ‘mongodb-linux-x86_64-rhel70-3.6.5.tgz’ 100%[==================================================\u0026gt;] 100,564,462 630KB/s in 2m 9s 2018-06-21 18:35:04 (760 KB/s) - ‘mongodb-linux-x86_64-rhel70-3.6.5.tgz’ saved [100564462/100564462] [root ~]# gunzip mongodb-linux-x86_64-rhel70-3.6.5.tgz [root ~]# tar -xvf mongodb-linux-x86_64-rhel70-3.6.5.tar mongodb-linux-x86_64-rhel70-3.6.5/README mongodb-linux-x86_64-rhel70-3.6.5/THIRD-PARTY-NOTICES mongodb-linux-x86_64-rhel70-3.6.5/MPL-2 mongodb-linux-x86_64-rhel70-3.6.5/GNU-AGPL-3.0 mongodb-linux-x86_64-rhel70-3.6.5/bin/mongodump mongodb-linux-x86_64-rhel70-3.6.5/bin/mongorestore mongodb-linux-x86_64-rhel70-3.6.5/bin/mongoexport mongodb-linux-x86_64-rhel70-3.6.5/bin/mongoimport mongodb-linux-x86_64-rhel70-3.6.5/bin/mongostat mongodb-linux-x86_64-rhel70-3.6.5/bin/mongotop mongodb-linux-x86_64-rhel70-3.6.5/bin/bsondump mongodb-linux-x86_64-rhel70-3.6.5/bin/mongofiles mongodb-linux-x86_64-rhel70-3.6.5/bin/mongoreplay mongodb-linux-x86_64-rhel70-3.6.5/bin/mongoperf mongodb-linux-x86_64-rhel70-3.6.5/bin/mongod mongodb-linux-x86_64-rhel70-3.6.5/bin/mongos mongodb-linux-x86_64-rhel70-3.6.5/bin/mongo mongodb-linux-x86_64-rhel70-3.6.5/bin/install_compass [root ~]# vim .bash_profile ... PATH=$PATH:$HOME/bin:$HOME/mongodb-linux-x86_64-rhel70-3.6.5/bin export PATH ... [root ~]# source .bash_profile [root ~]# mongod --version db version v3.6.5 git version: a20ecd3e3a174162052ff99913bc2ca9a839d618 OpenSSL version: OpenSSL 1.0.1e-fips 11 Feb 2013 allocator: tcmalloc modules: none build environment: distmod: rhel70 distarch: x86_64 target_arch: x86_64 [root ~]# mongo --version MongoDB shell version v3.6.5 git version: a20ecd3e3a174162052ff99913bc2ca9a839d618 OpenSSL version: OpenSSL 1.0.1e-fips 11 Feb 2013 allocator: tcmalloc modules: none build environment: distmod: rhel70 distarch: x86_64 target_arch: x86_64  说明：当然也可以通过yum来安装MongoDB，具体可以参照官方网站上给出的说明。\n 源代码构建安装  安装Python 3.6。\n[root ~]# yum install gcc [root ~]# wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tgz [root ~]# gunzip Python-3.6.5.tgz [root ~]# tar -xvf Python-3.6.5.tar [root ~]# cd Python-3.6.5 [root ~]# ./configure --prefix=/usr/local/python36 --enable-optimizations [root ~]# yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel [root ~]# make \u0026amp;\u0026amp; make install ... [root ~]# ln -s /usr/local/python36/bin/python3.6 /usr/bin/python3 [root ~]# python3 --version Python 3.6.5 [root ~]# python3 -m pip install -U pip [root ~]# pip3 --version   说明：上面在安装好Python之后还需要注册PATH环境变量，将Python安装路径下bin文件夹的绝对路径注册到PATH环境变量中。注册环境变量可以修改用户主目录下的.bash_profile或者/etc目录下的profile文件，二者的区别在于前者相当于是用户环境变量，而后者相当于是系统环境变量。\n  安装Redis-3.2.12。\n[root ~]# wget http://download.redis.io/releases/redis-3.2.12.tar.gz [root ~]# gunzip redis-3.2.12.tar.gz [root ~]# tar -xvf redis-3.2.12.tar [root ~]# cd redis-3.2.12 [root ~]# make \u0026amp;\u0026amp; make install [root ~]# redis-server --version Redis server v=3.2.12 sha=00000000:0 malloc=jemalloc-4.0.3 bits=64 build=5bc5cd3c03d6ceb6 [root ~]# redis-cli --version redis-cli 3.2.12  配置服务 我们可以Linux系统下安装和配置各种服务，也就是说我们可以把Linux系统打造成数据库服务器、Web服务器、缓存服务器、文件服务器、消息队列服务器等等。Linux下的大多数服务都被设置为守护进程（驻留在系统后台运行，但不会因为服务还在运行而导致Linux无法停止运行），所以我们安装的服务通常名字后面都有一个字母d，它是英文单词daemon的缩写，例如：防火墙服务叫firewalld，我们之前安装的MySQL服务叫mysqld，Apache服务器叫httpd等。在安装好服务之后，可以使用systemctl命令或service命令来完成对服务的启动、停止等操作，具体操作如下所示。\n 启动防火墙服务。\n[root ~]# systemctl start firewalld 终止防火墙服务。\n[root ~]# systemctl stop firewalld 重启防火墙服务。\n[root ~]# systemctl restart firewalld 查看防火墙服务状态。\n[root ~]# systemctl status firewalld 设置/禁用防火墙服务开机自启。\n[root ~]# systemctl enable firewalld Created symlink from /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service to /usr/lib/systemd/system/firewalld.service. Created symlink from /etc/systemd/system/multi-user.target.wants/firewalld.service to /usr/lib/systemd/system/firewalld.service. [root ~]# systemctl disable firewalld Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service. Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.  计划任务  在指定的时间执行命令\n at - 将任务排队，在指定的时间执行。 atq - 查看待执行的任务队列。 atrm - 从队列中删除待执行的任务。   指定3天以后下午5点要执行的任务。\n[root ~]# at 5pm+3days at\u0026gt; rm -f /root/*.html at\u0026gt; \u0026lt;EOT\u0026gt; job 9 at Wed Jun 5 17:00:00 2019 查看待执行的任务队列。\n[root ~]# atq 9 Wed Jun 5 17:00:00 2019 a root 从队列中删除指定的任务。\n[root ~]$ atrm 9  计划任务表 - crontab。\n[root ~]# crontab -e * * * * * echo \u0026#34;hello, world!\u0026#34; \u0026gt;\u0026gt; /root/hello.txt 59 23 * * * rm -f /root/*.log   说明：输入crontab -e命令会打开vim来编辑Cron表达式并指定触发的任务，上面我们定制了两个计划任务，一个是每分钟向/root目录下的hello.txt中追加输出hello, world!；另一个是每天23时59分执行删除/root目录下以log为后缀名的文件。如果不知道Cron表达式如何书写，可以参照/etc/crontab文件中的提示（下面会讲到）或者用搜索引擎找一下“Cron表达式在线生成器”来生成Cron表达式。\n 和crontab相关的文件在/etc目录下，通过修改/etc目录下的crontab文件也能够定制计划任务。\n[root ~]# cd /etc [root etc]# ls -l | grep cron -rw-------. 1 root root 541 Aug 3 2017 anacrontab drwxr-xr-x. 2 root root 4096 Mar 27 11:56 cron.d drwxr-xr-x. 2 root root 4096 Mar 27 11:51 cron.daily -rw-------. 1 root root 0 Aug 3 2017 cron.deny drwxr-xr-x. 2 root root 4096 Mar 27 11:50 cron.hourly drwxr-xr-x. 2 root root 4096 Jun 10 2014 cron.monthly -rw-r--r-- 1 root root 493 Jun 23 15:09 crontab drwxr-xr-x. 2 root root 4096 Jun 10 2014 cron.weekly [root etc]# vim crontab 1 SHELL=/bin/bash 2 PATH=/sbin:/bin:/usr/sbin:/usr/bin 3 MAILTO=root 4 5 # For details see man 4 crontabs 6 7 # Example of job definition: 8 # .---------------- minute (0 - 59) 9 # | .------------- hour (0 - 23) 10 # | | .---------- day of month (1 - 31) 11 # | | | .------- month (1 - 12) OR jan,feb,mar,apr ... 12 # | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat 13 # | | | | | 14 # * * * * * user-name command to be executed 网络访问和管理  安全远程连接 - ssh。\n[root ~]$ ssh root@120.77.222.217 The authenticity of host \u0026#39;120.77.222.217 (120.77.222.217)\u0026#39; can\u0026#39;t be established. ECDSA key fingerprint is SHA256:BhUhykv+FvnIL03I9cLRpWpaCxI91m9n7zBWrcXRa8w. ECDSA key fingerprint is MD5:cc:85:e9:f0:d7:07:1a:26:41:92:77:6b:7f:a0:92:65. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added \u0026#39;120.77.222.217\u0026#39; (ECDSA) to the list of known hosts. root@120.77.222.217\u0026#39;s password: 通过网络获取资源 - wget。\n -b 后台下载模式 -O 下载到指定的目录 -r 递归下载  发送和接收邮件 - mail。\n 网络配置工具（旧） - ifconfig。\n[root ~]# ifconfig eth0 eth0: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 172.18.61.250 netmask 255.255.240.0 broadcast 172.18.63.255 ether 00:16:3e:02:b6:46 txqueuelen 1000 (Ethernet) RX packets 1067841 bytes 1296732947 (1.2 GiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 409912 bytes 43569163 (41.5 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 网络配置工具（新） - ip。\n[root ~]# ip address 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 2: eth0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000 link/ether 00:16:3e:02:b6:46 brd ff:ff:ff:ff:ff:ff inet 172.18.61.250/20 brd 172.18.63.255 scope global eth0 valid_lft forever preferred_lft forever 网络可达性检查 - ping。\n[root ~]# ping www.baidu.com -c 3 PING www.a.shifen.com (220.181.111.188) 56(84) bytes of data. 64 bytes from 220.181.111.188 (220.181.111.188): icmp_seq=1 ttl=51 time=36.3 ms 64 bytes from 220.181.111.188 (220.181.111.188): icmp_seq=2 ttl=51 time=36.4 ms 64 bytes from 220.181.111.188 (220.181.111.188): icmp_seq=3 ttl=51 time=36.4 ms --- www.a.shifen.com ping statistics --- 3 packets transmitted, 3 received, 0% packet loss, time 2002ms rtt min/avg/max/mdev = 36.392/36.406/36.427/0.156 ms 显示或管理路由表 - route。\n 查看网络服务和端口 - netstat / ss。\n[root ~]# netstat -nap | grep nginx 网络监听抓包 - tcpdump。\n 安全文件拷贝 - scp。\n[root ~]# scp root@1.2.3.4:/root/guido.jpg hellokitty@4.3.2.1:/home/hellokitty/pic.jpg 文件同步工具 - rsync。\n 说明：使用rsync可以实现文件的自动同步，这个对于文件服务器来说相当重要。关于这个命令的用法，我们在后面讲项目部署的时候为大家详细说明。\n 安全文件传输 - sftp。\n[root ~]# sftp root@1.2.3.4 root@1.2.3.4\u0026#39;s password: Connected to 1.2.3.4. sftp\u0026gt;  help：显示帮助信息。\n ls/lls：显示远端/本地目录列表。\n cd/lcd：切换远端/本地路径。\n mkdir/lmkdir：创建远端/本地目录。\n pwd/lpwd：显示远端/本地当前工作目录。\n get：下载文件。\n put：上传文件。\n rm：删除远端文件。\n bye/exit/quit：退出sftp。\n   进程管理  查看进程 - ps。\n[root ~]# ps -ef UID PID PPID C STIME TTY TIME CMD root 1 0 0 Jun23 ? 00:00:05 /usr/lib/systemd/systemd --switched-root --system --deserialize 21 root 2 0 0 Jun23 ? 00:00:00 [kthreadd] ... [root ~]# ps -ef | grep mysqld root 4943 4581 0 22:45 pts/0 00:00:00 grep --color=auto mysqld mysql 25257 1 0 Jun25 ? 00:00:39 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid 显示进程状态树 - pstree。\n[root ~]# pstree systemd─┬─AliYunDun───18*[{AliYunDun}] ├─AliYunDunUpdate───3*[{AliYunDunUpdate}] ├─2*[agetty] ├─aliyun-service───2*[{aliyun-service}] ├─atd ├─auditd───{auditd} ├─dbus-daemon ├─dhclient ├─irqbalance ├─lvmetad ├─mysqld───28*[{mysqld}] ├─nginx───2*[nginx] ├─ntpd ├─polkitd───6*[{polkitd}] ├─rsyslogd───2*[{rsyslogd}] ├─sshd───sshd───bash───pstree ├─systemd-journal ├─systemd-logind ├─systemd-udevd └─tuned───4*[{tuned}] 查找与指定条件匹配的进程 - pgrep。\n[root ~]$ pgrep mysqld 3584 通过进程号终止进程 - kill。\n[root ~]$ kill -l 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR1 11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM 16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP 21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ 26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR 31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+3 38) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+8 43) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-7 58) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-2 63) SIGRTMAX-1 64) SIGRTMAX [root ~]# kill 1234 [root ~]# kill -9 1234  例子：用一条命令强制终止正在运行的Redis进程。\n```Shell  ps -ef | grep redis | grep -v grep | awk \u0026lsquo;{print $2}\u0026rsquo; | xargs kill ```\n 通过进程名终止进程 - killall / pkill。\n结束名为mysqld的进程。\n[root ~]# pkill mysqld 结束hellokitty用户的所有进程。\n[root ~]# pkill -u hellokitty  说明：这样的操作会让hellokitty用户和服务器断开连接。\n 将进程置于后台运行。\n Ctrl+Z - 快捷键，用于停止进程并置于后台。 \u0026amp; - 将进程置于后台运行。\n[root ~]# mongod \u0026amp; [root ~]# redis-server ... ^Z [4]+ Stopped redis-server  查询后台进程 - jobs。\n[root ~]# jobs [2] Running mongod \u0026amp; [3]- Stopped cat [4]+ Stopped redis-server 让进程在后台继续运行 - bg。\n[root ~]# bg %4 [4]+ redis-server \u0026amp; [root ~]# jobs [2] Running mongod \u0026amp; [3]+ Stopped cat [4]- Running redis-server \u0026amp; 将后台进程置于前台 - fg。\n[root ~]# fg %4 redis-server  说明：置于前台的进程可以使用Ctrl+C来终止它。\n 调整程序/进程运行时优先级 - nice / renice。\n 用户登出后进程继续工作 - nohup。\n[root ~]# nohup ping www.baidu.com \u0026gt; result.txt \u0026amp; 跟踪进程系统调用情况 - strace。\n[root ~]# pgrep mysqld 8803 [root ~]# strace -c -p 8803 strace: Process 8803 attached ^Cstrace: Process 8803 detached % time seconds usecs/call calls errors syscall ------ ----------- ----------- --------- --------- ---------------- 99.18 0.005719 5719 1 restart_syscall 0.49 0.000028 28 1 mprotect 0.24 0.000014 14 1 clone 0.05 0.000003 3 1 mmap 0.03 0.000002 2 1 accept ------ ----------- ----------- --------- --------- ---------------- 100.00 0.005766 5 total  说明：这个命令的用法和参数都比较复杂，建议大家在真正用到这个命令的时候再根据实际需要进行了解。\n 查看当前运行级别 - runlevel。\n[root ~]# runlevel N 3 实时监控进程占用资源状况 - top。\n[root ~]# top top - 23:04:23 up 3 days, 14:10, 1 user, load average: 0.00, 0.01, 0.05 Tasks: 65 total, 1 running, 64 sleeping, 0 stopped, 0 zombie %Cpu(s): 0.3 us, 0.3 sy, 0.0 ni, 99.3 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st KiB Mem : 1016168 total, 191060 free, 324700 used, 500408 buff/cache KiB Swap: 0 total, 0 free, 0 used. 530944 avail Mem ...  -c - 显示进程的整个路径。 -d - 指定两次刷屏之间的间隔时间（秒为单位）。 -i - 不显示闲置进程或僵尸进程。 -p - 显示指定进程的信息。   系统诊断  系统启动异常诊断 - dmesg。\n 查看系统活动信息 - sar。\n[root ~]# sar -u -r 5 10 Linux 3.10.0-957.10.1.el7.x86_64 (izwz97tbgo9lkabnat2lo8z) 06/02/2019 _x86_64_ (2 CPU) 06:48:30 PM CPU %user %nice %system %iowait %steal %idle 06:48:35 PM all 0.10 0.00 0.10 0.00 0.00 99.80 06:48:30 PM kbmemfree kbmemused %memused kbbuffers kbcached kbcommit %commit kbactive kbinact kbdirty 06:48:35 PM 1772012 2108392 54.33 102816 1634528 784940 20.23 793328 1164704 0  -A - 显示所有设备（CPU、内存、磁盘）的运行状况。 -u - 显示所有CPU的负载情况。 -d - 显示所有磁盘的使用情况。 -r - 显示内存的使用情况。 -n - 显示网络运行状态。  查看内存使用情况 - free。\n[root ~]# free total used free shared buff/cache available Mem: 1016168 323924 190452 356 501792 531800 Swap: 0 0 0 虚拟内存统计 - vmstat。\n[root ~]# vmstat procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 2 0 0 204020 79036 667532 0 0 5 18 101 58 1 0 99 0 0 CPU信息统计 - mpstat。\n[root ~]# mpstat Linux 3.10.0-957.5.1.el7.x86_64 (iZ8vba0s66jjlfmo601w4xZ) 05/30/2019 _x86_64_ (1 CPU) 01:51:54 AM CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle 01:51:54 AM all 0.71 0.00 0.17 0.04 0.00 0.00 0.00 0.00 0.00 99.07 查看进程使用内存状况 - pmap。\n[root ~]# ps PID TTY TIME CMD 4581 pts/0 00:00:00 bash 5664 pts/0 00:00:00 ps [root ~]# pmap 4581 4581: -bash 0000000000400000 884K r-x-- bash 00000000006dc000 4K r---- bash 00000000006dd000 36K rw--- bash 00000000006e6000 24K rw--- [ anon ] 0000000001de0000 400K rw--- [ anon ] 00007f82fe805000 48K r-x-- libnss_files-2.17.so 00007f82fe811000 2044K ----- libnss_files-2.17.so ... 报告设备CPU和I/O统计信息 - iostat。\n[root ~]# iostat Linux 3.10.0-693.11.1.el7.x86_64 (iZwz97tbgo9lkabnat2lo8Z) 06/26/2018 _x86_64_ (1 CPU) avg-cpu: %user %nice %system %iowait %steal %idle 0.79 0.00 0.20 0.04 0.00 98.97 Device: tps kB_read/s kB_wrtn/s kB_read kB_wrtn vda 0.85 6.78 21.32 2106565 6623024 vdb 0.00 0.01 0.00 2088 0 显示所有PCI设备 - lspci。\n[root ~]# lspci 00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02) 00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II] 00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II] 00:01.2 USB controller: Intel Corporation 82371SB PIIX3 USB [Natoma/Triton II] (rev 01) 00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03) 00:02.0 VGA compatible controller: Cirrus Logic GD 5446 00:03.0 Ethernet controller: Red Hat, Inc. Virtio network device 00:04.0 Communication controller: Red Hat, Inc. Virtio console 00:05.0 SCSI storage controller: Red Hat, Inc. Virtio block device 00:06.0 SCSI storage controller: Red Hat, Inc. Virtio block device 00:07.0 Unclassified device [00ff]: Red Hat, Inc. Virtio memory balloon 显示进程间通信设施的状态 - ipcs。\n[root ~]# ipcs ------ Message Queues -------- key msqid owner perms used-bytes messages ------ Shared Memory Segments -------- key shmid owner perms bytes nattch status ------ Semaphore Arrays -------- key semid owner perms nsems  Shell编程 之前我们提到过，Shell是一个连接用户和操作系统的应用程序，它提供了人机交互的界面（接口），用户通过这个界面访问操作系统内核的服务。Shell脚本是一种为Shell编写的脚本程序，我们可以通过Shell脚本来进行系统管理，同时也可以通过它进行文件操作。总之，编写Shell脚本对于使用Linux系统的人来说，应该是一项标配技能。\n互联网上有大量关于Shell脚本的相关知识，我不打算再此对Shell脚本做一个全面系统的讲解，我们通过下面的代码来感性的认识下Shell脚本就行了。\n例子1：输入两个整数m和n，计算从m到n的整数求和的结果。\n#!/usr/bin/bash printf \u0026#39;m = \u0026#39; read m printf \u0026#39;n = \u0026#39; read n a=$m sum=0 while [ $a -le $n ] do sum=$[ sum + a ] a=$[ a + 1 ] done echo \u0026#39;结果: \u0026#39;$sum 例子2：自动创建文件夹和指定数量的文件。\n#!/usr/bin/bash printf \u0026#39;输入文件名: \u0026#39; read file printf \u0026#39;输入文件数量(\u0026lt;1000): \u0026#39; read num if [ $num -ge 1000 ] then echo \u0026#39;文件数量不能超过1000\u0026#39; else if [ -e $dir -a -d $dir ] then rm -rf $dir else if [ -e $dir -a -f $dir ] then rm -f $dir fi fi mkdir -p $dir index=1 while [ $index -le $num ] do if [ $index -lt 10 ] then pre=\u0026#39;00\u0026#39; elif [ $index -lt 100 ] then pre=\u0026#39;0\u0026#39; else pre=\u0026#39;\u0026#39; fi touch $dir\u0026#39;/\u0026#39;$file\u0026#39;_\u0026#39;$pre$index index=$[ index + 1 ] done fi 例子3：自动安装指定版本的Redis。\n#!/usr/bin/bash install_redis() { if ! which redis-server \u0026gt; /dev/null then cd /root wget $1$2\u0026#39;.tar.gz\u0026#39; \u0026gt;\u0026gt; install.log gunzip /root/$2\u0026#39;.tar.gz\u0026#39; tar -xf /root/$2\u0026#39;.tar\u0026#39; cd /root/$2 make \u0026gt;\u0026gt; install.log make install \u0026gt;\u0026gt; install.log echo \u0026#39;安装完成\u0026#39; else echo \u0026#39;已经安装过Redis\u0026#39; fi } install_redis \u0026#39;http://download.redis.io/releases/\u0026#39; $1 相关资源  Linux命令行常用快捷键  | 快捷键 | 功能说明 | | \u0026mdash;\u0026mdash;\u0026mdash;- | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; | | tab | 自动补全命令或路径 | | Ctrl+a | 将光标移动到命令行行首 | | Ctrl+e | 将光标移动到命令行行尾 | | Ctrl+f | 将光标向右移动一个字符 | | Ctrl+b | 将光标向左移动一个字符 | | Ctrl+k | 剪切从光标到行尾的字符 | | Ctrl+u | 剪切从光标到行首的字符 | | Ctrl+w | 剪切光标前面的一个单词 | | Ctrl+y | 复制剪切命名剪切的内容 | | Ctrl+c | 中断正在执行的任务 | | Ctrl+h | 删除光标前面的一个字符 | | Ctrl+d | 退出当前命令行 | | Ctrl+r | 搜索历史命令 | | Ctrl+g | 退出历史命令搜索 | | Ctrl+l | 清除屏幕上所有内容在屏幕的最上方开启一个新行 | | Ctrl+s | 锁定终端使之暂时无法输入内容 | | Ctrl+q | 退出终端锁定 | | Ctrl+z | 将正在终端执行的任务停下来放到后台 | | !! | 执行上一条命令 | | !数字 | 执行数字对应的历史命令 | | !字母 | 执行最近的以字母打头的命令 | | !$ / Esc+. | 获得上一条命令最后一个参数 | | Esc+b | 移动到当前单词的开头 | | Esc+f | 移动到当前单词的结尾 |\n man查阅命令手册的内容说明  | 手册中的标题 | 功能说明 | | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; | | NAME | 命令的说明和介绍 | | SYNOPSIS | 使用该命令的基本语法 | | DESCRIPTION | 使用该命令的详细描述，各个参数的作用，有时候这些信息会出现在OPTIONS中 | | OPTIONS | 命令相关参数选项的说明 | | EXAMPLES | 使用该命令的参考例子 | | EXIT STATUS | 命令结束的退出状态码，通常0表示成功执行 | | SEE ALSO | 和命令相关的其他命令或信息 | | BUGS | 和命令相关的缺陷的描述 | | AUTHOR | 该命令的作者介绍 |\n"},{"idx":29,"href":"/python100days/docs/Day36-40/36-38-%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93MySQL/","title":"36 38 关系型数据库 My S Q L","content":" 关系数据库入门 关系数据库概述  数据持久化 - 将数据保存到能够长久保存数据的存储介质中，在掉电的情况下数据也不会丢失。\n 数据库发展史 - 网状数据库、层次数据库、关系数据库、NoSQL数据库。\n   1970年，IBM的研究员E.F.Codd在*Communication of the ACM*上发表了名为*A Relational Model of Data for Large Shared Data Banks*的论文，提出了关系模型的概念，奠定了关系模型的理论基础。后来Codd又陆续发表多篇文章，论述了范式理论和衡量关系系统的12条标准，用数学理论奠定了关系数据库的基础。\n  关系数据库特点。\n 理论基础：集合论和关系代数。\n 具体表象：用二维表（有行和列）组织数据。\n 编程语言：结构化查询语言（SQL）。\n  ER模型（实体关系模型）和概念模型图。\n  ER模型，全称为实体关系模型（Entity-Relationship Model），由美籍华裔计算机科学家陈品山先生提出，是概念数据模型的高层描述方式，如下图所示。\n 实体 - 矩形框 属性 - 椭圆框 关系 - 菱形框 重数 - 1:1（一对一） / 1:N（一对多） / M:N（多对多）  实际项目开发中，我们可以利用数据库建模工具（如：PowerDesigner）来绘制概念数据模型（其本质就是ER模型），然后再设置好目标数据库系统，将概念模型转换成物理模型，最终生成创建二维表的SQL（很多工具都可以根据我们设计的物理模型图以及设定的目标数据库来导出SQL或直接生成数据表）。\n 关系数据库产品。  Oracle - 目前世界上使用最为广泛的数据库管理系统，作为一个通用的数据库系统，它具有完整的数据管理功能；作为一个关系数据库，它是一个完备关系的产品；作为分布式数据库，它实现了分布式处理的功能。在Oracle最新的12c版本中，还引入了多承租方架构，使用该架构可轻松部署和管理数据库云。 DB2 - IBM公司开发的、主要运行于Unix（包括IBM自家的AIX）、Linux、以及Windows服务器版等系统的关系数据库产品。DB2历史悠久且被认为是最早使用SQL的数据库产品，它拥有较为强大的商业智能功能。 SQL Server - 由Microsoft开发和推广的关系型数据库产品，最初适用于中小企业的数据管理，但是近年来它的应用范围有所扩展，部分大企业甚至是跨国公司也开始基于它来构建自己的数据管理系统。 MySQL - MySQL是开放源代码的，任何人都可以在GPL（General Public License）的许可下下载并根据个性化的需要对其进行修改。MySQL因为其速度、可靠性和适应性而备受关注。 [PostgreSQL]() - 在BSD许可证下发行的开放源代码的关系数据库产品。   MySQL简介 MySQL最早是由瑞典的MySQL AB公司开发的一个开放源码的关系数据库管理系统，该公司于2008年被昇阳微系统公司（Sun Microsystems）收购。在2009年，甲骨文公司（Oracle）收购昇阳微系统公司，因此在这之后MySQL成为了Oracle旗下产品。\nMySQL在过去由于性能高、成本低、可靠性好，已经成为最流行的开源数据库，因此被广泛地应用于中小型网站开发。随着MySQL的不断成熟，它也逐渐被应用于更多大规模网站和应用，比如维基百科、谷歌（Google）、脸书（Facebook）、淘宝网等网站都使用了MySQL来提供数据持久化服务。\n甲骨文公司收购后昇阳微系统公司，大幅调涨MySQL商业版的售价，且甲骨文公司不再支持另一个自由软件项目OpenSolaris的发展，因此导致自由软件社区对于Oracle是否还会持续支持MySQL社区版（MySQL的各个发行版本中唯一免费的版本）有所担忧，MySQL的创始人麦克尔·维德纽斯以MySQL为基础，成立分支计划MariaDB（以他女儿的名字命名的数据库）。有许多原来使用MySQL数据库的公司（例如：维基百科）已经陆续完成了从MySQL数据库到MariaDB数据库的迁移。\n 安装和配置   说明：下面的安装和配置都是以CentOS Linux环境为例，如果需要在其他系统下安装MySQL，读者可以自行在网络上查找对应的安装教程）。\n  刚才说过，MySQL有一个分支版本名叫MariaDB，该数据库旨在继续保持MySQL数据库在GNU GPL下开源。如果要使用MariaDB作为MySQL的替代品，可以使用下面的命令进行安装。\nyum install mariadb mariadb-server 如果要安装官方版本的MySQL，可以在MySQL官方网站下载安装文件。首先在下载页面中选择平台和版本，然后找到对应的下载链接。下面以MySQL 5.7.26版本和Red Hat Enterprise Linux为例，直接下载包含所有安装文件的归档文件，解归档之后通过包管理工具进行安装。\nwget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar tar -xvf mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar 如果系统上有MariaDB相关的文件，需要先移除MariaDB相关的文件。\nyum list installed | grep mariadb | awk \u0026#39;{print $1}\u0026#39; | xargs yum erase -y 接下来可以按照如下所示的顺序用RPM（Redhat Package Manager）工具安装MySQL。\nrpm -ivh mysql-community-common-5.7.26-1.el7.x86_64.rpm rpm -ivh mysql-community-libs-5.7.26-1.el7.x86_64.rpm rpm -ivh mysql-community-client-5.7.26-1.el7.x86_64.rpm rpm -ivh mysql-community-server-5.7.26-1.el7.x86_64.rpm 可以使用下面的命令查看已经安装的MySQL相关的包。\nrpm -qa | grep mysql 配置MySQL。\nMySQL的配置文件在/etc目录下，名为my.cnf，默认的配置文件内容如下所示。如果对这个文件不理解并没有关系，什么时候用到这个配置文件什么时候再了解它就行了。\ncat /etc/my.cnf# For advice on how to change settings please see # http://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html [mysqld] # # Remove leading # and set to the amount of RAM for the most important data # cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%. # innodb_buffer_pool_size = 128M # # Remove leading # to turn on a very important data integrity option: logging # changes to the binary log between backups. # log_bin # # Remove leading # to set options mainly useful for reporting servers. # The server defaults are faster for transactions and fast SELECTs. # Adjust sizes as needed, experiment to find the optimal values. # join_buffer_size = 128M # sort_buffer_size = 2M # read_rnd_buffer_size = 2M datadir=/var/lib/mysql socket=/var/lib/mysql/mysql.sock # Disabling symbolic-links is recommended to prevent assorted security risks symbolic-links=0 log-error=/var/log/mysqld.log pid-file=/var/run/mysqld/mysqld.pid 启动MySQL服务。\n可以使用下面的命令来启动MySQL。\nservice mysqld start 在CentOS 7中，更推荐使用下面的命令来启动MySQL。\nsystemctl start mysqld 启动MySQL成功后，可以通过下面的命令来检查网络端口使用情况，MySQL默认使用3306端口。\nnetstat -ntlp | grep mysql 也可以使用下面的命令查找是否有名为mysqld的进程。\npgrep mysqld 使用MySQL客户端工具连接服务器。\n命令行工具：\nmysql -u root -p  说明：启动客户端时，-u参数用来指定用户名，MySQL默认的超级管理账号为root；-p表示要输入密码（用户口令）；如果连接的是其他主机而非本机，可以用-h来指定连接主机的主机名或IP地址。\n 如果是首次安装MySQL，可以使用下面的命令来找到默认的初始密码。\ncat /var/log/mysqld.log | grep password 上面的命令会查看MySQL的日志带有password的行，在显示的结果中root@localhost:后面的部分就是默认设置的初始密码。\n修改超级管理员（root）的访问口令为123456。\nset global validate_password_policy=0; set global validate_password_length=6; alter user \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; identified by \u0026#39;123456\u0026#39;;  说明：MySQL较新的版本默认不允许使用弱口令作为用户口令，所以我们通过上面的前两条命令修改了验证用户口令的策略和口令的长度。事实上我们不应该使用弱口令，因为存在用户口令被暴力破解的风险。近年来，攻击数据库窃取数据和劫持数据库勒索比特币的事件屡见不鲜，要避免这些潜在的风险，最为重要的一点是不要让数据库服务器暴露在公网上（最好的做法是将数据库置于内网，至少要做到不向公网开放数据库服务器的访问端口），另外要保管好root账号的口令，应用系统需要访问数据库时，通常不使用root账号进行访问，而是创建其他拥有适当权限的账号来访问。\n 再次使用客户端工具连接MySQL服务器时，就可以使用新设置的口令了。在实际开发中，为了方便用户操作，可以选择图形化的客户端工具来连接MySQL服务器，包括：\n MySQL Workbench（官方提供的工具） Navicat for MySQL（界面简单优雅，功能直观强大） SQLyog for MySQL（强大的MySQL数据库管理员工具）    常用命令。\n 查看服务器版本。\nselect version(); 查看所有数据库。\nshow databases; 切换到指定数据库。\nuse mysql; 查看数据库下所有表。\nshow tables; 获取帮助。\n? contents; ? functions; ? numeric functions; ? round; ? data types; ? longblob;   SQL详解 基本操作 我们通常可以将SQL分为三类：DDL（数据定义语言）、DML（数据操作语言）和DCL（数据控制语言）。DDL主要用于创建（create）、删除（drop）、修改（alter）数据库中的对象，比如创建、删除和修改二维表；DML主要负责插入数据（insert）、删除数据（delete）、更新数据（update）和查询（select）；DCL通常用于授予权限（grant）和召回权限（revoke）。\n 说明：SQL是不区分大小写的语言，为了书写方便，下面的SQL都使用了小写字母来书写。\n  DDL（数据定义语言）\n-- 如果存在名为school的数据库就删除它 drop database if exists school; -- 创建名为school的数据库并设置默认的字符集和排序方式 create database school default charset utf8 collate utf8_bin; -- 切换到school数据库上下文环境 use school; -- 创建学院表 create table tb_college ( collid\tint auto_increment comment \u0026#39;编号\u0026#39;, collname\tvarchar(50) not null comment \u0026#39;名称\u0026#39;, collmaster\tvarchar(20) not null comment \u0026#39;院长\u0026#39;, primary key (collid) ); -- 创建学生表 create table tb_student ( stuid\tint not null comment \u0026#39;学号\u0026#39;, stuname\tvarchar(20) not null comment \u0026#39;姓名\u0026#39;, stusex\tboolean default 1 comment \u0026#39;性别\u0026#39;, stubirth\tdate not null comment \u0026#39;出生日期\u0026#39;, stuaddr\tvarchar(255) default \u0026#39;\u0026#39; comment \u0026#39;籍贯\u0026#39;, collid\tint not null comment \u0026#39;所属学院\u0026#39;, primary key (stuid), foreign key (collid) references tb_college (collid) ); -- 创建教师表 create table tb_teacher ( teaid\tint not null comment \u0026#39;工号\u0026#39;, teaname\tvarchar(20) not null comment \u0026#39;姓名\u0026#39;, teatitle\tvarchar(10) default \u0026#39;助教\u0026#39; comment \u0026#39;职称\u0026#39;, collid\tint not null comment \u0026#39;所属学院\u0026#39;, primary key (teaid), foreign key (collid) references tb_college (collid) ); -- 创建课程表 create table tb_course ( couid\tint not null comment \u0026#39;编号\u0026#39;, couname\tvarchar(50) not null comment \u0026#39;名称\u0026#39;, coucredit\tint not null comment \u0026#39;学分\u0026#39;, teaid\tint not null comment \u0026#39;授课老师\u0026#39;, primary key (couid), foreign key (teaid) references tb_teacher (teaid) ); -- 创建选课记录表 create table tb_record ( recid\tint auto_increment comment \u0026#39;选课记录编号\u0026#39;, sid\tint not null comment \u0026#39;选课学生\u0026#39;, cid\tint not null comment \u0026#39;所选课程\u0026#39;, seldate\tdatetime default now() comment \u0026#39;选课时间日期\u0026#39;, score\tdecimal(4,1) comment \u0026#39;考试成绩\u0026#39;, primary key (recid), foreign key (sid) references tb_student (stuid), foreign key (cid) references tb_course (couid), unique (sid, cid) );  上面的DDL有几个地方需要强调一下：\n 创建数据库时，我们通过default charset utf8指定了数据库默认使用的字符集，我们推荐使用该字符集，因为utf8能够支持国际化编码。如果将来数据库中用到的字符可能包括类似于Emoji这样的图片字符，也可以将默认字符集设定为utf8mb4（最大4字节的utf-8编码）。查看MySQL支持的字符集可以执行下面的语句。\nshow character set;  +----------+---------------------------------+---------------------+--------+ | Charset | Description | Default collation | Maxlen | +----------+---------------------------------+---------------------+--------+ | big5 | Big5 Traditional Chinese | big5_chinese_ci | 2 | | dec8 | DEC West European | dec8_swedish_ci | 1 | | cp850 | DOS West European | cp850_general_ci | 1 | | hp8 | HP West European | hp8_english_ci | 1 | | koi8r | KOI8-R Relcom Russian | koi8r_general_ci | 1 | | latin1 | cp1252 West European | latin1_swedish_ci | 1 | | latin2 | ISO 8859-2 Central European | latin2_general_ci | 1 | | swe7 | 7bit Swedish | swe7_swedish_ci | 1 | | ascii | US ASCII | ascii_general_ci | 1 | | ujis | EUC-JP Japanese | ujis_japanese_ci | 3 | | sjis | Shift-JIS Japanese | sjis_japanese_ci | 2 | | hebrew | ISO 8859-8 Hebrew | hebrew_general_ci | 1 | | tis620 | TIS620 Thai | tis620_thai_ci | 1 | | euckr | EUC-KR Korean | euckr_korean_ci | 2 | | koi8u | KOI8-U Ukrainian | koi8u_general_ci | 1 | | gb2312 | GB2312 Simplified Chinese | gb2312_chinese_ci | 2 | | greek | ISO 8859-7 Greek | greek_general_ci | 1 | | cp1250 | Windows Central European | cp1250_general_ci | 1 | | gbk | GBK Simplified Chinese | gbk_chinese_ci | 2 | | latin5 | ISO 8859-9 Turkish | latin5_turkish_ci | 1 | | armscii8 | ARMSCII-8 Armenian | armscii8_general_ci | 1 | | utf8 | UTF-8 Unicode | utf8_general_ci | 3 | | ucs2 | UCS-2 Unicode | ucs2_general_ci | 2 | | cp866 | DOS Russian | cp866_general_ci | 1 | | keybcs2 | DOS Kamenicky Czech-Slovak | keybcs2_general_ci | 1 | | macce | Mac Central European | macce_general_ci | 1 | | macroman | Mac West European | macroman_general_ci | 1 | | cp852 | DOS Central European | cp852_general_ci | 1 | | latin7 | ISO 8859-13 Baltic | latin7_general_ci | 1 | | utf8mb4 | UTF-8 Unicode | utf8mb4_general_ci | 4 | | cp1251 | Windows Cyrillic | cp1251_general_ci | 1 | | utf16 | UTF-16 Unicode | utf16_general_ci | 4 | | utf16le | UTF-16LE Unicode | utf16le_general_ci | 4 | | cp1256 | Windows Arabic | cp1256_general_ci | 1 | | cp1257 | Windows Baltic | cp1257_general_ci | 1 | | utf32 | UTF-32 Unicode | utf32_general_ci | 4 | | binary | Binary pseudo charset | binary | 1 | | geostd8 | GEOSTD8 Georgian | geostd8_general_ci | 1 | | cp932 | SJIS for Windows Japanese | cp932_japanese_ci | 2 | | eucjpms | UJIS for Windows Japanese | eucjpms_japanese_ci | 3 | | gb18030 | China National Standard GB18030 | gb18030_chinese_ci | 4 | +----------+---------------------------------+---------------------+--------+ 41 rows in set (0.00 sec)  如果要设置MySQL服务启动时默认使用的字符集，可以修改MySQL的配置并添加以下内容\n[mysqld] character-set-server=utf8 在创建表的时候，我们可以在右圆括号的后面通过engine=XXX来指定表的存储引擎，MySQL支持多种存储引擎，可以通过show engines命令进行查看。MySQL 5.5以后的版本默认使用的存储引擎是InnoDB，它正好也就是我们推荐大家使用的存储引擎（因为InnoDB更适合互联网应用对高并发、性能以及事务支持等方面的需求）。\nshow engines\\G  *************************** 1. row *************************** Engine: InnoDB Support: DEFAULT Comment: Supports transactions, row-level locking, and foreign keys Transactions: YES XA: YES Savepoints: YES *************************** 2. row *************************** Engine: MRG_MYISAM Support: YES Comment: Collection of identical MyISAM tables Transactions: NO XA: NO Savepoints: NO *************************** 3. row *************************** Engine: MEMORY Support: YES Comment: Hash based, stored in memory, useful for temporary tables Transactions: NO XA: NO Savepoints: NO *************************** 4. row *************************** Engine: BLACKHOLE Support: YES Comment: /dev/null storage engine (anything you write to it disappears) Transactions: NO XA: NO Savepoints: NO *************************** 5. row *************************** Engine: MyISAM Support: YES Comment: MyISAM storage engine Transactions: NO XA: NO Savepoints: NO *************************** 6. row *************************** Engine: CSV Support: YES Comment: CSV storage engine Transactions: NO XA: NO Savepoints: NO *************************** 7. row *************************** Engine: ARCHIVE Support: YES Comment: Archive storage engine Transactions: NO XA: NO Savepoints: NO *************************** 8. row *************************** Engine: PERFORMANCE_SCHEMA Support: YES Comment: Performance Schema Transactions: NO XA: NO Savepoints: NO *************************** 9. row *************************** Engine: FEDERATED Support: NO Comment: Federated MySQL storage engine Transactions: NULL XA: NULL Savepoints: NULL 9 rows in set (0.00 sec)  下面的表格对MySQL几种常用的数据引擎进行了简单的对比。\n| 特性 | InnoDB | MRG_MYISAM | MEMORY | MyISAM | | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; | \u0026mdash;\u0026mdash;\u0026mdash;- | \u0026mdash;\u0026mdash; | \u0026mdash;\u0026mdash; | | 存储限制 | 有 | 没有 | 有 | 有 | | 事务 | 支持 | | | | | 锁机制 | 行锁 | 表锁 | 表锁 | 表锁 | | B树索引 | 支持 | 支持 | 支持 | 支持 | | 哈希索引 | | | 支持 | | | 全文检索 | 支持（5.6+） | | | 支持 | | 集群索引 | 支持 | | | | | 数据缓存 | 支持 | | 支持 | | | 索引缓存 | 支持 | 支持 | 支持 | 支持 | | 数据可压缩 | | | | 支持 | | 内存使用 | 高 | 低 | 中 | 低 | | 存储空间使用 | 高 | 低 | | 低 | | 批量插入性能 | 低 | 高 | 高 | 高 | | 是否支持外键 | 支持 | | | |\n通过上面的比较我们可以了解到，InnoDB是唯一能够支持外键、事务以及行锁的存储引擎，所以我们之前说它更适合互联网应用，而且它也是较新的MySQL版本中默认使用的存储引擎。\n 在定义表结构为每个字段选择数据类型时，如果不清楚哪个数据类型更合适，可以通过MySQL的帮助系统来了解每种数据类型的特性、数据的长度和精度等相关信息。\n? data types  You asked for help about help category: \u0026quot;Data Types\u0026quot; For more information, type 'help \u0026lt;item\u0026gt;', where \u0026lt;item\u0026gt; is one of the following topics: AUTO_INCREMENT BIGINT BINARY BIT BLOB BLOB DATA TYPE BOOLEAN CHAR CHAR BYTE DATE DATETIME DEC DECIMAL DOUBLE DOUBLE PRECISION ENUM FLOAT INT INTEGER LONGBLOB LONGTEXT MEDIUMBLOB MEDIUMINT MEDIUMTEXT SET DATA TYPE SMALLINT TEXT TIME TIMESTAMP TINYBLOB TINYINT TINYTEXT VARBINARY VARCHAR YEAR DATA TYPE  ? varchar  Name: 'VARCHAR' Description: [NATIONAL] VARCHAR(M) [CHARACTER SET charset_name] [COLLATE collation_name] A variable-length string. M represents the maximum column length in characters. The range of M is 0 to 65,535. The effective maximum length of a VARCHAR is subject to the maximum row size (65,535 bytes, which is shared among all columns) and the character set used. For example, utf8 characters can require up to three bytes per character, so a VARCHAR column that uses the utf8 character set can be declared to be a maximum of 21,844 characters. See http://dev.mysql.com/doc/refman/5.7/en/column-count-limit.html. MySQL stores VARCHAR values as a 1-byte or 2-byte length prefix plus data. The length prefix indicates the number of bytes in the value. A VARCHAR column uses one length byte if values require no more than 255 bytes, two length bytes if values may require more than 255 bytes. *Note*: MySQL follows the standard SQL specification, and does not remove trailing spaces from VARCHAR values. VARCHAR is shorthand for CHARACTER VARYING. NATIONAL VARCHAR is the standard SQL way to define that a VARCHAR column should use some predefined character set. MySQL uses utf8 as this predefined character set. http://dev.mysql.com/doc/refman/5.7/en/charset-national.html. NVARCHAR is shorthand for NATIONAL VARCHAR. URL: http://dev.mysql.com/doc/refman/5.7/en/string-type-overview.html  在数据类型的选择上，保存字符串数据通常都使用VARCHAR和CHAR两种类型，前者通常称为变长字符串，而后者通常称为定长字符串；对于InnoDB存储引擎，行存储格式没有区分固定长度和可变长度列，因此VARCHAR类型好CHAR类型没有本质区别，后者不一定比前者性能更好。如果要保存的很大字符串，可以使用TEXT类型；如果要保存很大的字节串，可以使用BLOB（二进制大对象）类型。在MySQL中，TEXT和BLOB又分别包括TEXT、MEDIUMTEXT、LONGTEXT和BLOB、MEDIUMBLOB、LONGBLOB三种不同的类型，它们主要的区别在于存储数据的最大大小不同。保存浮点数可以用FLOAT或DOUBLE类型，而保存定点数应该使用DECIMAL类型。如果要保存时间日期，DATETIME类型优于TIMESTAMP类型，因为前者能表示的时间日期范围更大。\n   DML\n-- 插入学院数据 insert into tb_college (collname, collmaster) values (\u0026#39;计算机学院\u0026#39;, \u0026#39;左冷禅\u0026#39;), (\u0026#39;外国语学院\u0026#39;, \u0026#39;岳不群\u0026#39;), (\u0026#39;经济管理学院\u0026#39;, \u0026#39;风清扬\u0026#39;); -- 插入学生数据 insert into tb_student (stuid, stuname, stusex, stubirth, stuaddr, collid) values (1001, \u0026#39;杨逍\u0026#39;, 1, \u0026#39;1990-3-4\u0026#39;, \u0026#39;四川成都\u0026#39;, 1), (1002, \u0026#39;任我行\u0026#39;, 1, \u0026#39;1992-2-2\u0026#39;, \u0026#39;湖南长沙\u0026#39;, 1), (1033, \u0026#39;王语嫣\u0026#39;, 0, \u0026#39;1989-12-3\u0026#39;, \u0026#39;四川成都\u0026#39;, 1), (1572, \u0026#39;岳不群\u0026#39;, 1, \u0026#39;1993-7-19\u0026#39;, \u0026#39;陕西咸阳\u0026#39;, 1), (1378, \u0026#39;纪嫣然\u0026#39;, 0, \u0026#39;1995-8-12\u0026#39;, \u0026#39;四川绵阳\u0026#39;, 1), (1954, \u0026#39;林平之\u0026#39;, 1, \u0026#39;1994-9-20\u0026#39;, \u0026#39;福建莆田\u0026#39;, 1), (2035, \u0026#39;东方不败\u0026#39;, 1, \u0026#39;1988-6-30\u0026#39;, null, 2), (3011, \u0026#39;林震南\u0026#39;, 1, \u0026#39;1985-12-12\u0026#39;, \u0026#39;福建莆田\u0026#39;, 3), (3755, \u0026#39;项少龙\u0026#39;, 1, \u0026#39;1993-1-25\u0026#39;, null, 3), (3923, \u0026#39;杨不悔\u0026#39;, 0, \u0026#39;1985-4-17\u0026#39;, \u0026#39;四川成都\u0026#39;, 3), (4040, \u0026#39;隔壁老王\u0026#39;, 1, \u0026#39;1989-1-1\u0026#39;, \u0026#39;四川成都\u0026#39;, 2); -- 删除学生数据 delete from tb_student where stuid=4040; -- 更新学生数据 update tb_student set stuname=\u0026#39;杨过\u0026#39;, stuaddr=\u0026#39;湖南长沙\u0026#39; where stuid=1001; -- 插入老师数据 insert into tb_teacher (teaid, teaname, teatitle, collid) values (1122, \u0026#39;张三丰\u0026#39;, \u0026#39;教授\u0026#39;, 1), (1133, \u0026#39;宋远桥\u0026#39;, \u0026#39;副教授\u0026#39;, 1), (1144, \u0026#39;杨逍\u0026#39;, \u0026#39;副教授\u0026#39;, 1), (2255, \u0026#39;范遥\u0026#39;, \u0026#39;副教授\u0026#39;, 2), (3366, \u0026#39;韦一笑\u0026#39;, \u0026#39;讲师\u0026#39;, 3); -- 插入课程数据 insert into tb_course (couid, couname, coucredit, teaid) values (1111, \u0026#39;Python程序设计\u0026#39;, 3, 1122), (2222, \u0026#39;Web前端开发\u0026#39;, 2, 1122), (3333, \u0026#39;操作系统\u0026#39;, 4, 1122), (4444, \u0026#39;计算机网络\u0026#39;, 2, 1133), (5555, \u0026#39;编译原理\u0026#39;, 4, 1144), (6666, \u0026#39;算法和数据结构\u0026#39;, 3, 1144), (7777, \u0026#39;经贸法语\u0026#39;, 3, 2255), (8888, \u0026#39;成本会计\u0026#39;, 2, 3366), (9999, \u0026#39;审计学\u0026#39;, 3, 3366); -- 插入选课数据 insert into tb_record (sid, cid, seldate, score) values (1001, 1111, \u0026#39;2017-09-01\u0026#39;, 95), (1001, 2222, \u0026#39;2017-09-01\u0026#39;, 87.5), (1001, 3333, \u0026#39;2017-09-01\u0026#39;, 100), (1001, 4444, \u0026#39;2018-09-03\u0026#39;, null), (1001, 6666, \u0026#39;2017-09-02\u0026#39;, 100), (1002, 1111, \u0026#39;2017-09-03\u0026#39;, 65), (1002, 5555, \u0026#39;2017-09-01\u0026#39;, 42), (1033, 1111, \u0026#39;2017-09-03\u0026#39;, 92.5), (1033, 4444, \u0026#39;2017-09-01\u0026#39;, 78), (1033, 5555, \u0026#39;2017-09-01\u0026#39;, 82.5), (1572, 1111, \u0026#39;2017-09-02\u0026#39;, 78), (1378, 1111, \u0026#39;2017-09-05\u0026#39;, 82), (1378, 7777, \u0026#39;2017-09-02\u0026#39;, 65.5), (2035, 7777, \u0026#39;2018-09-03\u0026#39;, 88), (2035, 9999, default, null), (3755, 1111, default, null), (3755, 8888, default, null), (3755, 9999, \u0026#39;2017-09-01\u0026#39;, 92);-- 查询所有学生信息 select * from tb_student; -- 查询所有课程名称及学分(投影和别名) select couname, coucredit from tb_course; select couname as 课程名称, coucredit as 学分 from tb_course; -- 查询所有学生的姓名和性别(条件运算) select stuname as 姓名, case stusex when 1 then \u0026#39;男\u0026#39; else \u0026#39;女\u0026#39; end as 性别 from tb_student; select stuname as 姓名, if(stusex, \u0026#39;男\u0026#39;, \u0026#39;女\u0026#39;) as 性别 from tb_student; -- 查询所有女学生的姓名和出生日期(筛选) select stuname, stubirth from tb_student where stusex=0; -- 查询所有80后学生的姓名、性别和出生日期(筛选) select stuname, stusex, stubirth from tb_student where stubirth\u0026gt;=\u0026#39;1980-1-1\u0026#39; and stubirth\u0026lt;=\u0026#39;1989-12-31\u0026#39;; select stuname, stusex, stubirth from tb_student where stubirth between \u0026#39;1980-1-1\u0026#39; and \u0026#39;1989-12-31\u0026#39;; -- 查询姓\u0026#34;杨\u0026#34;的学生姓名和性别(模糊) select stuname, stusex from tb_student where stuname like \u0026#39;杨%\u0026#39;; -- 查询姓\u0026#34;杨\u0026#34;名字两个字的学生姓名和性别(模糊) select stuname, stusex from tb_student where stuname like \u0026#39;杨_\u0026#39;; -- 查询姓\u0026#34;杨\u0026#34;名字三个字的学生姓名和性别(模糊) select stuname, stusex from tb_student where stuname like \u0026#39;杨__\u0026#39;; -- 查询名字中有\u0026#34;不\u0026#34;字或\u0026#34;嫣\u0026#34;字的学生的姓名(模糊) select stuname, stusex from tb_student where stuname like \u0026#39;%不%\u0026#39; or stuname like \u0026#39;%嫣%\u0026#39;; -- 查询没有录入家庭住址的学生姓名(空值) select stuname from tb_student where stuaddr is null; -- 查询录入了家庭住址的学生姓名(空值) select stuname from tb_student where stuaddr is not null; -- 查询学生选课的所有日期(去重) select distinct seldate from tb_record; -- 查询学生的家庭住址(去重) select distinct stuaddr from tb_student where stuaddr is not null; -- 查询男学生的姓名和生日按年龄从大到小排列(排序) select stuname as 姓名, datediff(curdate(), stubirth) div 365 as 年龄 from tb_student where stusex=1 order by 年龄 desc; -- 查询年龄最大的学生的出生日期(聚合函数) select min(stubirth) from tb_student; -- 查询年龄最小的学生的出生日期(聚合函数) select max(stubirth) from tb_student; -- 查询男女学生的人数(分组和聚合函数) select stusex, count(*) from tb_student group by stusex; -- 查询课程编号为1111的课程的平均成绩(筛选和聚合函数) select avg(score) from tb_record where cid=1111; -- 查询学号为1001的学生所有课程的平均分(筛选和聚合函数) select avg(score) from tb_record where sid=1001; -- 查询每个学生的学号和平均成绩(分组和聚合函数) select sid as 学号, avg(score) as 平均分 from tb_record group by sid; -- 查询平均成绩大于等于90分的学生的学号和平均成绩 -- 分组以前的筛选使用where子句 / 分组以后的筛选使用having子句 select sid as 学号, avg(score) as 平均分 from tb_record group by sid having 平均分\u0026gt;=90; -- 查询年龄最大的学生的姓名(子查询/嵌套的查询) select stuname from tb_student where stubirth=( select min(stubirth) from tb_student ); -- 查询年龄最大的学生姓名和年龄(子查询+运算) select stuname as 姓名, datediff(curdate(), stubirth) div 365 as 年龄 from tb_student where stubirth=( select min(stubirth) from tb_student ); -- 查询选了两门以上的课程的学生姓名(子查询/分组条件/集合运算) select stuname from tb_student where stuid in ( select stuid from tb_record group by stuid having count(stuid)\u0026gt;2 ); -- 查询学生姓名、课程名称以及成绩(连接查询) select stuname, couname, score from tb_student t1, tb_course t2, tb_record t3 where stuid=sid and couid=cid and score is not null; -- 查询学生姓名、课程名称以及成绩按成绩从高到低查询第11-15条记录(内连接+分页) select stuname, couname, score from tb_student inner join tb_record on stuid=sid inner join tb_course on couid=cid where score is not null order by score desc limit 5 offset 10; select stuname, couname, score from tb_student inner join tb_record on stuid=sid inner join tb_course on couid=cid where score is not null order by score desc limit 10, 5; -- 查询选课学生的姓名和平均成绩(子查询和连接查询) select stuname, avgmark from tb_student, ( select sid, avg(score) as avgmark from tb_record group by sid ) temp where stuid=sid; select stuname, avgmark from tb_student inner join ( select sid, avg(score) as avgmark from tb_record group by sid ) temp on stuid=sid; -- 查询每个学生的姓名和选课数量(左外连接和子查询) select stuname, ifnull(total, 0) from tb_student left outer join ( select sid, count(sid) as total from tb_record group by sid ) temp on stuid=sid;  上面的DML有几个地方需要加以说明：\n MySQL中支持多种类型的运算符，包括：算术运算符（+、-、*、/、%）、比较运算符（=、\u0026lt;\u0026gt;、\u0026lt;=\u0026gt;、\u0026lt;、\u0026lt;=、\u0026gt;、\u0026gt;=、BETWEEN\u0026hellip;AND\u0026hellip;、IN、IS NULL、IS NOT NULL、LIKE、RLIKE、REGEXP）、逻辑运算符（NOT、AND、OR、XOR）和位运算符（\u0026amp;、|、^、~、\u0026gt;\u0026gt;、\u0026lt;\u0026lt;），我们可以在DML中使用这些运算符处理数据。\n 在查询数据时，可以在SELECT语句及其子句（如WHERE子句、ORDER BY子句、HAVING子句等）中使用函数，这些函数包括字符串函数、数值函数、时间日期函数、流程函数等，如下面的表格所示。\n常用字符串函数。\n| 函数 | 功能 | | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; | | CONCAT | 将多个字符串连接成一个字符串 | | FORMAT | 将数值格式化成字符串并指定保留几位小数 | | FROM_BASE64 / TO_BASE64 | BASE64解码/编码 | | BIN / OCT / HEX | 将数值转换成二进制/八进制/十六进制字符串 | | LOCATE | 在字符串中查找一个子串的位置 | | LEFT / RIGHT | 返回一个字符串左边/右边指定长度的字符 | | LENGTH / CHAR_LENGTH | 返回字符串的长度以字节/字符为单位 | | LOWER / UPPER | 返回字符串的小写/大写形式 | | LPAD / RPAD | 如果字符串的长度不足，在字符串左边/右边填充指定的字符 | | LTRIM / RTRIM | 去掉字符串前面/后面的空格 | | ORD / CHAR | 返回字符对应的编码/返回编码对应的字符 | | STRCMP | 比较字符串，返回-1、0、1分别表示小于、等于、大于 | | SUBSTRING | 返回字符串指定范围的子串 |\n常用数值函数。\n| 函数 | 功能 | | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- | | ABS | 返回一个数的绝度值 | | CEILING / FLOOR | 返回一个数上取整/下取整的结果 | | CONV | 将一个数从一种进制转换成另一种进制 | | CRC32 | 计算循环冗余校验码 | | EXP / LOG / LOG2 / LOG10 | 计算指数/对数 | | POW | 求幂 | | RAND | 返回[0,1)范围的随机数 | | ROUND | 返回一个数四舍五入后的结果 | | SQRT | 返回一个数的平方根 | | TRUNCATE | 截断一个数到指定的精度 | | SIN / COS / TAN / COT / ASIN / ACOS / ATAN | 三角函数 |\n常用时间日期函数。\n| 函数 | 功能 | | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- | | CURDATE / CURTIME / NOW | 获取当前日期/时间/日期和时间 | | ADDDATE / SUBDATE | 将两个日期表达式相加/相减并返回结果 | | DATE / TIME | 从字符串中获取日期/时间 | | YEAR / MONTH / DAY | 从日期中获取年/月/日 | | HOUR / MINUTE / SECOND | 从时间中获取时/分/秒 | | DATEDIFF / TIMEDIFF | 返回两个时间日期表达式相差多少天/小时 | | MAKEDATE / MAKETIME | 制造一个日期/时间 |\n常用流程函数。\n| 函数 | 功能 | | \u0026mdash;\u0026mdash; | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; | | IF | 根据条件是否成立返回不同的值 | | IFNULL | 如果为NULL则返回指定的值否则就返回本身 | | NULLIF | 两个表达式相等就返回NULL否则返回第一个表达式的值 |\n其他常用函数。\n| 函数 | 功能 | | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; | | MD5 / SHA1 / SHA2 | 返回字符串对应的哈希摘要 | | CHARSET / COLLATION | 返回字符集/校对规则 | | USER / CURRENT_USER | 返回当前用户 | | DATABASE | 返回当前数据库名 | | VERSION | 返回当前数据库版本 | | FOUND_ROWS / ROW_COUNT | 返回查询到的行数/受影响的行数 | | LAST_INSERT_ID | 返回最后一个自增主键的值 | | UUID / UUID_SHORT | 返回全局唯一标识符 |\n DCL\n-- 创建可以远程登录的root账号并为其指定口令 create user \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39; identified by \u0026#39;123456\u0026#39;; -- 为远程登录的root账号授权操作所有数据库所有对象的所有权限并允许其将权限再次赋予其他用户 grant all privileges on *.* to \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39; with grant option; -- 创建名为hellokitty的用户并为其指定口令 create user \u0026#39;hellokitty\u0026#39;@\u0026#39;%\u0026#39; identified by \u0026#39;123123\u0026#39;; -- 将对school数据库所有对象的所有操作权限授予hellokitty grant all privileges on school.* to \u0026#39;hellokitty\u0026#39;@\u0026#39;%\u0026#39;; -- 召回hellokitty对school数据库所有对象的insert/delete/update权限 revoke insert, delete, update on school.* from \u0026#39;hellokitty\u0026#39;@\u0026#39;%\u0026#39;;   说明：创建一个可以允许任意主机登录并且具有超级管理员权限的用户在现实中并不是一个明智的决定，因为一旦该账号的口令泄露或者被破解，数据库将会面临灾难级的风险。\n 索引 索引是关系型数据库中用来提升查询性能最为重要的手段。关系型数据库中的索引就像一本书的目录，我们可以想象一下，如果要从一本书中找出某个知识点，但是这本书没有目录，这将是意见多么可怕的事情（我们估计得一篇一篇的翻下去，才能确定这个知识点到底在什么位置）。创建索引虽然会带来存储空间上的开销，就像一本书的目录会占用一部分的篇幅一样，但是在牺牲空间后换来的查询时间的减少也是非常显著的。\nMySQL中，所有数据类型的列都可以被索引，常用的存储引擎InnoDB和MyISAM能支持每个表创建16个索引。InnoDB和MyISAM使用的索引其底层算法是B-tree（B树），B-tree是一种自平衡的树，类似于平衡二叉排序树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的操作都在对数时间内完成。\n接下来我们通过一个简单的例子来说明索引的意义，比如我们要根据学生的姓名来查找学生，这个场景在实际开发中应该经常遇到，就跟通过商品名称查找商品道理是一样的。我们可以使用MySQL的explain关键字来查看SQL的执行计划。\nexplain select * from tb_student where stuname=\u0026#39;林震南\u0026#39;\\G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: tb_student partitions: NULL type: ALL possible_keys: NULL key: NULL key_len: NULL ref: NULL rows: 11 filtered: 10.00 Extra: Using where 1 row in set, 1 warning (0.00 sec)  在上面的SQL执行计划中，有几项值得我们关注：\n type：MySQL在表中找到满足条件的行的方式，也称为访问类型，包括：ALL（全表扫描）、index（索引全扫描）、range（索引范围扫描）、ref（非唯一索引扫描）、eq_ref（唯一索引扫描）、const/system、NULL。在所有的访问类型中，很显然ALL是性能最差的，它代表了全表扫描是指要扫描表中的每一行才能找到匹配的行。 possible_keys：MySQL可以选择的索引，但是有可能不会使用。 key：MySQL真正使用的索引。 rows：执行查询需要扫描的行数，这是一个预估值。  从上面的执行计划可以看出，当我们通过学生名字查询学生时实际上是进行了全表扫描，不言而喻这个查询性能肯定是非常糟糕的，尤其是在表中的行很多的时候。如果我们需要经常通过学生姓名来查询学生，那么就应该在学生姓名对应的列上创建索引，通过索引来加速查询。\ncreate index idx_student_name on tb_student(stuname); 再次查看刚才的SQL对应的执行计划。\nexplain select * from tb_student where stuname=\u0026#39;林震南\u0026#39;\\G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: tb_student partitions: NULL type: ref possible_keys: idx_student_name key: idx_student_name key_len: 62 ref: const rows: 1 filtered: 100.00 Extra: NULL 1 row in set, 1 warning (0.00 sec)  可以注意到，在对学生姓名创建索引后，刚才的查询已经不是全表扫描而是基于索引的查询，而且扫描的行只有唯一的一行，这显然大大的提升了查询的性能。MySQL中还允许创建前缀索引，即对索引字段的前N个字符创建索引，这样的话可以减少索引占用的空间（但节省了空间很有可能会浪费时间，时间和空间是不可调和的矛盾），如下所示。\ncreate index idx_student_name_1 on tb_student(stuname(1)); 上面的索引相当于是根据学生姓名的第一个字来创建的索引，我们再看看SQL执行计划。\nexplain select * from tb_student where stuname=\u0026#39;林震南\u0026#39;\\G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: tb_student partitions: NULL type: ref possible_keys: idx_student_name key: idx_student_name key_len: 5 ref: const rows: 2 filtered: 100.00 Extra: Using where 1 row in set, 1 warning (0.00 sec)  不知道大家是否注意到，这一次扫描的行变成了2行，因为学生表中有两个姓“林”的学生，我们只用姓名的第一个字作为索引的话，在查询时通过索引就会找到这两行。\n如果要删除索引，可以使用下面的SQL。\nalter table tb_student drop index idx_student_name; 或者\ndrop index idx_student_name on tb_student; 我们简单的为大家总结一下索引的设计原则：\n 最适合索引的列是出现在WHERE子句和连接子句中的列。 索引列的基数越大（取值多重复值少），索引的效果就越好。 使用前缀索引可以减少索引占用的空间，内存中可以缓存更多的索引。 索引不是越多越好，虽然索引加速了读操作（查询），但是写操作（增、删、改）都会变得更慢，因为数据的变化会导致索引的更新，就如同书籍章节的增删需要更新目录一样。 使用InnoDB存储引擎时，表的普通索引都会保存主键的值，所以主键要尽可能选择较短的数据类型，这样可以有效的减少索引占用的空间，利用提升索引的缓存效果。  最后，还有一点需要说明，InnoDB使用的B-tree索引，数值类型的列除了等值判断时索引会生效之外，使用\u0026gt;、\u0026lt;、\u0026gt;=、\u0026lt;=、BETWEEN\u0026hellip;AND\u0026hellip; 、\u0026lt;\u0026gt;时，索引仍然生效；对于字符串类型的列，如果使用不以通配符开头的模糊查询，索引也是起作用的，但是其他的情况会导致索引失效，这就意味着很有可能会做全表查询。\n视图 视图是关系型数据库中将一组查询指令构成的结果集组合成可查询的数据表的对象。简单的说，视图就是虚拟的表，但与数据表不同的是，数据表是一种实体结构，而视图是一种虚拟结构，你也可以将视图理解为保存在数据库中被赋予名字的SQL语句。\n使用视图可以获得以下好处：\n 可以将实体数据表隐藏起来，让外部程序无法得知实际的数据结构，让访问者可以使用表的组成部分而不是整个表，降低数据库被攻击的风险。 在大多数的情况下视图是只读的（更新视图的操作通常都有诸多的限制），外部程序无法直接透过视图修改数据。 重用SQL语句，将高度复杂的查询包装在视图表中，直接访问该视图即可取出需要的数据；也可以将视图视为数据表进行连接查询。 视图可以返回与实体数据表不同格式的数据，  创建视图。\ncreate view vw_score as select sid, round(avg(score), 1) as avgscore from tb_record group by sid; create view vw_student_score as select stuname, avgscore from tb_student, vw_score where stuid=sid;  提示：因为视图不包含数据，所以每次使用视图时，都必须执行查询以获得数据，如果你使用了连接查询、嵌套查询创建了较为复杂的视图，你可能会发现查询性能下降得很厉害。因此，在使用复杂的视图前，应该进行测试以确保其性能能够满足应用的需求。\n 使用视图。\nselect stuname, avgscore from vw_student_score order by avgscore desc; +--------------+----------+ | stuname | avgscore | +--------------+----------+ | 杨过 | 95.6 | | 任我行 | 53.5 | | 王语嫣 | 84.3 | | 纪嫣然 | 73.8 | | 岳不群 | 78.0 | | 东方不败 | 88.0 | | 项少龙 | 92.0 | +--------------+----------+  既然视图是一张虚拟的表，那么视图的中的数据可以更新吗？视图的可更新性要视具体情况而定，以下类型的视图是不能更新的：\n 使用了聚合函数（SUM、MIN、MAX、AVG、COUNT等）、DISTINCT、GROUP BY、HAVING、UNION或者UNION ALL的视图。 SELECT中包含了子查询的视图。 FROM子句中包含了一个不能更新的视图的视图。 WHERE子句的子查询引用了FROM子句中的表的视图。  删除视图。\ndrop view vw_student_score;  说明：如果希望更新视图，可以先用上面的命令删除视图，也可以通过create or replace view来更新视图。\n 视图的规则和限制。\n 视图可以嵌套，可以利用从其他视图中检索的数据来构造一个新的视图。视图也可以和表一起使用。 创建视图时可以使用order by子句，但如果从视图中检索数据时也使用了order by，那么该视图中原先的order by会被覆盖。 视图无法使用索引，也不会激发触发器（实际开发中因为性能等各方面的考虑，通常不建议使用触发器，所以我们也不对这个概念进行介绍）的执行。  存储过程 存储过程是事先编译好存储在数据库中的一组SQL的集合，调用存储过程可以简化应用程序开发人员的工作，减少与数据库服务器之间的通信，对于提升数据操作的性能也是有帮助的。其实迄今为止，我们使用的SQL语句都是针对一个或多个表的单条语句，但在实际开发中经常会遇到某个操作需要多条SQL语句才能完成的情况。例如，电商网站在受理用户订单时，需要做以下一系列的处理。\n 通过查询来核对库存中是否有对应的物品以及库存是否充足。 如果库存有物品，需要锁定库存以确保这些物品不再卖给别人， 并且要减少可用的物品数量以反映正确的库存量。 如果库存不足，可能需要进一步与供应商进行交互或者至少产生一条系统提示消息。 不管受理订单是否成功，都需要产生流水记录，而且需要给对应的用户产生一条通知信息。  我们可以通过存储过程将复杂的操作封装起来，这样不仅有助于保证数据的一致性，而且将来如果业务发生了变动，只需要调整和修改存储过程即可。对于调用存储过程的用户来说，存储过程并没有暴露数据表的细节，而且执行存储过程比一条条的执行一组SQL要快得多。\n下面的存储过程实现了查询某门课程的最高分、最低分和平均分。\ndelimiter $$ create procedure sp_get_score(courseId int, out maxScore decimal(4,1), out minScore decimal(4,1), out avgScore decimal(4,1)) begin select max(score) into maxScore from tb_record where cid=courseId; select min(score) into minScore from tb_record where cid=courseId; select avg(score) into avgScore from tb_record where cid=courseId; end $$ delimiter ;  说明：在定义存储过程时，因为可能需要书写多条SQL，而分隔这些SQL需要使用分号作为分隔符，如果这个时候，仍然用分号表示整段代码结束，那么定义存储过程的SQL就会出现错误，所以上面我们用delimiter $$将整段代码结束的标记定义为$$，那么代码中的分号将不再表示整段代码的结束，需要马上执行，整段代码在遇到end $$时才输入完成并执行。在定义完存储过程后，通过delimiter ;将结束符重新改回成分号。\n 上面定义的存储过程有四个参数，其中第一个参数是输入参数，代表课程的编号，后面的参数都是输出参数，因为存储过程不能定义返回值，只能通过输出参数将执行结果带出，定义输出参数的关键字是out，默认情况下参数都是输入参数。\n调用存储过程。\ncall sp_get_score(1111, @a, @b, @c); 获取输出参数的值。\nselect @a as 最高分, @b as 最低分, @c as 平均分; 删除存储过程。\ndrop procedure sp_get_score; 在存储过程中，我们可以定义变量、条件，可以使用分支和循环语句，可以通过游标操作查询结果，还可以使用事件调度器，这些内容我们暂时不在此处进行介绍。虽然我们说了很多存储过程的好处，但是在实际开发中，如果过度的使用存储过程，将大量复杂的运算放到存储过程中，也会导致占用数据库服务器的CPU资源，造成数据库服务器承受巨大的压力。为此，我们一般会将复杂的运算和处理交给应用服务器，因为很容易部署多台应用服务器来分摊这些压力。\n几个重要的概念 范式理论 - 设计二维表的指导思想  第一范式：数据表的每个列的值域都是由原子值组成的，不能够再分割。 第二范式：数据表里的所有数据都要和该数据表的键（主键与候选键）有完全依赖关系。 第三范式：所有非键属性都只和候选键有相关性，也就是说非键属性之间应该是独立无关的。  数据完整性  实体完整性 - 每个实体都是独一无二的\n 主键（primary key） / 唯一约束 / 唯一索引（unique）  引用完整性（参照完整性）- 关系中不允许引用不存在的实体\n 外键（foreign key）  域完整性 - 数据是有效的\n 数据类型及长度\n 非空约束（not null）\n 默认值约束（default）\n 检查约束（check）\n   说明：在MySQL数据库中，检查约束并不起作用。\n  数据一致性  事务：一系列对数据库进行读/写的操作，这些操作要么全都成功，要么全都失败。\n 事务的ACID特性\n 原子性：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行 一致性：事务应确保数据库的状态从一个一致状态转变为另一个一致状态 隔离性：多个事务并发执行时，一个事务的执行不应影响其他事务的执行 持久性：已被提交的事务对数据库的修改应该永久保存在数据库中  MySQL中的事务操作\n 开启事务环境\nstart transaction  或\nbegin  提交事务\ncommit 回滚事务\nrollback   其他内容 大家应该能够想到，关于MySQL的知识肯定远远不止上面列出的这些，比如MySQL的性能优化、管理和维护MySQL的相关工具、MySQL数据的备份和恢复、监控MySQL、部署高可用架构等问题我们在这里都没有进行讨论。当然，这些内容也都是跟项目开发密切相关的，我们就留到后续的章节中再续点进行讲解。\nPython数据库编程 我们用如下所示的数据库来演示在Python中如何访问MySQL数据库。\ndrop database if exists hrs; create database hrs default charset utf8; use hrs; drop table if exists tb_emp; drop table if exists tb_dept; create table tb_dept ( dno int not null comment \u0026#39;编号\u0026#39;, dname varchar(10) not null comment \u0026#39;名称\u0026#39;, dloc varchar(20) not null comment \u0026#39;所在地\u0026#39;, primary key (dno) ); insert into tb_dept values (10, \u0026#39;会计部\u0026#39;, \u0026#39;北京\u0026#39;), (20, \u0026#39;研发部\u0026#39;, \u0026#39;成都\u0026#39;), (30, \u0026#39;销售部\u0026#39;, \u0026#39;重庆\u0026#39;), (40, \u0026#39;运维部\u0026#39;, \u0026#39;深圳\u0026#39;); create table tb_emp ( eno int not null comment \u0026#39;员工编号\u0026#39;, ename varchar(20) not null comment \u0026#39;员工姓名\u0026#39;, job varchar(20) not null comment \u0026#39;员工职位\u0026#39;, mgr int comment \u0026#39;主管编号\u0026#39;, sal int not null comment \u0026#39;员工月薪\u0026#39;, comm int comment \u0026#39;每月补贴\u0026#39;, dno int comment \u0026#39;所在部门编号\u0026#39;, primary key (eno) ); alter table tb_emp add constraint fk_emp_dno foreign key (dno) references tb_dept (dno); insert into tb_emp values (7800, \u0026#39;张三丰\u0026#39;, \u0026#39;总裁\u0026#39;, null, 9000, 1200, 20), (2056, \u0026#39;乔峰\u0026#39;, \u0026#39;分析师\u0026#39;, 7800, 5000, 1500, 20), (3088, \u0026#39;李莫愁\u0026#39;, \u0026#39;设计师\u0026#39;, 2056, 3500, 800, 20), (3211, \u0026#39;张无忌\u0026#39;, \u0026#39;程序员\u0026#39;, 2056, 3200, null, 20), (3233, \u0026#39;丘处机\u0026#39;, \u0026#39;程序员\u0026#39;, 2056, 3400, null, 20), (3251, \u0026#39;张翠山\u0026#39;, \u0026#39;程序员\u0026#39;, 2056, 4000, null, 20), (5566, \u0026#39;宋远桥\u0026#39;, \u0026#39;会计师\u0026#39;, 7800, 4000, 1000, 10), (5234, \u0026#39;郭靖\u0026#39;, \u0026#39;出纳\u0026#39;, 5566, 2000, null, 10), (3344, \u0026#39;黄蓉\u0026#39;, \u0026#39;销售主管\u0026#39;, 7800, 3000, 800, 30), (1359, \u0026#39;胡一刀\u0026#39;, \u0026#39;销售员\u0026#39;, 3344, 1800, 200, 30), (4466, \u0026#39;苗人凤\u0026#39;, \u0026#39;销售员\u0026#39;, 3344, 2500, null, 30), (3244, \u0026#39;欧阳锋\u0026#39;, \u0026#39;程序员\u0026#39;, 3088, 3200, null, 20), (3577, \u0026#39;杨过\u0026#39;, \u0026#39;会计\u0026#39;, 5566, 2200, null, 10), (3588, \u0026#39;朱九真\u0026#39;, \u0026#39;会计\u0026#39;, 5566, 2500, null, 10); 在Python 3中，我们通常使用纯Python的三方库PyMySQL来访问MySQL数据库，它应该是目前Python操作MySQL数据库最好的选择。\n 安装PyMySQL。\npip install pymysql 添加一个部门。\nimport pymysql def main(): no = int(input(\u0026#39;编号: \u0026#39;)) name = input(\u0026#39;名字: \u0026#39;) loc = input(\u0026#39;所在地: \u0026#39;) # 1. 创建数据库连接对象 con = pymysql.connect(host=\u0026#39;localhost\u0026#39;, port=3306, database=\u0026#39;hrs\u0026#39;, charset=\u0026#39;utf8\u0026#39;, user=\u0026#39;root\u0026#39;, password=\u0026#39;123456\u0026#39;) try: # 2. 通过连接对象获取游标 with con.cursor() as cursor: # 3. 通过游标执行SQL并获得执行结果 result = cursor.execute( \u0026#39;insert into tb_dept values (%s, %s, %s)\u0026#39;, (no, name, loc) ) if result == 1: print(\u0026#39;添加成功!\u0026#39;) # 4. 操作成功提交事务 con.commit() finally: # 5. 关闭连接释放资源 con.close() if __name__ == \u0026#39;__main__\u0026#39;: main() 删除一个部门。\nimport pymysql def main(): no = int(input(\u0026#39;编号: \u0026#39;)) con = pymysql.connect(host=\u0026#39;localhost\u0026#39;, port=3306, database=\u0026#39;hrs\u0026#39;, charset=\u0026#39;utf8\u0026#39;, user=\u0026#39;root\u0026#39;, password=\u0026#39;123456\u0026#39;, autocommit=True) try: with con.cursor() as cursor: result = cursor.execute( \u0026#39;delete from tb_dept where dno=%s\u0026#39;, (no, ) ) if result == 1: print(\u0026#39;删除成功!\u0026#39;) finally: con.close() if __name__ == \u0026#39;__main__\u0026#39;: main()   说明：如果不希望每次SQL操作之后手动提交或回滚事务，可以像上面的代码那样，在创建连接的时候多加一个名为autocommit的参数并将它的值设置为True，表示每次执行SQL之后自动提交。如果程序中不需要使用事务环境也不希望手动的提交或回滚就可以这么做。\n  更新一个部门。\nimport pymysql def main(): no = int(input(\u0026#39;编号: \u0026#39;)) name = input(\u0026#39;名字: \u0026#39;) loc = input(\u0026#39;所在地: \u0026#39;) con = pymysql.connect(host=\u0026#39;localhost\u0026#39;, port=3306, database=\u0026#39;hrs\u0026#39;, charset=\u0026#39;utf8\u0026#39;, user=\u0026#39;root\u0026#39;, password=\u0026#39;123456\u0026#39;, autocommit=True) try: with con.cursor() as cursor: result = cursor.execute( \u0026#39;update tb_dept set dname=%s, dloc=%swhere dno=%s\u0026#39;, (name, loc, no) ) if result == 1: print(\u0026#39;更新成功!\u0026#39;) finally: con.close() if __name__ == \u0026#39;__main__\u0026#39;: main() 查询所有部门。\nimport pymysql from pymysql.cursors import DictCursor def main(): con = pymysql.connect(host=\u0026#39;localhost\u0026#39;, port=3306, database=\u0026#39;hrs\u0026#39;, charset=\u0026#39;utf8\u0026#39;, user=\u0026#39;root\u0026#39;, password=\u0026#39;123456\u0026#39;) try: with con.cursor(cursor=DictCursor) as cursor: cursor.execute(\u0026#39;select dno as no, dname as name, dloc as loc from tb_dept\u0026#39;) results = cursor.fetchall() print(results) print(\u0026#39;编号\\t名称\\t\\t所在地\u0026#39;) for dept in results: print(dept[\u0026#39;no\u0026#39;], end=\u0026#39;\\t\u0026#39;) print(dept[\u0026#39;name\u0026#39;], end=\u0026#39;\\t\u0026#39;) print(dept[\u0026#39;loc\u0026#39;]) finally: con.close() if __name__ == \u0026#39;__main__\u0026#39;: main() 分页查询员工信息。\nimport pymysql from pymysql.cursors import DictCursor class Emp(object): def __init__(self, no, name, job, sal): self.no = no self.name = name self.job = job self.sal = sal def __str__(self): return f\u0026#39;\\n编号：{self.no}\\n姓名：{self.name}\\n职位：{self.job}\\n月薪：{self.sal}\\n\u0026#39; def main(): page = int(input(\u0026#39;页码: \u0026#39;)) size = int(input(\u0026#39;大小: \u0026#39;)) con = pymysql.connect(host=\u0026#39;localhost\u0026#39;, port=3306, database=\u0026#39;hrs\u0026#39;, charset=\u0026#39;utf8\u0026#39;, user=\u0026#39;root\u0026#39;, password=\u0026#39;123456\u0026#39;) try: with con.cursor() as cursor: cursor.execute( \u0026#39;select eno as no, ename as name, job, sal from tb_emp limit %s,%s\u0026#39;, ((page - 1) * size, size) ) for emp_tuple in cursor.fetchall(): emp = Emp(*emp_tuple) print(emp) finally: con.close() if __name__ == \u0026#39;__main__\u0026#39;: main()  "},{"idx":30,"href":"/python100days/docs/Day36-40/39-40-NoSQL%E5%85%A5%E9%97%A8/","title":"39 40 No S Q L入门","content":" NoSQL入门 NoSQL概述 如今，大多数的计算机系统（包括服务器、PC、移动设备等）都会产生庞大的数据量。其实，早在2012年的时候，全世界每天产生的数据量就达到了2.5EB（艾字节，$$1EB\\approx10^{18}B$$）。这些数据有很大一部分是由关系型数据库来存储和管理的。 早在1970年，E.F.Codd发表了论述关系型数据库的著名论文“*A relational model of data for large shared data banks*”，这篇文章奠定了关系型数据库的基础并在接下来的数十年时间内产生了深远的影响。实践证明，关系型数据库是实现数据持久化最为重要的方式，它也是大多数应用在选择持久化方案时的首选技术。\nNoSQL是一项全新的数据库革命性运动，虽然它的历史可以追溯到1998年，但是NoSQL真正深入人心并得到广泛的应用是在进入大数据时候以后，业界普遍认为NoSQL是更适合大数据存储的技术方案，这才使得NoSQL的发展达到了前所未有的高度。2012年《纽约时报》的一篇专栏中写到，大数据时代已经降临，在商业、经济及其他领域中，决策将不再基于经验和直觉而是基于数据和分析而作出。事实上，在天文学、气象学、基因组学、生物学、社会学、互联网搜索引擎、金融、医疗、社交网络、电子商务等诸多领域，由于数据过于密集和庞大，在数据的分析和处理上也遇到了前所未有的限制和阻碍，这一切都使得对大数据处理技术的研究被提升到了新的高度，也使得各种NoSQL的技术方案进入到了公众的视野。\nNoSQL数据库按照其存储类型可以大致分为以下几类：\n   类型 部分代表 特点     列族数据库 HBase\nCassandra\nHypertable 顾名思义是按列存储数据的。最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，对针对某一列或者某几列的查询有非常大的I/O优势，适合于批量数据处理和即时查询。   文档数据库 MongoDB\nCouchDB\nElasticSearch 文档数据库一般用类JSON格式存储数据，存储的内容是文档型的。这样也就有机会对某些字段建立索引，实现关系数据库的某些功能，但不提供对参照完整性和分布事务的支持。   KV数据库 DynamoDB\nRedis\nLevelDB 可以通过key快速查询到其value，有基于内存和基于磁盘两种实现方案。   图数据库 Neo4J\nFlockDB\nJanusGraph 使用图结构进行语义查询的数据库，它使用节点、边和属性来表示和存储数据。图数据库从设计上，就可以简单快速的检索难以在关系系统中建模的复杂层次结构。   对象数据库 db4o\nVersant 通过类似面向对象语言的语法操作数据库，通过对象的方式存取数据。     说明：想了解更多的NoSQL数据库，可以访问http://nosql-database.org/。\n Redis概述 Redis是一种基于键值对的NoSQL数据库，它提供了对多种数据类型（字符串、哈希、列表、集合、有序集合、位图等）的支持，能够满足很多应用场景的需求。Redis将数据放在内存中，因此读写性能是非常惊人的。与此同时，Redis也提供了持久化机制，能够将内存中的数据保存到硬盘上，在发生意外状况时数据也不会丢掉。此外，Redis还支持键过期、地理信息运算、发布订阅、事务、管道、Lua脚本扩展等功能，总而言之，Redis的功能和性能都非常强大，如果项目中要实现高速缓存和消息队列这样的服务，直接交给Redis就可以了。目前，国内外很多著名的企业和商业项目都使用了Redis，包括：Twitter、Github、StackOverflow、新浪微博、百度、优酷土豆、美团、小米、唯品会等。\nRedis简介 2008年，一个名为Salvatore Sanfilippo的程序员为他开发的LLOOGG项目定制了专属的数据库（因为之前他无论怎样优化MySQL，系统性能已经无法再提升了），这项工作的成果就是Redis的初始版本。后来他将Redis的代码放到了全球最大的代码托管平台Github，从那以后，Redis引发了大量开发者的好评和关注，继而有数百人参与了Redis的开发和维护，这使得Redis的功能越来越强大和性能越来越好。\nRedis是REmote DIctionary Server的缩写，它是一个用ANSI C编写的高性能的key-value存储系统，与其他的key-value存储系统相比，Redis有以下一些特点（也是优点）：\n Redis的读写性能极高，并且有丰富的特性（发布/订阅、事务、通知等）。 Redis支持数据的持久化（RDB和AOF两种方式），可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis支持多种数据类型，包括：string、hash、list、set，zset、bitmap、hyperloglog等。 Redis支持主从复制（实现读写分析）以及哨兵模式（监控master是否宕机并自动调整配置）。 Redis支持分布式集群，可以很容易的通过水平扩展来提升系统的整体性能。 Redis基于TCP提供的可靠传输服务进行通信，很多编程语言都提供了Redis客户端支持。  Redis的应用场景  高速缓存 - 将不常变化但又经常被访问的热点数据放到Redis数据库中，可以大大降低关系型数据库的压力，从而提升系统的响应性能。 排行榜 - 很多网站都有排行榜功能，利用Redis中的列表和有序集合可以非常方便的构造各种排行榜系统。 商品秒杀/投票点赞 - Redis提供了对计数操作的支持，网站上常见的秒杀、点赞等功能都可以利用Redis的计数器通过+1或-1的操作来实现，从而避免了使用关系型数据的update操作。 分布式锁 - 利用Redis可以跨多台服务器实现分布式锁（类似于线程锁，但是能够被多台机器上的多个线程或进程共享）的功能，用于实现一个阻塞式操作。 消息队列 - 消息队列和高速缓存一样，是一个大型网站不可缺少的基础服务，可以实现业务解耦和非实时业务削峰等特性，这些我们都会在后面的项目中为大家展示。  Redis的安装和配置 可以使用Linux系统的包管理工具（如yum）来安装Redis，也可以通过在Redis的官方网站下载Redis的源代码，解压缩解归档之后通过make工具对源代码进行构建并安装，在更新这篇文档时，Redis官方提供的最新稳定版本是Redis 5.0.4。\nwget http://download.redis.io/releases/redis-5.0.4.tar.gz gunzip redis-5.0.4.tar.gz tar -xvf redis-5.0.4.tar cd redis-5.0.4 make \u0026amp;\u0026amp; make install 在redis源代码目录下有一个名为redis.conf的配置文件，我们可以先查看一下该文件。\nvim redis.conf 配置将Redis服务绑定到指定的IP地址和端口。\n配置底层有多少个数据库。\n配置Redis的持久化机制 - RDB。\n配置Redis的持久化机制 - AOF。\n配置访问Redis服务器的验证口令。\n配置Redis的主从复制，通过主从复制可以实现读写分离。\n配置慢查询。\n上面这些内容就是Redis的基本配置，如果你对上面的内容感到困惑也没有关系，先把Redis用起来再回头去推敲这些内容就行了。如果想找一些参考书，《Redis开发与运维》是一本不错的入门读物，而《Redis实战》是不错的进阶读物。\nRedis的服务器和客户端 接下来启动Redis服务器，下面的方式将以默认的配置启动Redis服务。\nredis-server 如果希望修改Redis的配置（如端口、认证口令、持久化方式等），可以通过下面两种方式。\n方式一：通过参数指定认证口令和AOF持久化方式。\nredis-server --requirepass 1qaz2wsx --appendonly yes 方式二：通过指定的配置文件来修改Redis的配置。\nredis-server /root/redis-5.0.4/redis.conf 下面我们使用第一种方式来启动Redis并将其置于后台运行，将Redis产生的输出重定向到名为redis.log的文件中。\nredis-server --requirepass 1qaz2wsx \u0026gt; redis.log \u0026amp; 可以通过ps或者netstat来检查Redis服务器是否启动成功。\nps -ef | grep redis-server netstat -nap | grep redis-server 接下来，我们尝试用Redis客户端去连接服务器。\nredis-cli 127.0.0.1:6379\u0026gt; auth 1qaz2wsx OK 127.0.0.1:6379\u0026gt; ping PONG 127.0.0.1:6379\u0026gt; Redis有着非常丰富的数据类型，也有很多的命令来操作这些数据，具体的内容可以查看Redis命令参考，在这个网站上，除了Redis的命令参考，还有Redis的详细文档，其中包括了通知、事务、主从复制、持久化、哨兵、集群等内容。\n 说明：上面的插图来自付磊和张益军先生编著的《Redis开发与运维》一书。\n 127.0.0.1:6379\u0026gt; set username admin OK 127.0.0.1:6379\u0026gt; get username \u0026#34;admin\u0026#34; 127.0.0.1:6379\u0026gt; set password \u0026#34;123456\u0026#34; ex 300 OK 127.0.0.1:6379\u0026gt; get password \u0026#34;123456\u0026#34; 127.0.0.1:6379\u0026gt; ttl username (integer) -1 127.0.0.1:6379\u0026gt; ttl password (integer) 286 127.0.0.1:6379\u0026gt; hset stu1 name hao (integer) 0 127.0.0.1:6379\u0026gt; hset stu1 age 38 (integer) 1 127.0.0.1:6379\u0026gt; hset stu1 gender male (integer) 1 127.0.0.1:6379\u0026gt; hgetall stu1 1) \u0026#34;name\u0026#34; 2) \u0026#34;hao\u0026#34; 3) \u0026#34;age\u0026#34; 4) \u0026#34;38\u0026#34; 5) \u0026#34;gender\u0026#34; 6) \u0026#34;male\u0026#34; 127.0.0.1:6379\u0026gt; hvals stu1 1) \u0026#34;hao\u0026#34; 2) \u0026#34;38\u0026#34; 3) \u0026#34;male\u0026#34; 127.0.0.1:6379\u0026gt; hmset stu2 name wang age 18 gender female tel 13566778899 OK 127.0.0.1:6379\u0026gt; hgetall stu2 1) \u0026#34;name\u0026#34; 2) \u0026#34;wang\u0026#34; 3) \u0026#34;age\u0026#34; 4) \u0026#34;18\u0026#34; 5) \u0026#34;gender\u0026#34; 6) \u0026#34;female\u0026#34; 7) \u0026#34;tel\u0026#34; 8) \u0026#34;13566778899\u0026#34; 127.0.0.1:6379\u0026gt; lpush nums 1 2 3 4 5 (integer) 5 127.0.0.1:6379\u0026gt; lrange nums 0 -1 1) \u0026#34;5\u0026#34; 2) \u0026#34;4\u0026#34; 3) \u0026#34;3\u0026#34; 4) \u0026#34;2\u0026#34; 5) \u0026#34;1\u0026#34; 127.0.0.1:6379\u0026gt; lpop nums \u0026#34;5\u0026#34; 127.0.0.1:6379\u0026gt; lpop nums \u0026#34;4\u0026#34; 127.0.0.1:6379\u0026gt; rpop nums \u0026#34;1\u0026#34; 127.0.0.1:6379\u0026gt; rpop nums \u0026#34;2\u0026#34; 127.0.0.1:6379\u0026gt; sadd fruits apple banana orange apple grape grape (integer) 4 127.0.0.1:6379\u0026gt; scard fruits (integer) 4 127.0.0.1:6379\u0026gt; smembers fruits 1) \u0026#34;grape\u0026#34; 2) \u0026#34;orange\u0026#34; 3) \u0026#34;banana\u0026#34; 4) \u0026#34;apple\u0026#34; 127.0.0.1:6379\u0026gt; sismember fruits apple (integer) 1 127.0.0.1:6379\u0026gt; sismember fruits durian (integer) 0 127.0.0.1:6379\u0026gt; sadd nums1 1 2 3 4 5 (integer) 5 127.0.0.1:6379\u0026gt; sadd nums2 2 4 6 8 (integer) 4 127.0.0.1:6379\u0026gt; sinter nums1 nums2 1) \u0026#34;2\u0026#34; 2) \u0026#34;4\u0026#34; 127.0.0.1:6379\u0026gt; sunion nums1 nums2 1) \u0026#34;1\u0026#34; 2) \u0026#34;2\u0026#34; 3) \u0026#34;3\u0026#34; 4) \u0026#34;4\u0026#34; 5) \u0026#34;5\u0026#34; 6) \u0026#34;6\u0026#34; 7) \u0026#34;8\u0026#34; 127.0.0.1:6379\u0026gt; sdiff nums1 nums2 1) \u0026#34;1\u0026#34; 2) \u0026#34;3\u0026#34; 3) \u0026#34;5\u0026#34; 127.0.0.1:6379\u0026gt; zadd topsinger 5234 zhangxy 1978 chenyx 2235 zhoujl 3520 xuezq (integer) 4 127.0.0.1:6379\u0026gt; zrange topsinger 0 -1 withscores 1) \u0026#34;chenyx\u0026#34; 2) \u0026#34;1978\u0026#34; 3) \u0026#34;zhoujl\u0026#34; 4) \u0026#34;2235\u0026#34; 5) \u0026#34;xuezq\u0026#34; 6) \u0026#34;3520\u0026#34; 7) \u0026#34;zhangxy\u0026#34; 8) \u0026#34;5234\u0026#34; 127.0.0.1:6379\u0026gt; zrevrange topsinger 0 -1 1) \u0026#34;zhangxy\u0026#34; 2) \u0026#34;xuezq\u0026#34; 3) \u0026#34;zhoujl\u0026#34; 4) \u0026#34;chenyx\u0026#34; 127.0.0.1:6379\u0026gt; geoadd pois 116.39738549206541 39.90862689286386 tiananmen 116.27172936413572 39.99 135172904494 yiheyuan 117.27766503308104 40.65332064313784 gubeishuizhen (integer) 3 127.0.0.1:6379\u0026gt; geodist pois tiananmen gubeishuizhen km \u0026#34;111.5333\u0026#34; 127.0.0.1:6379\u0026gt; geodist pois tiananmen yiheyuan km \u0026#34;14.1230\u0026#34; 127.0.0.1:6379\u0026gt; georadius pois 116.86499108288572 40.40149669363615 50 km withdist 1) 1) \u0026#34;gubeishuizhen\u0026#34; 2) \u0026#34;44.7408\u0026#34; 在Python程序中使用Redis 可以使用pip安装redis模块。redis模块的核心是名为Redis的类，该类的对象代表一个Redis客户端，通过该客户端可以向Redis服务器发送命令并获取执行的结果。上面我们在Redis客户端中使用的命令基本上就是Redis对象可以接收的消息，所以如果了解了Redis的命令就可以在Python中玩转Redis。\npip3 install redis python3\u0026gt;\u0026gt;\u0026gt; import redis \u0026gt;\u0026gt;\u0026gt; client = redis.Redis(host=\u0026#39;1.2.3.4\u0026#39;, port=6379, password=\u0026#39;1qaz2wsx\u0026#39;) \u0026gt;\u0026gt;\u0026gt; client.set(\u0026#39;username\u0026#39;, \u0026#39;admin\u0026#39;) True \u0026gt;\u0026gt;\u0026gt; client.hset(\u0026#39;student\u0026#39;, \u0026#39;name\u0026#39;, \u0026#39;hao\u0026#39;) 1 \u0026gt;\u0026gt;\u0026gt; client.hset(\u0026#39;student\u0026#39;, \u0026#39;age\u0026#39;, 38) 1 \u0026gt;\u0026gt;\u0026gt; client.keys(\u0026#39;*\u0026#39;) [b\u0026#39;username\u0026#39;, b\u0026#39;student\u0026#39;] \u0026gt;\u0026gt;\u0026gt; client.get(\u0026#39;username\u0026#39;) b\u0026#39;admin\u0026#39; \u0026gt;\u0026gt;\u0026gt; client.hgetall(\u0026#39;student\u0026#39;) {b\u0026#39;name\u0026#39;: b\u0026#39;hao\u0026#39;, b\u0026#39;age\u0026#39;: b\u0026#39;38\u0026#39;} MongoDB概述 MongoDB简介 MongoDB是2009年问世的一个面向文档的数据库管理系统，由C++语言编写，旨在为Web应用提供可扩展的高性能数据存储解决方案。虽然在划分类别的时候后，MongoDB被认为是NoSQL的产品，但是它更像一个介于关系数据库和非关系数据库之间的产品，在非关系数据库中它功能最丰富，最像关系数据库。\nMongoDB将数据存储为一个文档，一个文档由一系列的“键值对”组成，其文档类似于JSON对象，但是MongoDB对JSON进行了二进制处理（能够更快的定位key和value），因此其文档的存储格式称为BSON。关于JSON和BSON的差别大家可以看看MongoDB官方网站的文章《JSON and BSON》。\n目前，MongoDB已经提供了对Windows、MacOS、Linux、Solaris等多个平台的支持，而且也提供了多种开发语言的驱动程序，Python当然是其中之一。\nMongoDB的安装和配置 可以从MongoDB的官方下载链接下载MongoDB，官方为Windows系统提供了一个Installer程序，而Linux和MacOS则提供了压缩文件。下面简单说一下Linux系统如何安装和配置MongoDB。\nwget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-amazon-3.6.5.tgz gunzip mongodb-linux-x86_64-amazon-3.6.5.tgz mkdir mongodb-3.6.5 tar -xvf mongodb-linux-x86_64-amazon-3.6.5.tar --strip-components 1 -C mongodb-3.6.5/ export PATH=$PATH:~/mongodb-3.6.5/bin mkdir -p /data/db mongod --bind_ip 172.18.61.250 2018-06-03T18:03:28.232+0800 I CONTROL [initandlisten] MongoDB starting : pid=1163 port=27017 dbpath=/data/db 64-bit host=iZwz97tbgo9lkabnat2lo8Z 2018-06-03T18:03:28.232+0800 I CONTROL [initandlisten] db version v3.6.5 2018-06-03T18:03:28.232+0800 I CONTROL [initandlisten] git version: a20ecd3e3a174162052ff99913bc2ca9a839d618 2018-06-03T18:03:28.232+0800 I CONTROL [initandlisten] OpenSSL version: OpenSSL 1.0.0-fips29 Mar 2010 ... 2018-06-03T18:03:28.945+0800 I NETWORK [initandlisten] waiting for connections on port 27017  说明：上面的操作中，export命令是设置PATH环境变量，这样可以在任意路径下执行mongod来启动MongoDB服务器。MongoDB默认保存数据的路径是/data/db目录，为此要提前创建该目录。此外，在使用mongod启动MongoDB服务器时，\u0026ndash;bind_ip参数用来将服务绑定到指定的IP地址，也可以用\u0026ndash;port参数来指定端口，默认端口为27017。\n MongoDB基本概念 我们通过与关系型数据库进行对照的方式来说明MongoDB中的一些概念。\n   SQL MongoDB 解释（SQL/MongoDB）     database database 数据库/数据库   table collection 二维表/集合   row document 记录（行）/文档   column field 字段（列）/域   index index 索引/索引   table joins \u0026mdash; 表连接/嵌套文档   primary key primary key 主键/主键（_id字段）    通过Shell操作MongoDB 启动服务器后可以使用交互式环境跟服务器通信，如下所示。\nmongo --host 172.18.61.250 MongoDB shell version v3.6.5 connecting to: mongodb://172.18.61.250:27017/  查看、创建和删除数据库。\n\u0026gt; // 显示所有数据库 \u0026gt; show dbs admin 0.000GB config 0.000GB local 0.000GB \u0026gt; // 创建并切换到school数据库 \u0026gt; use school switched to db school \u0026gt; // 删除当前数据库 \u0026gt; db.dropDatabase() { \u0026#34;ok\u0026#34; : 1 } \u0026gt;  创建、删除和查看集合。\n\u0026gt; // 创建并切换到school数据库 \u0026gt; use school switched to db school \u0026gt; // 创建colleges集合 \u0026gt; db.createCollection(\u0026#39;colleges\u0026#39;) { \u0026#34;ok\u0026#34; : 1 } \u0026gt; // 创建students集合 \u0026gt; db.createCollection(\u0026#39;students\u0026#39;) { \u0026#34;ok\u0026#34; : 1 } \u0026gt; // 查看所有集合 \u0026gt; show collections colleges students \u0026gt; // 删除colleges集合 \u0026gt; db.colleges.drop() true \u0026gt;    说明：在MongoDB中插入文档时如果集合不存在会自动创建集合，所以也可以按照下面的方式通过创建文档来创建集合。\n  文档的CRUD操作。\n\u0026gt; // 向students集合插入文档 \u0026gt; db.students.insert({stuid: 1001, name: \u0026#39;骆昊\u0026#39;, age: 38}) WriteResult({ \u0026#34;nInserted\u0026#34; : 1 }) \u0026gt; // 向students集合插入文档 \u0026gt; db.students.save({stuid: 1002, name: \u0026#39;王大锤\u0026#39;, tel: \u0026#39;13012345678\u0026#39;, gender: \u0026#39;男\u0026#39;}) WriteResult({ \u0026#34;nInserted\u0026#34; : 1 }) \u0026gt; // 查看所有文档 \u0026gt; db.students.find() { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5b13c72e006ad854460ee70b\u0026#34;), \u0026#34;stuid\u0026#34; : 1001, \u0026#34;name\u0026#34; : \u0026#34;骆昊\u0026#34;, \u0026#34;age\u0026#34; : 38 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5b13c790006ad854460ee70c\u0026#34;), \u0026#34;stuid\u0026#34; : 1002, \u0026#34;name\u0026#34; : \u0026#34;王大锤\u0026#34;, \u0026#34;tel\u0026#34; : \u0026#34;13012345678\u0026#34;, \u0026#34;gender\u0026#34; : \u0026#34;男\u0026#34; } \u0026gt; // 更新stuid为1001的文档 \u0026gt; db.students.update({stuid: 1001}, {\u0026#39;$set\u0026#39;: {tel: \u0026#39;13566778899\u0026#39;, gender: \u0026#39;男\u0026#39;}}) WriteResult({ \u0026#34;nMatched\u0026#34; : 1, \u0026#34;nUpserted\u0026#34; : 0, \u0026#34;nModified\u0026#34; : 1 }) \u0026gt; // 插入或更新stuid为1003的文档 \u0026gt; db.students.update({stuid: 1003}, {\u0026#39;$set\u0026#39;: {name: \u0026#39;白元芳\u0026#39;, tel: \u0026#39;13022223333\u0026#39;, gender: \u0026#39;男\u0026#39;}}, upsert=true) WriteResult({ \u0026#34;nMatched\u0026#34; : 0, \u0026#34;nUpserted\u0026#34; : 1, \u0026#34;nModified\u0026#34; : 0, \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5b13c92dd185894d7283efab\u0026#34;) }) \u0026gt; // 查询所有文档 \u0026gt; db.students.find().pretty() { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5b13c72e006ad854460ee70b\u0026#34;), \u0026#34;stuid\u0026#34; : 1001, \u0026#34;name\u0026#34; : \u0026#34;骆昊\u0026#34;, \u0026#34;age\u0026#34; : 38, \u0026#34;gender\u0026#34; : \u0026#34;男\u0026#34;, \u0026#34;tel\u0026#34; : \u0026#34;13566778899\u0026#34; } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5b13c790006ad854460ee70c\u0026#34;), \u0026#34;stuid\u0026#34; : 1002, \u0026#34;name\u0026#34; : \u0026#34;王大锤\u0026#34;, \u0026#34;tel\u0026#34; : \u0026#34;13012345678\u0026#34;, \u0026#34;gender\u0026#34; : \u0026#34;男\u0026#34; } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5b13c92dd185894d7283efab\u0026#34;), \u0026#34;stuid\u0026#34; : 1003, \u0026#34;gender\u0026#34; : \u0026#34;男\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;白元芳\u0026#34;, \u0026#34;tel\u0026#34; : \u0026#34;13022223333\u0026#34; } \u0026gt; // 查询stuid大于1001的文档 \u0026gt; db.students.find({stuid: {\u0026#39;$gt\u0026#39;: 1001}}).pretty() { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5b13c790006ad854460ee70c\u0026#34;), \u0026#34;stuid\u0026#34; : 1002, \u0026#34;name\u0026#34; : \u0026#34;王大锤\u0026#34;, \u0026#34;tel\u0026#34; : \u0026#34;13012345678\u0026#34;, \u0026#34;gender\u0026#34; : \u0026#34;男\u0026#34; } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5b13c92dd185894d7283efab\u0026#34;), \u0026#34;stuid\u0026#34; : 1003, \u0026#34;gender\u0026#34; : \u0026#34;男\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;白元芳\u0026#34;, \u0026#34;tel\u0026#34; : \u0026#34;13022223333\u0026#34; } \u0026gt; // 查询stuid大于1001的文档只显示name和tel字段 \u0026gt; db.students.find({stuid: {\u0026#39;$gt\u0026#39;: 1001}}, {_id: 0, name: 1, tel: 1}).pretty() { \u0026#34;name\u0026#34; : \u0026#34;王大锤\u0026#34;, \u0026#34;tel\u0026#34; : \u0026#34;13012345678\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;白元芳\u0026#34;, \u0026#34;tel\u0026#34; : \u0026#34;13022223333\u0026#34; } \u0026gt; // 查询name为“骆昊”或者tel为“13022223333”的文档 \u0026gt; db.students.find({\u0026#39;$or\u0026#39;: [{name: \u0026#39;骆昊\u0026#39;}, {tel: \u0026#39;13022223333\u0026#39;}]}, {_id: 0, name: 1, tel: 1}).pretty() { \u0026#34;name\u0026#34; : \u0026#34;骆昊\u0026#34;, \u0026#34;tel\u0026#34; : \u0026#34;13566778899\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;白元芳\u0026#34;, \u0026#34;tel\u0026#34; : \u0026#34;13022223333\u0026#34; } \u0026gt; // 查询学生文档跳过第1条文档只查1条文档 \u0026gt; db.students.find().skip(1).limit(1).pretty() { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;5b13c790006ad854460ee70c\u0026#34;), \u0026#34;stuid\u0026#34; : 1002, \u0026#34;name\u0026#34; : \u0026#34;王大锤\u0026#34;, \u0026#34;tel\u0026#34; : \u0026#34;13012345678\u0026#34;, \u0026#34;gender\u0026#34; : \u0026#34;男\u0026#34; } \u0026gt; // 对查询结果进行排序(1表示升序，-1表示降序) \u0026gt; db.students.find({}, {_id: 0, stuid: 1, name: 1}).sort({stuid: -1}) { \u0026#34;stuid\u0026#34; : 1003, \u0026#34;name\u0026#34; : \u0026#34;白元芳\u0026#34; } { \u0026#34;stuid\u0026#34; : 1002, \u0026#34;name\u0026#34; : \u0026#34;王大锤\u0026#34; } { \u0026#34;stuid\u0026#34; : 1001, \u0026#34;name\u0026#34; : \u0026#34;骆昊\u0026#34; } \u0026gt; // 在指定的一个或多个字段上创建索引 \u0026gt; db.students.ensureIndex({name: 1}) { \u0026#34;createdCollectionAutomatically\u0026#34; : false, \u0026#34;numIndexesBefore\u0026#34; : 1, \u0026#34;numIndexesAfter\u0026#34; : 2, \u0026#34;ok\u0026#34; : 1 } \u0026gt;   使用MongoDB可以非常方便的配置数据复制，通过冗余数据来实现数据的高可用以及灾难恢复，也可以通过数据分片来应对数据量迅速增长的需求。关于MongoDB更多的操作可以查阅官方文档 ，同时推荐大家阅读Kristina Chodorow写的《MongoDB权威指南》。\n在Python程序中操作MongoDB 可以通过pip安装pymongo来实现对MongoDB的操作。\npip3 install pymongo python3\u0026gt;\u0026gt;\u0026gt; from pymongo import MongoClient \u0026gt;\u0026gt;\u0026gt; client = MongoClient(\u0026#39;mongodb://127.0.0.1:27017\u0026#39;) \u0026gt;\u0026gt;\u0026gt; db = client.school \u0026gt;\u0026gt;\u0026gt; for student in db.students.find(): ... print(\u0026#39;学号:\u0026#39;, student[\u0026#39;stuid\u0026#39;]) ... print(\u0026#39;姓名:\u0026#39;, student[\u0026#39;name\u0026#39;]) ... print(\u0026#39;电话:\u0026#39;, student[\u0026#39;tel\u0026#39;]) ... 学号: 1001.0 姓名: 骆昊 电话: 13566778899 学号: 1002.0 姓名: 王大锤 电话: 13012345678 学号: 1003.0 姓名: 白元芳 电话: 13022223333 \u0026gt;\u0026gt;\u0026gt; db.students.find().count() 3 \u0026gt;\u0026gt;\u0026gt; db.students.remove() {\u0026#39;n\u0026#39;: 3, \u0026#39;ok\u0026#39;: 1.0} \u0026gt;\u0026gt;\u0026gt; db.students.find().count() 0 \u0026gt;\u0026gt;\u0026gt; coll = db.students \u0026gt;\u0026gt;\u0026gt; from pymongo import ASCENDING \u0026gt;\u0026gt;\u0026gt; coll.create_index([(\u0026#39;name\u0026#39;, ASCENDING)], unique=True) \u0026#39;name_1\u0026#39; \u0026gt;\u0026gt;\u0026gt; coll.insert_one({\u0026#39;stuid\u0026#39;: int(1001), \u0026#39;name\u0026#39;: \u0026#39;骆昊\u0026#39;, \u0026#39;gender\u0026#39;: True}) \u0026lt;pymongo.results.InsertOneResult object at 0x1050cc6c8\u0026gt; \u0026gt;\u0026gt;\u0026gt; coll.insert_many([{\u0026#39;stuid\u0026#39;: int(1002), \u0026#39;name\u0026#39;: \u0026#39;王大锤\u0026#39;, \u0026#39;gender\u0026#39;: False}, {\u0026#39;stuid\u0026#39;: int(1003), \u0026#39;name\u0026#39;: \u0026#39;白元芳\u0026#39;, \u0026#39;gender\u0026#39;: True}]) \u0026lt;pymongo.results.InsertManyResult object at 0x1050cc8c8\u0026gt; \u0026gt;\u0026gt;\u0026gt; for student in coll.find({\u0026#39;gender\u0026#39;: True}): ... print(\u0026#39;学号:\u0026#39;, student[\u0026#39;stuid\u0026#39;]) ... print(\u0026#39;姓名:\u0026#39;, student[\u0026#39;name\u0026#39;]) ... print(\u0026#39;性别:\u0026#39;, \u0026#39;男\u0026#39; if student[\u0026#39;gender\u0026#39;] else \u0026#39;女\u0026#39;) ... 学号: 1001 姓名: 骆昊 性别: 男 学号: 1003 姓名: 白元芳 性别: 男 \u0026gt;\u0026gt;\u0026gt; 关于PyMongo更多的知识可以通过它的官方文档进行了解，也可以使用MongoEngine这样的库来简化Python程序对MongoDB的操作，除此之外，还有以异步I/O方式访问MongoDB的三方库motor都是不错的选择。\n"},{"idx":31,"href":"/python100days/docs/Day41-55/41-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/","title":"41 快速上手","content":" 快速上手 Web开发的早期阶段，开发者需要手动编写每个页面，例如一个新闻门户网站，每天都要修改它的HTML页面，随着网站规模和体量的增大，这种方式就变得极度糟糕。为了解决这个问题，开发人员想到了用外部程序来为Web服务器生成动态内容，也就是说HTML页面以及页面中的动态内容不再通过手动编写而是通过程序自动生成。最早的时候，这项技术被称为CGI（公共网关接口），当然随着时间的推移，CGI暴露出的问题也越来越多，例如大量重复的样板代码，总体性能较为低下等，因此在时代呼唤新英雄的背景下，PHP、ASP、JSP这类Web应用开发技术在上世纪90年代中后期如雨后春笋般涌现。通常我们说的Web应用是指通过浏览器来访问网络资源的应用程序，因为浏览器的普及性以及易用性，Web应用使用起来方便简单，免除了安装和更新应用程序带来的麻烦，而且也不用关心用户到底用的是什么操作系统，甚至不用区分是PC端还是移动端。\nWeb应用机制和术语 下图向我们展示了Web应用的工作流程，其中涉及到的术语如下表所示。\n 说明：相信有经验的读者会发现，这张图中其实还少了很多东西，例如反向代理服务器、数据库服务器、防火墙等，而且图中的每个节点在实际项目部署时可能是一组节点组成的集群。当然，如果你对这些没有什么概念也不要紧，继续下去就行了，后面会给大家一一讲解的。\n    术语 解释     URL/URI 统一资源定位符/统一资源标识符，网络资源的唯一标识   域名 与Web服务器地址对应的一个易于记忆的字符串名字   DNS 域名解析服务，可以将域名转换成对应的IP地址   IP地址 网络上的主机的身份标识，通过IP地址可以区分不同的主机   HTTP 超文本传输协议，构建在TCP之上的应用级协议，万维网数据通信的基础   反向代理 代理客户端向服务器发出请求，然后将服务器返回的资源返回给客户端   Web服务器 接受HTTP请求，然后返回HTML文件、纯文本文件、图像等资源给请求者   Nginx 高性能的Web服务器，也可以用作反向代理，负载均衡 和 HTTP缓存    HTTP协议 这里我们稍微费一些笔墨来谈谈上面提到的HTTP。HTTP（超文本传输协议）是构建于TCP（传输控制协议）之上应用级协议，它利用了TCP提供的可靠的传输服务实现了Web应用中的数据交换。按照维基百科上的介绍，设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法，也就是说这个协议是浏览器和Web服务器之间传输的数据的载体。关于这个协议的详细信息以及目前的发展状况，大家可以阅读阮一峰老师的《HTTP 协议入门》、《互联网协议入门》系列以及《图解HTTPS协议》进行了解。下图是我在四川省网络通信技术重点实验室学习和工作期间使用开源协议分析工具Ethereal（抓包工具WireShark的前身）截取的访问百度首页时的HTTP请求和响应的报文（协议数据），由于Ethereal截取的是经过网络适配器的数据，因此可以清晰的看到从物理链路层到应用层的协议数据。\nHTTP请求（请求行+请求头+空行+[消息体]）：\nHTTP响应（响应行+响应头+空行+消息体）：\n 说明：这两张图是在2009年9月10日截取的，但愿这两张如同泛黄的照片般的截图能帮助你了解HTTP到底是什么样子的。\n Django概述 Python的Web框架有上百个，比它的关键字还要多。所谓Web框架，就是用于开发Web服务器端应用的基础设施（通常指封装好的模块和一系列的工具）。事实上，即便没有Web框架，我们仍然可以通过socket或CGI来开发Web服务器端应用，但是这样做的成本和代价在实际开发中通常是不能接受的。通过Web框架，我们可以化繁为简，同时降低创建、更新、扩展应用程序的工作量。Python的Web框架中比较有名的有：Flask、Django、Tornado、Sanic、Pyramid、Bottle、Web2py、web.py等。\n在基于Python的Web框架中，Django是所有重量级选手中最有代表性的一位，开发者可以基于Django快速的开发可靠的Web应用程序，因为它减少了Web开发中不必要的开销，对常用的设计和开发模式进行了封装，并对MVC架构提供了支持（MTV）。许多成功的网站和App都是基于Django框架构建的，国内比较有代表性的网站包括：知乎、豆瓣网、果壳网、搜狐闪电邮箱、101围棋网、海报时尚网、背书吧、堆糖、手机搜狐网、咕咚、爱福窝、果库等。\nDjango诞生于2003年，它是一个在真正的应用中成长起来的项目，由劳伦斯出版集团旗下在线新闻网站的内容管理系统（CMS）研发团队编写（主要是Adrian Holovaty和Simon Willison），以比利时的吉普赛爵士吉他手Django Reinhardt来命名，在2005年夏天作为开源框架发布。使用Django能用很短的时间构建出功能完备的网站，因为它代替程序员完成了所有乏味和重复的劳动，剩下真正有意义的核心业务给程序员，这一点就是对DRY（Don\u0026rsquo;t Repeat Yourself）理念的最好践行。\n快速上手 准备工作  检查Python环境：Django 1.11需要Python 2.7或Python 3.4以上的版本；Django 2.0需要Python 3.4以上的版本；Django 2.1需要Python 3.5以上的版本。   说明：我自己平时使用macOS做开发，macOS和Linux平台使用的命令跟Windows平台有较大的区别，这一点在之前也有过类似的说明，如果使用Windows平台做开发，替换一下对应的命令即可。\n $ python3 --version$ python3 \u0026gt;\u0026gt;\u0026gt; import sys \u0026gt;\u0026gt;\u0026gt; sys.version \u0026gt;\u0026gt;\u0026gt; sys.version_info  创建项目文件夹并切换到该目录，例如我们要实例一个OA（办公自动化）项目。\n$ mkdir oa $ cd oa 创建并激活虚拟环境。\n$ python3 -m venv venv $ source venv/bin/activate   说明：上面使用了Python自带的venv模块完成了虚拟环境的创建，当然也可以使用virtualenv或pipenv这样的工具。要激活虚拟环境，在Windows环境下可以通过\u0026rdquo;venv/Scripts/activate\u0026rdquo;执行批处理文件来实现。\n  更新包管理工具pip。\n(venv)$ pip install -U pip  或\n(venv)$ python -m pip install -U pip  注意：请注意终端提示符发生的变化，前面的(venv)说明我们已经进入虚拟环境，而虚拟环境下的python和pip已经是Python 3的解释器和包管理工具了。\n  安装Django。\n(venv)$ pip install django  或指定版本号来安装对应的Django的版本。\n(venv)$ pip install django==2.1.8  检查Django的版本。\n(venv)$ python -m django --version (venv)$ django-admin --version  或\n(venv)$ python \u0026gt;\u0026gt;\u0026gt; import django \u0026gt;\u0026gt;\u0026gt; django.get_version() 当然，也可以通过pip来查看安装的依赖库及其版本，如：\n(venv)$ pip freeze (venv)$ pip list 下图展示了Django版本和Python版本的对应关系，如果在安装时没有指定版本号，将自动选择最新的版本（在写作这段内容时，Django最新的版本是2.2）。\n| Django版本 | Python版本 | | \u0026mdash;\u0026mdash;\u0026mdash;- | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; | | 1.8 | 2.7、3.2、3.3、3.4、3.5 | | 1.9、1.10 | 2.7、3.4、3.5 | | 1.11 | 2.7、3.4、3.5、3.6、3.7 | | 2.0 | 3.4、3.5、3.6、3.7 | | 2.1、2.2 | 3.5、3.6、3.7 |\n 使用django-admin创建项目，项目命名为oa。\n(venv)$ django-admin startproject oa .   注意：上面的命令最后的那个点，它表示在当前路径下创建项目。\n 执行上面的命令后看看生成的文件和文件夹，它们的作用如下所示：\n manage.py： 一个让你可以管理Django项目的工具程序。 oa/__init__.py：一个空文件，告诉Python解释器这个目录应该被视为一个Python的包。 oa/settings.py：Django项目的配置文件。 oa/urls.py：Django项目的URL声明（URL映射），就像是你的网站的“目录”。 oa/wsgi.py：项目运行在WSGI兼容Web服务器上的接口文件。   说明：WSGI全称是Web服务器网关接口，维基百科上给出的解释是“为Python语言定义的Web服务器和Web应用程序或框架之间的一种简单而通用的接口”。\n  启动服务器运行项目。\n(venv)$ python manage.py runserver  在浏览器中输入http://127.0.0.1:8000访问我们的服务器，效果如下图所示。\n 说明1：刚刚启动的是Django自带的用于开发和测试的服务器，它是一个用纯Python编写的轻量级Web服务器，但它并不是真正意义上的生产级别的服务器，千万不要将这个服务器用于和生产环境相关的任何地方。\n说明2：用于开发的服务器在需要的情况下会对每一次的访问请求重新载入一遍Python代码。所以你不需要为了让修改的代码生效而频繁的重新启动服务器。然而，一些动作，比如添加新文件，将不会触发自动重新加载，这时你得自己手动重启服务器。\n说明3：可以通过python manage.py help命令查看可用命令列表；在启动服务器时，也可以通过python manage.py runserver 1.2.3.4:5678来指定将服务器运行于哪个IP地址和端口。\n说明4：可以通过Ctrl+C来终止服务器的运行。\n  接下来我们修改项目的配置文件settings.py，Django是一个支持国际化和本地化的框架，因此刚才我们看到的默认首页也是支持国际化的，我们将默认语言修改为中文，时区设置为东八区。\n(venv)$ vim oa/settings.py# 此处省略上面的内容 # 设置语言代码 LANGUAGE_CODE = \u0026#39;zh-hans\u0026#39; # 设置时区 TIME_ZONE = \u0026#39;Asia/Chongqing\u0026#39; # 此处省略下面的内容 刷新刚才的页面。\n  动态页面  创建名为hrs（人力资源系统）的应用，一个Django项目可以包含一个或多个应用。\n(venv)$ python manage.py startapp hrs  执行上面的命令会在当前路径下创建hrs目录，其目录结构如下所示：\n __init__.py：一个空文件，告诉Python解释器这个目录应该被视为一个Python的包。 admin.py：可以用来注册模型，用于在Django的管理界面管理模型。 apps.py：当前应用的配置文件。 migrations：存放与模型有关的数据库迁移信息。  __init__.py：一个空文件，告诉Python解释器这个目录应该被视为一个Python的包。  models.py：存放应用的数据模型，即实体类及其之间的关系（MVC/MTV中的M）。 tests.py：包含测试应用各项功能的测试类和测试函数。 views.py：处理请求并返回响应的函数（MVC中的C，MTV中的V）。   修改应用目录下的视图文件views.py。\n(venv)$ vim hrs/views.pyfrom django.http import HttpResponse def index(request): return HttpResponse(\u0026#39;\u0026lt;h1\u0026gt;Hello, Django!\u0026lt;/h1\u0026gt;\u0026#39;) 在应用目录创建一个urls.py文件并映射URL。\n(venv)$ touch hrs/urls.py (venv)$ vim hrs/urls.pyfrom django.urls import path from hrs import views urlpatterns = [ path(\u0026#39;\u0026#39;, views.index, name=\u0026#39;index\u0026#39;), ]   说明：上面使用的path函数是Django 2.x中新添加的函数，除此之外还可以使用支持正则表达式的URL映射函数re_path函数；Django 1.x中是用名为url函数来设定URL映射。\n  修改项目目录下的urls.py文件，对应用中设定的URL进行合并。\n(venv) $ vim oa/urls.pyfrom django.contrib import admin from django.urls import path, include urlpatterns = [ path(\u0026#39;admin/\u0026#39;, admin.site.urls), path(\u0026#39;hrs/\u0026#39;, include(\u0026#39;hrs.urls\u0026#39;)), ]   说明：上面的代码通过include函数将hrs应用中配置URL的文件包含到项目的URL配置中，并映射到hrs/路径下。\n  重新运行项目，并打开浏览器中访问http://localhost:8000/hrs。\n(venv)$ python manage.py runserver 修改views.py生成动态内容。\n(venv)$ vim hrs/views.pyfrom io import StringIO from django.http import HttpResponse depts_list = [ {\u0026#39;no\u0026#39;: 10, \u0026#39;name\u0026#39;: \u0026#39;财务部\u0026#39;, \u0026#39;location\u0026#39;: \u0026#39;北京\u0026#39;}, {\u0026#39;no\u0026#39;: 20, \u0026#39;name\u0026#39;: \u0026#39;研发部\u0026#39;, \u0026#39;location\u0026#39;: \u0026#39;成都\u0026#39;}, {\u0026#39;no\u0026#39;: 30, \u0026#39;name\u0026#39;: \u0026#39;销售部\u0026#39;, \u0026#39;location\u0026#39;: \u0026#39;上海\u0026#39;}, ] def index(request): output = StringIO() output.write(\u0026#39;\u0026lt;html\u0026gt;\\n\u0026#39;) output.write(\u0026#39;\u0026lt;head\u0026gt;\\n\u0026#39;) output.write(\u0026#39;\\t\u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt;\\n\u0026#39;) output.write(\u0026#39;\\t\u0026lt;title\u0026gt;首页\u0026lt;/title\u0026gt;\u0026#39;) output.write(\u0026#39;\u0026lt;/head\u0026gt;\\n\u0026#39;) output.write(\u0026#39;\u0026lt;body\u0026gt;\\n\u0026#39;) output.write(\u0026#39;\\t\u0026lt;h1\u0026gt;部门信息\u0026lt;/h1\u0026gt;\\n\u0026#39;) output.write(\u0026#39;\\t\u0026lt;hr\u0026gt;\\n\u0026#39;) output.write(\u0026#39;\\t\u0026lt;table\u0026gt;\\n\u0026#39;) output.write(\u0026#39;\\t\\t\u0026lt;tr\u0026gt;\\n\u0026#39;) output.write(\u0026#39;\\t\\t\\t\u0026lt;th width=120\u0026gt;部门编号\u0026lt;/th\u0026gt;\\n\u0026#39;) output.write(\u0026#39;\\t\\t\\t\u0026lt;th width=180\u0026gt;部门名称\u0026lt;/th\u0026gt;\\n\u0026#39;) output.write(\u0026#39;\\t\\t\\t\u0026lt;th width=180\u0026gt;所在地\u0026lt;/th\u0026gt;\\n\u0026#39;) output.write(\u0026#39;\\t\\t\u0026lt;/tr\u0026gt;\\n\u0026#39;) for dept in depts_list: output.write(\u0026#39;\\t\\t\u0026lt;tr\u0026gt;\\n\u0026#39;) output.write(f\u0026#39;\\t\\t\\t\u0026lt;td align=center\u0026gt;{dept[\u0026#34;no\u0026#34;]}\u0026lt;/td\u0026gt;\\n\u0026#39;) output.write(f\u0026#39;\\t\\t\\t\u0026lt;td align=center\u0026gt;{dept[\u0026#34;name\u0026#34;]}\u0026lt;/td\u0026gt;\\n\u0026#39;) output.write(f\u0026#39;\\t\\t\\t\u0026lt;td align=center\u0026gt;{dept[\u0026#34;location\u0026#34;]}\u0026lt;/td\u0026gt;\\n\u0026#39;) output.write(\u0026#39;\\t\\t\u0026lt;/tr\u0026gt;\\n\u0026#39;) output.write(\u0026#39;\\t\u0026lt;/table\u0026gt;\\n\u0026#39;) output.write(\u0026#39;\u0026lt;/body\u0026gt;\\n\u0026#39;) output.write(\u0026#39;\u0026lt;/html\u0026gt;\\n\u0026#39;) return HttpResponse(output.getvalue()) 刷新页面查看程序的运行结果。\n  使用视图模板 上面通过拼接HTML代码的方式生成动态视图的做法在实际开发中是无能接受的，这一点大家一定能够想到。为了解决这个问题，我们可以提前准备一个模板页，所谓模板页就是一个带占位符的HTML页面，当我们将程序中获得的数据替换掉页面中的占位符时，一个动态页面就产生了。\n我们可以用Django框架中template模块的Template类创建模板对象，通过模板对象的render方法实现对模板的渲染，在Django框架中还有一个名为render的便捷函数可以来完成渲染模板的操作。所谓的渲染就是用数据替换掉模板页中的占位符，当然这里的渲染称为后端渲染，即在服务器端完成页面的渲染再输出到浏览器中，这种做法的主要坏处是当并发访问量较大时，服务器会承受较大的负担，所以今天有很多的Web应用都使用了前端渲染，即服务器只提供所需的数据（通常是JSON格式），在浏览器中通过JavaScript获取这些数据并渲染到页面上，这个我们在后面的内容中会讲到。\n 先回到manage.py文件所在的目录创建名为templates文件夹。\n(venv)$ mkdir templates 创建模板页index.html。\n(venv)$ touch templates/index.html (venv)$ vim templates/index.html\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;首页\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;部门信息\u0026lt;/h1\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;部门编号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;部门名称\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;所在地\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; {% for dept in depts_list %} \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;{{ dept.no }}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ dept.name }}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ dept.location }}\u0026lt;/td\u0026gt; \u0026lt;tr\u0026gt; {% endfor %} \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  在上面的模板页中我们使用了{{ greeting }}这样的模板占位符语法，也使用了{% for %}这样的模板指令，这些都是Django模板语言（DTL）的一部分。如果对此不熟悉并不要紧，我们会在后续的内容中进一步的讲解，而且我们刚才也说到了，渲染页面还有更好的选择就是使用前端渲染，当然这是后话。\n 回到应用目录，修改views.py文件。\n(venv)$ vim hrs/views.pyfrom django.shortcuts import render depts_list = [ {\u0026#39;no\u0026#39;: 10, \u0026#39;name\u0026#39;: \u0026#39;财务部\u0026#39;, \u0026#39;location\u0026#39;: \u0026#39;北京\u0026#39;}, {\u0026#39;no\u0026#39;: 20, \u0026#39;name\u0026#39;: \u0026#39;研发部\u0026#39;, \u0026#39;location\u0026#39;: \u0026#39;成都\u0026#39;}, {\u0026#39;no\u0026#39;: 30, \u0026#39;name\u0026#39;: \u0026#39;销售部\u0026#39;, \u0026#39;location\u0026#39;: \u0026#39;上海\u0026#39;}, ] def index(request): return render(request, \u0026#39;index.html\u0026#39;, {\u0026#39;depts_list\u0026#39;: depts_list})   说明：Django框架通过shortcuts模块的便捷函数render简化了渲染模板的操作，有了这个函数，就不用先创建Template对象再去调用render方法。。\n 到此为止，我们还没有办法让views.py中的render函数找到模板文件index.html，为此我们需要修改settings.py文件，配置模板文件所在的路径。\n 切换到项目目录修改settings.py文件。\n(venv)$ vim oa/settings.py# 此处省略上面的内容 TEMPLATES = [ { \u0026#39;BACKEND\u0026#39;: \u0026#39;django.template.backends.django.DjangoTemplates\u0026#39;, \u0026#39;DIRS\u0026#39;: [os.path.join(BASE_DIR, \u0026#39;templates\u0026#39;)], \u0026#39;APP_DIRS\u0026#39;: True, \u0026#39;OPTIONS\u0026#39;: { \u0026#39;context_processors\u0026#39;: [ \u0026#39;django.template.context_processors.debug\u0026#39;, \u0026#39;django.template.context_processors.request\u0026#39;, \u0026#39;django.contrib.auth.context_processors.auth\u0026#39;, \u0026#39;django.contrib.messages.context_processors.messages\u0026#39;, ], }, }, ] # 此处省略下面的内容 重新运行项目或直接刷新页面查看结果。\n(venv)$ python manage.py runserver  总结 至此，我们已经利用Django框架完成了一个非常小的Web应用，虽然它并没有任何的实际价值，但是可以通过这个项目对Django框架有一个感性的认识。当然，实际开发中我们可以用PyCharm来创建项目，如果使用专业版的PyCharm，可以直接创建Django项目。使用PyCharm的好处在于编写代码时可以获得代码提示、错误修复、自动导入等功能，从而提升开发效率，但是专业版的PyCharm需要按年支付相应的费用，社区版的PyCharm中并未包含对Django框架直接的支持，但是我们仍然可以使用它来创建Django项目，只是在使用上没有专业版的方便。关于PyCharm的使用，可以参考《玩转PyCharm》一文。此外，Django最好的学习资料肯定是它的官方文档，当然图灵社区出版的《Django基础教程》也是非常适合初学者的入门级读物。\n"},{"idx":32,"href":"/python100days/docs/Day41-55/42-%E6%B7%B1%E5%85%A5%E6%A8%A1%E5%9E%8B/","title":"42 深入模型","content":" 深入模型 在上一个章节中，我们提到了Django是基于MVC架构的Web框架，MVC架构追求的是“模型”和“视图”的解耦合。所谓“模型”说得更直白一些就是数据（的表示），所以通常也被称作“数据模型”。在实际的项目中，数据模型通常通过数据库实现持久化操作，而关系型数据库在过去和当下都是持久化的首选方案，下面我们以MySQL为例来说明如何使用关系型数据库来实现持久化操作。\n配置关系型数据库MySQL 我们继续来完善上一个章节中的OA项目，首先从配置项目使用的数据库开始。\n 修改项目的settings.py文件，首先将我们之前创建的应用hrs添加已安装的项目中，然后配置MySQL作为持久化方案。\n(venv)$ vim oa/settings.py# 此处省略上面的代码 INSTALLED_APPS = [ \u0026#39;django.contrib.admin\u0026#39;, \u0026#39;django.contrib.auth\u0026#39;, \u0026#39;django.contrib.contenttypes\u0026#39;, \u0026#39;django.contrib.sessions\u0026#39;, \u0026#39;django.contrib.messages\u0026#39;, \u0026#39;django.contrib.staticfiles\u0026#39;, \u0026#39;hrs\u0026#39;, ] DATABASES = { \u0026#39;default\u0026#39;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;django.db.backends.mysql\u0026#39;, \u0026#39;NAME\u0026#39;: \u0026#39;oa\u0026#39;, \u0026#39;HOST\u0026#39;: \u0026#39;127.0.0.1\u0026#39;, \u0026#39;PORT\u0026#39;: 3306, \u0026#39;USER\u0026#39;: \u0026#39;root\u0026#39;, \u0026#39;PASSWORD\u0026#39;: \u0026#39;123456\u0026#39;, } } # 此处省略下面的代码  在配置ENGINE属性时，常用的可选值包括：\n 'django.db.backends.sqlite3'：SQLite嵌入式数据库。 'django.db.backends.postgresql'：BSD许可证下发行的开源关系型数据库产品。 'django.db.backends.mysql'：转手多次目前属于甲骨文公司的经济高效的数据库产品。 'django.db.backends.oracle'：甲骨文公司的关系型数据库旗舰产品。  其他的配置可以参考官方文档中数据库配置的部分。\nNAME属性代表数据库的名称，如果使用SQLite它对应着一个文件，在这种情况下NAME的属性值应该是一个绝对路径；使用其他关系型数据库，则要配置对应的HOST（主机）、PORT（端口）、USER（用户名）、PASSWORD（口令）等属性。\n 安装Python操作MySQL的依赖库，Python 3中通常使用PyMySQL，Python 2中通常用MySQLdb。\n(venv)$ pip install pymysql  如果使用Python 3需要修改项目目录下的__init__.py文件并加入如下所示的代码，这段代码的作用是将PyMySQL视为MySQLdb来使用，从而避免Django找不到连接MySQL的客户端工具而询问你：“Did you install mysqlclient? ”（你安装了mysqlclient吗？）。\nimport pymysql pymysql.install_as_MySQLdb()  如果之前没有为应用程序创建数据库，那么现在是时候创建名为oa的数据库了。在MySQL中创建数据库的SQL语句如下所示：\ncreate database oa default charset utf8; Django框架本身有自带的数据模型，我们稍后会用到这些模型，为此我们先做一次迁移操作。所谓迁移，就是根据模型自动生成关系数据库中的二维表，命令如下所示：\n(venv)$ python manage.py migrate Operations to perform: Apply all migrations: admin, auth, contenttypes, sessions Running migrations: Applying contenttypes.0001_initial... OK Applying auth.0001_initial... OK Applying admin.0001_initial... OK Applying admin.0002_logentry_remove_auto_add... OK Applying contenttypes.0002_remove_content_type_name... OK Applying auth.0002_alter_permission_name_max_length... OK Applying auth.0003_alter_user_email_max_length... OK Applying auth.0004_alter_user_username_opts... OK Applying auth.0005_alter_user_last_login_null... OK Applying auth.0006_require_contenttypes_0002... OK Applying auth.0007_alter_validators_add_error_messages... OK Applying auth.0008_alter_user_username_max_length... OK Applying auth.0009_alter_user_last_name_max_length... OK Applying sessions.0001_initial... OK 接下来，我们为自己的应用创建数据模型。如果要在hrs应用中实现对部门和员工的管理，我们可以先创建部门和员工数据模型，代码如下所示。\n(venv)$ vim hrs/models.pyfrom django.db import models class Dept(models.Model): \u0026#34;\u0026#34;\u0026#34;部门类\u0026#34;\u0026#34;\u0026#34; no = models.IntegerField(primary_key=True, db_column=\u0026#39;dno\u0026#39;, verbose_name=\u0026#39;部门编号\u0026#39;) name = models.CharField(max_length=20, db_column=\u0026#39;dname\u0026#39;, verbose_name=\u0026#39;部门名称\u0026#39;) location = models.CharField(max_length=10, db_column=\u0026#39;dloc\u0026#39;, verbose_name=\u0026#39;部门所在地\u0026#39;) class Meta: db_table = \u0026#39;tb_dept\u0026#39; class Emp(models.Model): \u0026#34;\u0026#34;\u0026#34;员工类\u0026#34;\u0026#34;\u0026#34; no = models.IntegerField(primary_key=True, db_column=\u0026#39;eno\u0026#39;, verbose_name=\u0026#39;员工编号\u0026#39;) name = models.CharField(max_length=20, db_column=\u0026#39;ename\u0026#39;, verbose_name=\u0026#39;员工姓名\u0026#39;) job = models.CharField(max_length=10, verbose_name=\u0026#39;职位\u0026#39;) # 多对一外键关联(自参照) mgr = models.ForeignKey(\u0026#39;self\u0026#39;, on_delete=models.SET_NULL, null=True, blank=True, verbose_name=\u0026#39;主管\u0026#39;) sal = models.DecimalField(max_digits=7, decimal_places=2, verbose_name=\u0026#39;月薪\u0026#39;) comm = models.DecimalField(max_digits=7, decimal_places=2, null=True, blank=True, verbose_name=\u0026#39;补贴\u0026#39;) # 多对一外键关联(参照部门模型) dept = models.ForeignKey(Dept, db_column=\u0026#39;dno\u0026#39;, on_delete=models.PROTECT, verbose_name=\u0026#39;所在部门\u0026#39;) class Meta: db_table = \u0026#39;tb_emp\u0026#39;   说明：上面定义模型时使用了字段类及其属性，其中IntegerField对应数据库中的integer类型，CharField对应数据库的varchar类型，DecimalField对应数据库的decimal类型，ForeignKey用来建立多对一外键关联。字段属性primary_key用于设置主键，max_length用来设置字段的最大长度，db_column用来设置数据库中与字段对应的列，verbose_name则设置了Django后台管理系统中该字段显示的名称。如果对这些东西感到很困惑也不要紧，文末提供了字段类、字段属性、元数据选项等设置的相关说明，不清楚的读者可以稍后查看对应的参考指南。\n  再次执行迁移操作，先通过模型生成迁移文件，再执行迁移创建二维表。\n(venv)$ python manage.py makemigrations hrs Migrations for \u0026#39;hrs\u0026#39;: hrs/migrations/0001_initial.py - Create model Dept - Create model Emp (venv)$ python manage.py migrate Operations to perform: Apply all migrations: admin, auth, contenttypes, hrs, sessions Running migrations: Applying hrs.0001_initial... OK  执行完数据模型迁移操作之后，可以在通过图形化的MySQL客户端工具查看到E-R图（实体关系图）。\n利用Django后台管理模型 Django框架有自带的后台管理系统来实现对模型的管理。虽然实际应用中，这个后台可能并不能满足我们的需求，但是在学习Django框架时，我们暂时可以利用Django自带的后台管理系统来管理我们的模型，同时也可以了解一个项目的后台管理系统到底需要哪些功能。\n 创建超级管理员账号。\n(venv)$ python manage.py createsuperuser Username (leave blank to use \u0026#39;hao\u0026#39;): jackfrued Email address: jackfrued@126.com Password: Password (again): Superuser created successfully. 启动Web服务器，登录后台管理系统。\n(venv)$ python manage.py runserver  访问http://127.0.0.1:8000/admin，会来到如下图所示的登录界面。\n登录后进入管理员操作平台。\n至此我们还没有看到之前创建的模型类，需要在应用的admin.py文件中模型进行注册。\n 注册模型类。\n(venv)$ vim hrs/admin.pyfrom django.contrib import admin from hrs.models import Emp, Dept admin.site.register(Dept) admin.site.register(Emp)  注册模型类后，就可以在后台管理系统中看到它们。\n 对模型进行CRUD操作。  可以在管理员平台对模型进行C（新增）、R（查看）、U（更新）、D（删除）操作，如下图所示。\n 添加新的部门。   查看所有部门。   更新和删除部门。   注册模型管理类。  可能大家已经注意到了，刚才在后台查看部门信息的时候，显示的部门信息并不直观，为此我们再修改admin.py文件，通过注册模型管理类，可以在后台管理系统中更好的管理模型。\nfrom django.contrib import admin from hrs.models import Emp, Dept class DeptAdmin(admin.ModelAdmin): list_display = (\u0026#39;no\u0026#39;, \u0026#39;name\u0026#39;, \u0026#39;location\u0026#39;) ordering = (\u0026#39;no\u0026#39;, ) class EmpAdmin(admin.ModelAdmin): list_display = (\u0026#39;no\u0026#39;, \u0026#39;name\u0026#39;, \u0026#39;job\u0026#39;, \u0026#39;mgr\u0026#39;, \u0026#39;sal\u0026#39;, \u0026#39;comm\u0026#39;, \u0026#39;dept\u0026#39;) search_fields = (\u0026#39;name\u0026#39;, \u0026#39;job\u0026#39;) admin.site.register(Dept, DeptAdmin) admin.site.register(Emp, EmpAdmin) 为了更好的查看模型数据，可以为Dept和Emp两个模型类添加__str__魔法方法。\nfrom django.db import models class Dept(models.Model): \u0026#34;\u0026#34;\u0026#34;部门类\u0026#34;\u0026#34;\u0026#34; # 此处省略上面的代码 def __str__(self): return self.name # 此处省略下面的代码 class Emp(models.Model): \u0026#34;\u0026#34;\u0026#34;员工类\u0026#34;\u0026#34;\u0026#34; # 此处省略上面的代码 def __str__(self): return self.name # 此处省略下面的代码 修改代码后刷新查看Emp模型的页面，效果如下图所示。\n使用ORM完成模型的CRUD操作 在了解了Django提供的模型管理平台之后，我们来看看如何从代码层面完成对模型的CRUD（Create / Read / Update / Delete）操作。我们可以通过manage.py开启Shell交互式环境，然后使用Django内置的ORM框架对模型进行CRUD操作。\n(venv)$ python manage.py shell Python 3.6.4 (v3.6.4:d48ecebad5, Dec 18 2017, 21:07:28) [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. (InteractiveConsole) \u0026gt;\u0026gt;\u0026gt; 新增 \u0026gt;\u0026gt;\u0026gt; from hrs.models import Dept, Emp \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; dept = Dept(40, \u0026#39;研发2部\u0026#39;, \u0026#39;深圳\u0026#39;) \u0026gt;\u0026gt;\u0026gt; dept.save() 更新 \u0026gt;\u0026gt;\u0026gt; dept.name = \u0026#39;研发3部\u0026#39; \u0026gt;\u0026gt;\u0026gt; dept.save() 查询  查询所有对象。\n\u0026gt;\u0026gt;\u0026gt; Dept.objects.all() \u0026lt;QuerySet [\u0026lt;Dept: 研发1部\u0026gt;, \u0026lt;Dept: 销售1部\u0026gt;, \u0026lt;Dept: 运维1部\u0026gt;, \u0026lt;Dept: 研发3部\u0026gt;]\u0026gt; 过滤数据。\n\u0026gt;\u0026gt;\u0026gt; Dept.objects.filter(name=\u0026#39;研发3部\u0026#39;) # 查询部门名称为“研发3部”的部门 \u0026lt;QuerySet [\u0026lt;Dept: 研发3部\u0026gt;]\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; Dept.objects.filter(name__contains=\u0026#39;研发\u0026#39;) # 查询部门名称包含“研发”的部门(模糊查询) \u0026lt;QuerySet [\u0026lt;Dept: 研发1部\u0026gt;, \u0026lt;Dept: 研发3部\u0026gt;]\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; Dept.objects.filter(no__gt=10).filter(no__lt=40) # 查询部门编号大于10小于40的部门 \u0026lt;QuerySet [\u0026lt;Dept: 销售1部\u0026gt;, \u0026lt;Dept: 运维1部\u0026gt;]\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; Dept.objects.filter(no__range=(10, 30)) # 查询部门编号在10到30之间的部门 \u0026lt;QuerySet [\u0026lt;Dept: 研发1部\u0026gt;, \u0026lt;Dept: 销售1部\u0026gt;, \u0026lt;Dept: 运维1部\u0026gt;]\u0026gt; 查询单个对象。\n\u0026gt;\u0026gt;\u0026gt; Dept.objects.get(pk=10) \u0026lt;Dept: 研发1部\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; Dept.objects.get(no=20) \u0026lt;Dept: 销售1部\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; Dept.objects.get(no__exact=30) \u0026lt;Dept: 运维1部\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; Dept.objects.filter(no=10).first() \u0026lt;Dept: 研发1部\u0026gt; 排序数据。\n\u0026gt;\u0026gt;\u0026gt; Dept.objects.order_by(\u0026#39;no\u0026#39;) # 查询所有部门按部门编号升序排列 \u0026lt;QuerySet [\u0026lt;Dept: 研发1部\u0026gt;, \u0026lt;Dept: 销售1部\u0026gt;, \u0026lt;Dept: 运维1部\u0026gt;, \u0026lt;Dept: 研发3部\u0026gt;]\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; Dept.objects.order_by(\u0026#39;-no\u0026#39;) # 查询所有部门按部门编号降序排列 \u0026lt;QuerySet [\u0026lt;Dept: 研发3部\u0026gt;, \u0026lt;Dept: 运维1部\u0026gt;, \u0026lt;Dept: 销售1部\u0026gt;, \u0026lt;Dept: 研发1部\u0026gt;]\u0026gt; 数据切片（分页查询）。\n\u0026gt;\u0026gt;\u0026gt; Dept.objects.order_by(\u0026#39;no\u0026#39;)[0:2] # 按部门编号排序查询1~2部门 \u0026lt;QuerySet [\u0026lt;Dept: 研发1部\u0026gt;, \u0026lt;Dept: 销售1部\u0026gt;]\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; Dept.objects.order_by(\u0026#39;no\u0026#39;)[2:4] # 按部门编号排序查询3~4部门 \u0026lt;QuerySet [\u0026lt;Dept: 运维1部\u0026gt;, \u0026lt;Dept: 研发3部\u0026gt;]\u0026gt; 高级查询。\n\u0026gt;\u0026gt;\u0026gt; Emp.objects.filter(dept__no=10) # 根据部门编号查询该部门的员工 \u0026lt;QuerySet [\u0026lt;Emp: 乔峰\u0026gt;, \u0026lt;Emp: 张无忌\u0026gt;, \u0026lt;Emp: 张三丰\u0026gt;]\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; Emp.objects.filter(dept__name__contains=\u0026#39;销售\u0026#39;) # 查询名字包含“销售”的部门的员工 \u0026lt;QuerySet [\u0026lt;Emp: 黄蓉\u0026gt;]\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; Dept.objects.get(pk=10).emp_set.all() # 通过部门反查部门所有的员工 \u0026lt;QuerySet [\u0026lt;Emp: 乔峰\u0026gt;, \u0026lt;Emp: 张无忌\u0026gt;, \u0026lt;Emp: 张三丰\u0026gt;]\u0026gt;   说明1：由于员工与部门之间存在多对一外键关联，所以也能通过部门反向查询该部门的员工（从一对多关系中“一”的一方查询“多”的一方），反向查询属性默认的名字是类名小写_set（如上面例子中的emp_set），当然也可以在创建模型时通过ForeingKey的related_name属性指定反向查询属性的名字。如果不希望执行反向查询可以将related_name属性设置为'+'或以'+'开头的字符串。\n说明2：查询多个对象的时候返回的是QuerySet对象，QuerySet使用了惰性查询，即在创建QuerySet对象的过程中不涉及任何数据库活动，等真正用到对象时（求值QuerySet）才向数据库发送SQL语句并获取对应的结果，这一点在实际开发中需要引起注意！\n说明3：可以在QuerySet上使用update()方法一次更新多个对象。\n 删除 \u0026gt;\u0026gt;\u0026gt; Dept.objects.get(pk=40).delete() (1, {\u0026#39;hrs.Dept\u0026#39;: 1}) Django模型最佳实践  正确的为模型和关系字段命名。 设置适当的related_name属性。 用OneToOneField代替ForeignKeyField(unique=True)。 通过“迁移操作”（migrate）来添加模型。 用NoSQL来应对需要降低范式级别的场景。 如果布尔类型可以为空要使用NullBooleanField。 在模型中放置业务逻辑。 用\u0026lt;ModelName\u0026gt;.DoesNotExists取代ObjectDoesNotExists。 在数据库中不要出现无效数据。 不要对QuerySet调用len()函数。 将QuerySet的exists()方法的返回值用于if条件。 用DecimalField来存储货币相关数据而不是FloatField。 定义__str__方法。 不要将数据文件放在同一个目录中。   说明：以上内容来自于STEELKIWI网站的Best Practice working with Django models in Python，有兴趣的小伙伴可以阅读原文。\n 模型定义参考 字段 对字段名称的限制\n 字段名不能是Python的保留字，否则会导致语法错误 字段名不能有多个连续下划线，否则影响ORM查询操作  Django模型字段类\n   字段类 说明     AutoField 自增ID字段   BigIntegerField 64位有符号整数   BinaryField 存储二进制数据的字段，对应Python的bytes类型   BooleanField 存储True或False   CharField 长度较小的字符串   DateField 存储日期，有auto_now和auto_now_add属性   DateTimeField 存储日期和日期，两个附加属性同上   DecimalField 存储固定精度小数，有max_digits（有效位数）和decimal_places（小数点后面）两个必要的参数   DurationField 存储时间跨度   EmailField 与CharField相同，可以用EmailValidator验证   FileField 文件上传字段   FloatField 存储浮点数   ImageField 其他同FileFiled，要验证上传的是不是有效图像   IntegerField 存储32位有符号整数。   GenericIPAddressField 存储IPv4或IPv6地址   NullBooleanField 存储True、False或null值   PositiveIntegerField 存储无符号整数（只能存储正数）   SlugField 存储slug（简短标注）   SmallIntegerField 存储16位有符号整数   TextField 存储数据量较大的文本   TimeField 存储时间   URLField 存储URL的CharField   UUIDField 存储全局唯一标识符    字段属性 通用字段属性\n   选项 说明     null 数据库中对应的字段是否允许为NULL，默认为False   blank 后台模型管理验证数据时，是否允许为NULL，默认为False   choices 设定字段的选项，各元组中的第一个值是设置在模型上的值，第二值是人类可读的值   db_column 字段对应到数据库表中的列名，未指定时直接使用字段的名称   db_index 设置为True时将在该字段创建索引   db_tablespace 为有索引的字段设置使用的表空间，默认为DEFAULT_INDEX_TABLESPACE   default 字段的默认值   editable 字段在后台模型管理或ModelForm中是否显示，默认为True   error_messages 设定字段抛出异常时的默认消息的字典，其中的键包括null、blank、invalid、invalid_choice、unique和unique_for_date   help_text 表单小组件旁边显示的额外的帮助文本。   primary_key 将字段指定为模型的主键，未指定时会自动添加AutoField用于主键，只读。   unique 设置为True时，表中字段的值必须是唯一的   verbose_name 字段在后台模型管理显示的名称，未指定时使用字段的名称    ForeignKey属性\n limit_choices_to：值是一个Q对象或返回一个Q对象，用于限制后台显示哪些对象。 related_name：用于获取关联对象的关联管理器对象（反向查询），如果不允许反向，该属性应该被设置为'+'，或者以'+'结尾。 to_field：指定关联的字段，默认关联对象的主键字段。 db_constraint：是否为外键创建约束，默认值为True。 on_delete：外键关联的对象被删除时对应的动作，可取的值包括django.db.models中定义的：  CASCADE：级联删除。 PROTECT：抛出ProtectedError异常，阻止删除引用的对象。 SET_NULL：把外键设置为null，当null属性被设置为True时才能这么做。 SET_DEFAULT：把外键设置为默认值，提供了默认值才能这么做。   ManyToManyField属性\n symmetrical：是否建立对称的多对多关系。 through：指定维持多对多关系的中间表的Django模型。 throughfields：定义了中间模型时可以指定建立多对多关系的字段。 db_table：指定维持多对多关系的中间表的表名。  模型元数据选项    选项 说明     abstract 设置为True时模型是抽象父类   app_label 如果定义模型的应用不在INSTALLED_APPS中可以用该属性指定   db_table 模型使用的数据表名称   db_tablespace 模型使用的数据表空间   default_related_name 关联对象回指这个模型时默认使用的名称，默认为_set   get_latest_by 模型中可排序字段的名称。   managed 设置为True时，Django在迁移中创建数据表并在执行flush管理命令时把表移除   order_with_respect_to 标记对象为可排序的   ordering 对象的默认排序   permissions 创建对象时写入权限表的额外权限   default_permissions 默认为('add', 'change', 'delete')   unique_together 设定组合在一起时必须独一无二的字段名   index_together 设定一起建立索引的多个字段名   verbose_name 为对象设定人类可读的名称   verbose_name_plural 设定对象的复数名称    查询参考 按字段查找可以用的条件：\n exact / iexact：精确匹配/忽略大小写的精确匹配查询 contains / icontains / startswith / istartswith / endswith / iendswith：基于like的模糊查询 in：集合运算 gt / gte / lt / lte：大于/大于等于/小于/小于等于关系运算 range：指定范围查询（SQL中的between…and…） year / month / day / week_day / hour / minute / second：查询时间日期 isnull：查询空值（True）或非空值（False） search：基于全文索引的全文检索 regex / iregex：基于正则表达式的模糊匹配查询  Q对象（用于执行复杂查询）的使用：\n\u0026gt;\u0026gt;\u0026gt; from django.db.models import Q \u0026gt;\u0026gt;\u0026gt; Emp.objects.filter( ... Q(name__startswith=\u0026#39;张\u0026#39;), ... Q(sal__gte=5000) | Q(comm__gte=1000) ... ) # 查询名字以“张”开头且工资大于等于5000或补贴大于等于1000的员工 \u0026lt;QuerySet [\u0026lt;Emp: 张三丰\u0026gt;]\u0026gt;"},{"idx":33,"href":"/python100days/docs/Day41-55/43-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%92%8CAjax%E8%AF%B7%E6%B1%82/","title":"43 静态资源和 Ajax请求","content":" 静态资源和Ajax请求 基于前面两个章节讲解的知识，我们已经可以使用Django框架来完成Web应用的开发了。接下来我们就尝试实现一个投票应用，具体的需求是用户进入应用首先查看到“学科介绍”页面，该页面显示了一个学校所开设的所有学科；通过点击某个学科，可以进入“老师介绍”页面，该页面展示了该学科所有老师的详细情况，可以在该页面上给老师点击“好评”或“差评”；如果用户没有登录，在投票时会先跳转到“登录页”要求用户登录，登录成功才能投票；对于未注册的用户，可以在“登录页”点击“新用户注册”进入“注册页”完成用户注册操作，注册成功后会跳转到“登录页”，注册失败会获得相应的提示信息。\n准备工作 由于之前已经详细的讲解了如何创建Django项目以及项目的相关配置，因此我们略过这部分内容，唯一需要说明的是，从上面对投票应用需求的描述中我们可以分析出三个业务实体：学科、老师和用户。学科和老师之间通常是一对多关联关系（一个学科有多个老师，一个老师通常只属于一个学科），用户因为要给老师投票，所以跟老师之间是多对多关联关系（一个用户可以给多个老师投票，一个老师也可以收到多个用户的投票）。首先修改应用下的models.py文件来定义数据模型，先给出学科和老师的模型。\nfrom django.db import models class Subject(models.Model): \u0026#34;\u0026#34;\u0026#34;学科\u0026#34;\u0026#34;\u0026#34; no = models.IntegerField(primary_key=True, verbose_name=\u0026#39;编号\u0026#39;) name = models.CharField(max_length=20, verbose_name=\u0026#39;名称\u0026#39;) intro = models.CharField(max_length=511, default=\u0026#39;\u0026#39;, verbose_name=\u0026#39;介绍\u0026#39;) create_date = models.DateField(null=True, verbose_name=\u0026#39;成立日期\u0026#39;) is_hot = models.BooleanField(default=False, verbose_name=\u0026#39;是否热门\u0026#39;) def __str__(self): return self.name class Meta: db_table = \u0026#39;tb_subject\u0026#39; verbose_name = \u0026#39;学科\u0026#39; verbose_name_plural = \u0026#39;学科\u0026#39; class Teacher(models.Model): \u0026#34;\u0026#34;\u0026#34;老师\u0026#34;\u0026#34;\u0026#34; no = models.AutoField(primary_key=True, verbose_name=\u0026#39;编号\u0026#39;) name = models.CharField(max_length=20, verbose_name=\u0026#39;姓名\u0026#39;) detail = models.CharField(max_length=1023, default=\u0026#39;\u0026#39;, blank=True, verbose_name=\u0026#39;详情\u0026#39;) photo = models.CharField(max_length=1023, default=\u0026#39;\u0026#39;, verbose_name=\u0026#39;照片\u0026#39;) good_count = models.IntegerField(default=0, verbose_name=\u0026#39;好评数\u0026#39;) bad_count = models.IntegerField(default=0, verbose_name=\u0026#39;差评数\u0026#39;) subject = models.ForeignKey(to=Subject, on_delete=models.PROTECT, db_column=\u0026#39;sno\u0026#39;, verbose_name=\u0026#39;所属学科\u0026#39;) class Meta: db_table = \u0026#39;tb_teacher\u0026#39; verbose_name = \u0026#39;老师\u0026#39; verbose_name_plural = \u0026#39;老师\u0026#39; 模型定义完成后，可以通过“生成迁移”和“执行迁移”来完成关系型数据库中二维表的创建，当然这需要提前启动数据库服务器并创建好对应的数据库，同时我们在项目中已经安装了PyMySQL而且完成了相应的配置，这些内容此处不再赘述。\n(venv)$ python manage.py makemigrations vote ... (venv)$ python manage.py migrate ...  注意：为了给vote应用生成迁移文件，需要修改Django项目settings.py文件，在INSTALLED_APPS中添加vote应用。\n 完成模型迁移之后，我们可以直接使用Django提供的后台管理来添加学科和老师信息，这需要先注册模型类和模型管理类。\nfrom django.contrib import admin from poll2.forms import UserForm from poll2.models import Subject, Teacher class SubjectAdmin(admin.ModelAdmin): list_display = (\u0026#39;no\u0026#39;, \u0026#39;name\u0026#39;, \u0026#39;create_date\u0026#39;, \u0026#39;is_hot\u0026#39;) ordering = (\u0026#39;no\u0026#39;, ) class TeacherAdmin(admin.ModelAdmin): list_display = (\u0026#39;no\u0026#39;, \u0026#39;name\u0026#39;, \u0026#39;detail\u0026#39;, \u0026#39;good_count\u0026#39;, \u0026#39;bad_count\u0026#39;, \u0026#39;subject\u0026#39;) ordering = (\u0026#39;subject\u0026#39;, \u0026#39;no\u0026#39;) admin.site.register(Subject, SubjectAdmin) admin.site.register(Teacher, TeacherAdmin) 接下来，我们就可以修改views.py文件，通过编写视图函数先实现“学科介绍”页面。\ndef show_subjects(request): \u0026#34;\u0026#34;\u0026#34;查看所有学科\u0026#34;\u0026#34;\u0026#34; subjects = Subject.objects.all() return render(request, \u0026#39;subject.html\u0026#39;, {\u0026#39;subjects\u0026#39;: subjects}) 至此，我们还需要一个模板页，模板的配置以及模板页中模板语言的用法在之前已经进行过简要的介绍，如果不熟悉可以看看下面的代码，相信这并不是一件困难的事情。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;所有学科信息\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt;/* 此处略去了层叠样式表的选择器 */\u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;所有学科\u0026lt;/h1\u0026gt; \u0026lt;hr\u0026gt; {% for subject in subjects %} \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt; \u0026lt;a href=\u0026#34;/teachers/?sno={{ subject.no }}\u0026#34;\u0026gt;{{ subject.name }}\u0026lt;/a\u0026gt; {% if subject.is_hot %} \u0026lt;img src=\u0026#34;/static/images/hot.png\u0026#34; width=\u0026#34;32\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; {% endif %} \u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{{ subject.intro }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; {% endfor %} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在上面的模板中，我们为每个学科添加了一个超链接，点击超链接可以查看该学科的讲师信息，为此需要再编写一个视图函数来处理查看指定学科老师信息。\ndef show_teachers(request): \u0026#34;\u0026#34;\u0026#34;显示指定学科的老师\u0026#34;\u0026#34;\u0026#34; try: sno = int(request.GET[\u0026#39;sno\u0026#39;]) subject = Subject.objects.get(no=sno) teachers = subject.teacher_set.all() return render(request, \u0026#39;teachers.html\u0026#39;, {\u0026#39;subject\u0026#39;: subject, \u0026#39;teachers\u0026#39;: teachers}) except (KeyError, ValueError, Subject.DoesNotExist): return redirect(\u0026#39;/\u0026#39;) 显示老师信息的模板页。\n\u0026lt;!DOCTYPE html\u0026gt; {% load static %} \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;老师\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt;/* 此处略去了层叠样式表的选择器 */\u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;{{ subject.name }}学科老师信息\u0026lt;/h1\u0026gt; \u0026lt;hr\u0026gt; {% if teachers %} {% for teacher in teachers %} \u0026lt;div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;img src=\u0026#34;{% static teacher.photo %}\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;{{ teacher.name }}\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{{ teacher.detail }}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;comment\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;好评\u0026lt;/a\u0026gt; (\u0026lt;span\u0026gt;{{ teacher.good_count }}\u0026lt;/span\u0026gt;) \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;差评\u0026lt;/a\u0026gt; (\u0026lt;span\u0026gt;{{ teacher.bad_count }}\u0026lt;/span\u0026gt;) \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {% endfor %} {% else %} \u0026lt;h3\u0026gt;暂时没有该学科的老师信息\u0026lt;/h3\u0026gt; {% endif %} \u0026lt;p\u0026gt; \u0026lt;a href=\u0026#34;/\u0026#34;\u0026gt;返回首页\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 加载静态资源 在上面的模板页面中，我们使用了\u0026lt;img\u0026gt;标签来加载老师的照片，其中使用了引用静态资源的模板指令{% static %}，要使用该指令，首先要使用{% load static %}指令来加载静态资源，我们将这段代码放在了页码开始的位置。在上面的项目中，我们将静态资源置于名为static的文件夹中，在该文件夹下又创建了三个文件夹：css、js和images，分别用来保存外部层叠样式表、外部JavaScript文件和图片资源。为了能够找到保存静态资源的文件夹，我们还需要修改Django项目的配置文件settings.py，如下所示：\n# 此处省略上面的代码 STATICFILES_DIRS = [os.path.join(BASE_DIR, \u0026#39;static\u0026#39;), ] STATIC_URL = \u0026#39;/static/\u0026#39; # 此处省略下面的代码 接下来修改urls.py文件，配置用户请求的URL和视图函数的对应关系。\nfrom django.contrib import admin from django.urls import path from vote import views urlpatterns = [ path(\u0026#39;\u0026#39;, views.show_subjects), path(\u0026#39;teachers/\u0026#39;, views.show_teachers), path(\u0026#39;admin/\u0026#39;, admin.site.urls), ] 启动服务器运行项目，进入首页查看学科信息。\n点击学科查看老师信息。\nAjax请求 接下来就可以实现“好评”和“差评”的功能了，很明显如果能够在不刷新页面的情况下实现这两个功能会带来更好的用户体验，因此我们考虑使用Ajax技术来实现“好评”和“差评”，Ajax技术我们在Web前端部分已经介绍过了，此处不再赘述。\n首先修改项目的urls.py文件，为“好评”和“差评”功能映射对应的URL。\nfrom django.contrib import admin from django.urls import path from vote import views urlpatterns = [ path(\u0026#39;\u0026#39;, views.show_subjects), path(\u0026#39;teachers/\u0026#39;, views.show_teachers), path(\u0026#39;praise/\u0026#39;, views.prise_or_criticize), path(\u0026#39;criticize/\u0026#39;, views.prise_or_criticize), path(\u0026#39;admin/\u0026#39;, admin.site.urls), ] 设计视图函数praise_or_criticize来支持“好评”和“差评”功能，该视图函数通过Django封装的JsonResponse类将字典序列化成JSON字符串作为返回给浏览器的响应内容。\ndef praise_or_criticize(request): \u0026#34;\u0026#34;\u0026#34;好评\u0026#34;\u0026#34;\u0026#34; try: tno = int(request.GET[\u0026#39;tno\u0026#39;]) teacher = Teacher.objects.get(no=tno) if request.path.startswith(\u0026#39;/praise\u0026#39;): teacher.good_count += 1 else: teacher.bad_count += 1 teacher.save() data = {\u0026#39;code\u0026#39;: 200, \u0026#39;hint\u0026#39;: \u0026#39;操作成功\u0026#39;} except (KeyError, ValueError, Teacher.DoseNotExist): data = {\u0026#39;code\u0026#39;: 404, \u0026#39;hint\u0026#39;: \u0026#39;操作失败\u0026#39;} return JsonResponse(data) 修改显示老师信息的模板页，引入jQuery库来实现事件处理、Ajax请求和DOM操作。\n\u0026lt;!DOCTYPE html\u0026gt; {% load static %} \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;老师\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt;/* 此处略去了层叠样式表的选择器 */\u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;{{ subject.name }}学科老师信息\u0026lt;/h1\u0026gt; \u0026lt;hr\u0026gt; {% if teachers %} {% for teacher in teachers %} \u0026lt;div class=\u0026#34;teacher\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;photo\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;{% static teacher.photo %}\u0026#34; height=\u0026#34;140\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;info\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;{{ teacher.name }}\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{{ teacher.detail }}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;comment\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;/praise/?tno={{ teacher.no }}\u0026#34;\u0026gt;好评\u0026lt;/a\u0026gt; (\u0026lt;span\u0026gt;{{ teacher.good_count }}\u0026lt;/span\u0026gt;) \u0026amp;nbsp;\u0026amp;nbsp; \u0026lt;a href=\u0026#34;/criticize/?tno={{ teacher.no }}\u0026#34;\u0026gt;差评\u0026lt;/a\u0026gt; (\u0026lt;span\u0026gt;{{ teacher.bad_count }}\u0026lt;/span\u0026gt;) \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {% endfor %} {% else %} \u0026lt;h3\u0026gt;暂时没有该学科的老师信息\u0026lt;/h3\u0026gt; {% endif %} \u0026lt;p\u0026gt; \u0026lt;a href=\u0026#34;/\u0026#34;\u0026gt;返回首页\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; $(() =\u0026gt; { $(\u0026#39;.comment\u0026gt;a\u0026#39;).on(\u0026#39;click\u0026#39;, (evt) =\u0026gt; { evt.preventDefault() let anchor = $(evt.target) let url = anchor.attr(\u0026#39;href\u0026#39;) $.getJSON(url, (json) =\u0026gt; { if (json.code == 10001) { let span = anchor.next() span.text(parseInt(span.text()) + 1) } else { alert(json.hint) } }) }) }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 小结 到此为止，这个投票项目的核心功能已然完成，在下面的章节中我们会要求用户必须登录才能投票，没有账号的用户可以通过注册功能注册一个账号。\n"},{"idx":34,"href":"/python100days/docs/Day41-55/44-%E8%A1%A8%E5%8D%95%E7%9A%84%E5%BA%94%E7%94%A8/","title":"44 表单的应用","content":" 表单的应用 我们继续来完成上一章节中的项目，实现“用户注册”和“用户登录”的功能，并限制只有登录的用户才能为老师投票。Django框架中提供了对表单的封装，而且提供了多种不同的使用方式。\n首先添加用户模型。\nclass User(models.Model): \u0026#34;\u0026#34;\u0026#34;用户\u0026#34;\u0026#34;\u0026#34; no = models.AutoField(primary_key=True, verbose_name=\u0026#39;编号\u0026#39;) username = models.CharField(max_length=20, unique=True, verbose_name=\u0026#39;用户名\u0026#39;) password = models.CharField(max_length=32, verbose_name=\u0026#39;密码\u0026#39;) regdate = models.DateTimeField(auto_now_add=True, verbose_name=\u0026#39;注册时间\u0026#39;) class Meta: db_table = \u0026#39;tb_user\u0026#39; verbose_name_plural = \u0026#39;用户\u0026#39; 通过生成迁移和执行迁移操作，在数据库中创建对应的用户表。\n(venv)$ python manage.py makemigrations vote ... (venv)$ python manage.py migrate ... 定制一个非常简单的注册模板页面。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;用户注册\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt;/* 此处省略层叠样式表选择器 */\u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;用户注册\u0026lt;/h1\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;p class=\u0026#34;hint\u0026#34;\u0026gt;{{ hint }}\u0026lt;/p\u0026gt; \u0026lt;form action=\u0026#34;/register/\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; {% csrf_token %} \u0026lt;div class=\u0026#34;input\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;username\u0026#34;\u0026gt;用户名：\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;username\u0026#34; name=\u0026#34;username\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;input\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;password\u0026#34;\u0026gt;密码：\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; id=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;input\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;repassword\u0026#34;\u0026gt;确认密码：\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; id=\u0026#34;repassword\u0026#34; name=\u0026#34;repassword\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;input\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;注册\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;reset\u0026#34; value=\u0026#34;重置\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;a href=\u0026#34;/login\u0026#34;\u0026gt;返回登录\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 注意，在上面的表单中，我们使用了模板指令{% csrf_token %}为表单添加一个隐藏域（type属性值为hidden的input标签），它的作用是在表单中生成一个随机令牌（token）来防范跨站请求伪造（通常简称为CSRF），这也是Django在提交表单时的硬性要求，除非我们设置了免除CSRF令牌。下图是一个关于CSRF简单生动的例子，它来自于维基百科。\n用户在提交注册表单时，我们还需要对用户的输入进行验证，例如我们的网站要求用户名必须由字母、数字、下划线构成且长度在4-20个字符之间，密码的长度为8-20个字符，确认密码必须跟密码保持一致。这些验证操作首先可以通过浏览器中的JavaScript代码来完成，但是即便如此，在服务器端仍然要对用户输入再次进行验证来避免将无效的数据库交给数据库，因为用户可能会禁用浏览器的JavaScript功能，也有可能绕过浏览器的输入检查将注册数据提交给服务器，所以服务器端的用户输入检查仍然是必要的。\n我们可以利用Django框架封装的表单功能来对用户输入的有效性进行检查，虽然Django封装的表单还能帮助我们定制出页面上的表单元素，但这显然是一种灵活性很差的设计，这样的功能在实际开发中基本不考虑，所以表单主要的作用就在于数据验证，具体的做法如下所示。\nUSERNAME_PATTERN = re.compile(r\u0026#39;\\w{4,20}\u0026#39;) class RegisterForm(forms.ModelForm): repassword = forms.CharField(min_length=8, max_length=20) def clean_username(self): username = self.cleaned_data[\u0026#39;username\u0026#39;] if not USERNAME_PATTERN.fullmatch(username): raise ValidationError(\u0026#39;用户名由字母、数字和下划线构成且长度为4-20个字符\u0026#39;) return username def clean_password(self): password = self.cleaned_data[\u0026#39;password\u0026#39;] if len(password) \u0026lt; 8 or len(password) \u0026gt; 20: raise ValidationError(\u0026#39;无效的密码，密码长度为8-20个字符\u0026#39;) return to_md5_hex(self.cleaned_data[\u0026#39;password\u0026#39;]) def clean_repassword(self): repassword = to_md5_hex(self.cleaned_data[\u0026#39;repassword\u0026#39;]) if repassword != self.cleaned_data[\u0026#39;password\u0026#39;]: raise ValidationError(\u0026#39;密码和确认密码不一致\u0026#39;) return repassword class Meta: model = User exclude = (\u0026#39;no\u0026#39;, \u0026#39;regdate\u0026#39;) 上面，我们定义了一个与User模型绑定的表单（继承自ModelForm），我们排除了用户编号（no）和注册日期（regdate）这两个属性，并添加了一个repassword属性用来接收从用户表单传给服务器的确认密码。我们在定义User模型时已经对用户名的最大长度进行了限制，上面我们又对确认密码的最小和最大长度进行了限制，但是这些都不足以完成我们对用户输入的验证。上面以clean_打头的方法就是我们自定义的验证规则。很明显，clean_username是对用户名的检查，而clean_password是对密码的检查。由于数据库二维表中不应该保存密码的原文，所以对密码做了一个简单的MD5摘要处理，实际开发中如果只做出这样的处理还不太够，因为即便使用了摘要，仍然有利用彩虹表反向查询破解用户密码的风险，如何做得更好我们会在后续的内容中讲到。为字符串生成MD5摘要的代码如下所示。\ndef to_md5_hex(message): return hashlib.md5(message.encode()).hexdigest() 新增一个视图函数实现用户注册的功能。\ndef register(request): page, hint = \u0026#39;register.html\u0026#39;, \u0026#39;\u0026#39; if request.method == \u0026#39;POST\u0026#39;: form = RegisterForm(request.POST) if form.is_valid(): form.save() page = \u0026#39;login.html\u0026#39; hint = \u0026#39;注册成功，请登录\u0026#39; else: hint = \u0026#39;请输入有效的注册信息\u0026#39; return render(request, page, {\u0026#39;hint\u0026#39;: hint}) 如果用户发起GET请求，将直接跳转到注册的页面；如果用户以POST方式提交注册表单，则创建自定义的注册表单对象并获取用户输入。可以通过表单对象的is_valid方法对表单进行验证，如果用户输入没有问题，该方法返回True，否则返回False；由于我们定义的RegisterForm继承自ModelForm，因此也可以直接使用表单对象的save方法来保存模型。下面是注册请求的URL配置。\nfrom django.contrib import admin from django.urls import path from vote import views urlpatterns = [ # 此处省略上面的代码 path(\u0026#39;register/\u0026#39;, views.register, name=\u0026#39;register\u0026#39;), # 此处省略下面的代码 ]  说明：path函数可以通过name参数给URL绑定一个逆向解析的名字，也就是说，如果需要可以从后面给的名字逆向解析出对应的URL。\n 我们再来定制一个非常简单的登录页。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;用户登录\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt;/* 此处省略层叠样式表选择器 */\u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;用户登录\u0026lt;/h1\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;p class=\u0026#34;hint\u0026#34;\u0026gt;{{ hint }}\u0026lt;/p\u0026gt; \u0026lt;form action=\u0026#34;/login/\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; {% csrf_token %} \u0026lt;div class=\u0026#34;input\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;username\u0026#34;\u0026gt;用户名：\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;username\u0026#34; name=\u0026#34;username\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;input\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;password\u0026#34;\u0026gt;密码：\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; id=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;input captcha\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;captcha\u0026#34;\u0026gt;验证码：\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;captcha\u0026#34; name=\u0026#34;captcha\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;/captcha/\u0026#34; width=\u0026#34;120\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;input\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;登录\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;reset\u0026#34; value=\u0026#34;重置\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;a href=\u0026#34;/register\u0026#34;\u0026gt;注册新用户\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上面的登录页中，我们要求用户提供验证码，验证码全称是全自动区分计算机和人类的公开图灵测试，它是一种用来区分系统的使用者是计算机还是人类的程序。简单的说就是程序出一个只有人类能够回答的问题，由系统使用者来解答，由于计算机理论上无法解答程序提出的问题，所以回答出问题的用户就可以被认为是人类。大多数的网站都使用了不同类型的验证码技术来防范用程序自动注册用户或模拟用户登录（暴力破解用户密码），因为验证码具有一次消费性，而没有通过图灵测试的程序是不能够完成注册或登录的。\n在Python程序中生成验证码并不算特别复杂，但需要三方库Pillow的支持（PIL的分支），因为要对验证码图片进行旋转、扭曲、拉伸以及加入干扰信息来防范那些用OCR（光学文字识别）破解验证码的程序。下面的代码封装了生成验证码图片的功能，大家可以直接用这些代码来生成图片验证码，不要“重复发明轮子”。\n\u0026#34;\u0026#34;\u0026#34; 图片验证码 \u0026#34;\u0026#34;\u0026#34; import os import random from io import BytesIO from PIL import Image from PIL import ImageFilter from PIL.ImageDraw import Draw from PIL.ImageFont import truetype class Bezier(object): \u0026#34;\u0026#34;\u0026#34;贝塞尔曲线\u0026#34;\u0026#34;\u0026#34; def __init__(self): self.tsequence = tuple([t / 20.0 for t in range(21)]) self.beziers = {} def make_bezier(self, n): \u0026#34;\u0026#34;\u0026#34;绘制贝塞尔曲线\u0026#34;\u0026#34;\u0026#34; try: return self.beziers[n] except KeyError: combinations = pascal_row(n - 1) result = [] for t in self.tsequence: tpowers = (t ** i for i in range(n)) upowers = ((1 - t) ** i for i in range(n - 1, -1, -1)) coefs = [c * a * b for c, a, b in zip(combinations, tpowers, upowers)] result.append(coefs) self.beziers[n] = result return result class Captcha(object): \u0026#34;\u0026#34;\u0026#34;验证码\u0026#34;\u0026#34;\u0026#34; def __init__(self, width, height, fonts=None, color=None): self._image = None self._fonts = fonts if fonts else \\ [os.path.join(os.path.dirname(__file__), \u0026#39;fonts\u0026#39;, font) for font in [\u0026#39;ArialRB.ttf\u0026#39;, \u0026#39;ArialNI.ttf\u0026#39;, \u0026#39;Georgia.ttf\u0026#39;, \u0026#39;Kongxin.ttf\u0026#39;]] self._color = color if color else random_color(0, 200, random.randint(220, 255)) self._width, self._height = width, height @classmethod def instance(cls, width=200, height=75): prop_name = f\u0026#39;_instance_{width}_{height}\u0026#39; if not hasattr(cls, prop_name): setattr(cls, prop_name, cls(width, height)) return getattr(cls, prop_name) def background(self): \u0026#34;\u0026#34;\u0026#34;绘制背景\u0026#34;\u0026#34;\u0026#34; Draw(self._image).rectangle([(0, 0), self._image.size], fill=random_color(230, 255)) def smooth(self): \u0026#34;\u0026#34;\u0026#34;平滑图像\u0026#34;\u0026#34;\u0026#34; return self._image.filter(ImageFilter.SMOOTH) def curve(self, width=4, number=6, color=None): \u0026#34;\u0026#34;\u0026#34;绘制曲线\u0026#34;\u0026#34;\u0026#34; dx, height = self._image.size dx /= number path = [(dx * i, random.randint(0, height)) for i in range(1, number)] bcoefs = Bezier().make_bezier(number - 1) points = [] for coefs in bcoefs: points.append(tuple(sum([coef * p for coef, p in zip(coefs, ps)]) for ps in zip(*path))) Draw(self._image).line(points, fill=color if color else self._color, width=width) def noise(self, number=50, level=2, color=None): \u0026#34;\u0026#34;\u0026#34;绘制扰码\u0026#34;\u0026#34;\u0026#34; width, height = self._image.size dx, dy = width / 10, height / 10 width, height = width - dx, height - dy draw = Draw(self._image) for i in range(number): x = int(random.uniform(dx, width)) y = int(random.uniform(dy, height)) draw.line(((x, y), (x + level, y)), fill=color if color else self._color, width=level) def text(self, captcha_text, fonts, font_sizes=None, drawings=None, squeeze_factor=0.75, color=None): \u0026#34;\u0026#34;\u0026#34;绘制文本\u0026#34;\u0026#34;\u0026#34; color = color if color else self._color fonts = tuple([truetype(name, size) for name in fonts for size in font_sizes or (65, 70, 75)]) draw = Draw(self._image) char_images = [] for c in captcha_text: font = random.choice(fonts) c_width, c_height = draw.textsize(c, font=font) char_image = Image.new(\u0026#39;RGB\u0026#39;, (c_width, c_height), (0, 0, 0)) char_draw = Draw(char_image) char_draw.text((0, 0), c, font=font, fill=color) char_image = char_image.crop(char_image.getbbox()) for drawing in drawings: d = getattr(self, drawing) char_image = d(char_image) char_images.append(char_image) width, height = self._image.size offset = int((width - sum(int(i.size[0] * squeeze_factor) for i in char_images[:-1]) - char_images[-1].size[0]) / 2) for char_image in char_images: c_width, c_height = char_image.size mask = char_image.convert(\u0026#39;L\u0026#39;).point(lambda i: i * 1.97) self._image.paste(char_image, (offset, int((height - c_height) / 2)), mask) offset += int(c_width * squeeze_factor) @staticmethod def warp(image, dx_factor=0.3, dy_factor=0.3): \u0026#34;\u0026#34;\u0026#34;图像扭曲\u0026#34;\u0026#34;\u0026#34; width, height = image.size dx = width * dx_factor dy = height * dy_factor x1 = int(random.uniform(-dx, dx)) y1 = int(random.uniform(-dy, dy)) x2 = int(random.uniform(-dx, dx)) y2 = int(random.uniform(-dy, dy)) warp_image = Image.new( \u0026#39;RGB\u0026#39;, (width + abs(x1) + abs(x2), height + abs(y1) + abs(y2))) warp_image.paste(image, (abs(x1), abs(y1))) width2, height2 = warp_image.size return warp_image.transform( (width, height), Image.QUAD, (x1, y1, -x1, height2 - y2, width2 + x2, height2 + y2, width2 - x2, -y1)) @staticmethod def offset(image, dx_factor=0.1, dy_factor=0.2): \u0026#34;\u0026#34;\u0026#34;图像偏移\u0026#34;\u0026#34;\u0026#34; width, height = image.size dx = int(random.random() * width * dx_factor) dy = int(random.random() * height * dy_factor) offset_image = Image.new(\u0026#39;RGB\u0026#39;, (width + dx, height + dy)) offset_image.paste(image, (dx, dy)) return offset_image @staticmethod def rotate(image, angle=25): \u0026#34;\u0026#34;\u0026#34;图像旋转\u0026#34;\u0026#34;\u0026#34; return image.rotate(random.uniform(-angle, angle), Image.BILINEAR, expand=1) def generate(self, captcha_text=\u0026#39;\u0026#39;, fmt=\u0026#39;PNG\u0026#39;): \u0026#34;\u0026#34;\u0026#34;生成验证码(文字和图片)\u0026#34;\u0026#34;\u0026#34; self._image = Image.new(\u0026#39;RGB\u0026#39;, (self._width, self._height), (255, 255, 255)) self.background() self.text(captcha_text, self._fonts, drawings=[\u0026#39;warp\u0026#39;, \u0026#39;rotate\u0026#39;, \u0026#39;offset\u0026#39;]) self.curve() self.noise() self.smooth() image_bytes = BytesIO() self._image.save(image_bytes, format=fmt) return image_bytes.getvalue() def pascal_row(n=0): \u0026#34;\u0026#34;\u0026#34;生成Pascal三角第n行\u0026#34;\u0026#34;\u0026#34; result = [1] x, numerator = 1, n for denominator in range(1, n // 2 + 1): x *= numerator x /= denominator result.append(x) numerator -= 1 if n \u0026amp; 1 == 0: result.extend(reversed(result[:-1])) else: result.extend(reversed(result)) return result def random_color(start=0, end=255, opacity=255): \u0026#34;\u0026#34;\u0026#34;获得随机颜色\u0026#34;\u0026#34;\u0026#34; red = random.randint(start, end) green = random.randint(start, end) blue = random.randint(start, end) if opacity is None: return red, green, blue return red, green, blue, opacity  说明：上面的代码在生成验证码图片时用到了三种字体文件，使用上面的代码时需要添加字体文件到应用目录下的fonts目录中。\n 下面的视图函数用来生成验证码并通过HttpResponse对象输出到用户浏览器中。\nALL_CHARS = \u0026#39;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39; def get_captcha_text(length=4): selected_chars = random.choices(ALL_CHARS, k=length) return \u0026#39;\u0026#39;.join(selected_chars) def get_captcha(request): \u0026#34;\u0026#34;\u0026#34;获得验证码\u0026#34;\u0026#34;\u0026#34; captcha_text = get_captcha_text() image = Captcha.instance().generate(captcha_text) return HttpResponse(image, content_type=\u0026#39;image/png\u0026#39;) 生成的验证码如下图所示。\n为了验证用户提交的登录表单，我们再定义个表单类。\nclass LoginForm(forms.Form): username = forms.CharField(min_length=4, max_length=20) password = forms.CharField(min_length=8, max_length=20) captcha = forms.CharField(min_length=4, max_length=4) def clean_username(self): username = self.cleaned_data[\u0026#39;username\u0026#39;] if not USERNAME_PATTERN.fullmatch(username): raise ValidationError(\u0026#39;无效的用户名\u0026#39;) return username def clean_password(self): return to_md5_hex(self.cleaned_data[\u0026#39;password\u0026#39;]) 跟之前我们定义的注册表单类略有区别，登录表单类直接继承自Form没有跟模型绑定，定义了三个字段分别对应登录表单中的用户名、密码和验证码。接下来是处理用户登录的视图函数。\ndef login(request): hint = \u0026#39;\u0026#39; if request.method == \u0026#39;POST\u0026#39;: form = LoginForm(request.POST) if form.is_valid(): username = form.cleaned_data[\u0026#39;username\u0026#39;] password = form.cleaned_data[\u0026#39;password\u0026#39;] user = User.objects.filter(username=username, password=password).first() if user: return redirect(\u0026#39;/\u0026#39;) else: hint = \u0026#39;用户名或密码错误\u0026#39; else: hint = \u0026#39;请输入有效的登录信息\u0026#39; return render(request, \u0026#39;login.html\u0026#39;, {\u0026#39;hint\u0026#39;: hint}) 映射URL。\nfrom django.contrib import admin from django.urls import path from vote import views urlpatterns = [ # 此处省略上面的代码 path(\u0026#39;login/\u0026#39;, views.login, name=\u0026#39;login\u0026#39;), # 此处省略下面的代码 ] 需要指出，上面我们设定用户登录成功时直接返回首页，而且在用户登录时并没有验证用户输入的验证码是否正确，这些我们留到下一个单元再为大家讲解。另外，如果要在Django自带的管理后台中进行表单验证，可以在admin.py的模型管理类中指定form属性为自定义的表单即可，例如：\nclass UserForm(forms.ModelForm): password = forms.CharField(min_length=8, max_length=20, widget=forms.PasswordInput, label=\u0026#39;密码\u0026#39;) def clean_username(self): username = self.cleaned_data[\u0026#39;username\u0026#39;] if not USERNAME_PATTERN.fullmatch(username): raise ValidationError(\u0026#39;用户名由字母、数字和下划线构成且长度为4-20个字符\u0026#39;) return username def clean_password(self): password = self.cleaned_data[\u0026#39;password\u0026#39;] return to_md5_hex(self.cleaned_data[\u0026#39;password\u0026#39;]) class Meta: model = User exclude = (\u0026#39;no\u0026#39;, ) class UserAdmin(admin.ModelAdmin): list_display = (\u0026#39;no\u0026#39;, \u0026#39;username\u0026#39;, \u0026#39;password\u0026#39;, \u0026#39;email\u0026#39;, \u0026#39;tel\u0026#39;) ordering = (\u0026#39;no\u0026#39;, ) form = UserForm list_per_page = 10 admin.site.register(User, UserAdmin)"},{"idx":35,"href":"/python100days/docs/Day41-55/45-Cookie%E5%92%8CSession/","title":"45 Cookie和 Session","content":" Cookie和Session 实现用户跟踪 如今，一个网站如果不通过某种方式记住你是谁以及你之前在网站的活动情况，失去的就是网站的可用性和便利性，继而很有可能导致网站用户的流式，所以记住一个用户（更专业的说法叫用户跟踪）对绝大多数Web应用来说都是必需的功能。\n在服务器端，我们想记住一个用户最简单的办法就是创建一个对象，通过这个对象就可以把用户相关的信息都保存起来，这个对象就是我们常说的session（用户会话对象）。那么问题来了，HTTP本身是一个无连接（每次请求和响应的过程中，服务器一旦完成对客户端请求的响应之后就断开连接）、无状态（客户端再次发起对服务器的请求时，服务器无法得知这个客户端之前的任何信息）的协议，即便服务器通过session对象保留了用户数据，还得通过某种方式来确定当前的请求与之前保存过的哪一个session是有关联的。相信很多人都能想到，我们可以给每个session对象分配一个全局唯一的标识符来识别session对象，我们姑且称之为sessionid，每次客户端发起请求时，只要携带上这个sessionid，就有办法找到与之对应的session对象，从而实现在两次请求之间记住该用户的信息，也就是我们之前说的用户跟踪。\n要让客户端记住并在每次请求时带上sessionid又有以下几种做法：\n URL重写。所谓URL重写就是在URL中携带sessionid，例如：http://www.example.com/index.html?sessionid=123456，服务器通过获取sessionid参数的值来取到与之对应的session对象。\n 隐藏域（隐式表单域）。在提交表单的时候，可以通过在表单中设置隐藏域向服务器发送额外的数据。例如：\u0026lt;input type=\u0026quot;hidden\u0026quot; name=\u0026quot;sessionid\u0026quot; value=\u0026quot;123456\u0026quot;\u0026gt;。\n 本地存储。现在的浏览器都支持多种本地存储方案，包括：cookie、localStorage、sessionStorage、IndexedDB等。在这些方案中，cookie是历史最为悠久也是被诟病得最多的一种方案，也是我们接下来首先为大家讲解的一种方案。简单的说，cookie是一种以键值对方式保存在浏览器临时文件中的数据，每次请求时，请求头中会携带本站点的cookie到服务器，那么只要将sessionid写入cookie，下次请求时服务器只要读取请求头中的cookie就能够获得这个sessionid，如下图所示。\n  在HTML5时代要，除了cookie，还可以使用新的本地存储API来保存数据，就是刚才提到的localStorage、sessionStorage、IndexedDB等技术，如下图所示。\nDjango框架对session的支持 在创建Django项目时，默认的配置文件settings.py文件中已经激活了一个名为SessionMiddleware的中间件（关于中间件的知识我们在下一个章节做详细的讲解，这里只需要知道它的存在即可），因为这个中间件的存在，我们可以直接通过请求对象的session属性来操作会话对象。session属性是一个像字典一样可以读写数据的容器对象，因此我们可以使用“键值对”的方式来保留用户数据。与此同时，SessionMiddleware中间件还封装了对cookie的操作，在cookie中保存了sessionid，就如同我们之前描述的那样。\n在默认情况下，Django将session的数据序列化后保存在关系型数据库中，在Django 1.6以后的版本中，默认的序列化数据的方式是JSON序列化，而在此之前一直使用Pickle序列化。JSON序列化和Pickle序列化的差别在于前者将对象序列化为字符串（字符形式），而后者将对象序列化为字节串（二进制形式），因为安全方面的原因，JSON序列化成为了目前Django框架默认序列化数据的方式，这就要求在我们保存在session中的数据必须是能够JSON序列化的，否则就会引发异常。还有一点需要说明的是，使用关系型数据库保存session中的数据在大多数时候并不是最好的选择，因为数据库可能会承受巨大的压力而成为系统性能的瓶颈，在后面的章节中我们会告诉大家如何将session的数据保存到缓存服务中。\n我们继续完善之前的投票应用，前一个章节中我们实现了用户的登录和注册，下面我们首先完善登录时对验证码的检查。\ndef get_captcha(request): \u0026#34;\u0026#34;\u0026#34;验证码\u0026#34;\u0026#34;\u0026#34; captcha_text = random_captcha_text() request.session[\u0026#39;captcha\u0026#39;] = captcha_text image_data = Captcha.instance().generate(captcha_text) return HttpResponse(image_data, content_type=\u0026#39;image/png\u0026#39;) 注意上面代码中的第4行，我们将随机生成的验证码字符串保存到session中，稍后用户登录时，我们要将保存在session中的验证码字符串和用户输入的验证码字符串进行比对，如果用户输入了正确的验证码才能够执行后续的登录流程，代码如下所示。\ndef login(request: HttpRequest): \u0026#34;\u0026#34;\u0026#34;登录\u0026#34;\u0026#34;\u0026#34; hint = \u0026#39;\u0026#39; if request.method == \u0026#39;POST\u0026#39;: form = LoginForm(request.POST) if form.is_valid(): # 对验证码的正确性进行验证 captcha_from_user = form.cleaned_data[\u0026#39;captcha\u0026#39;] captcha_from_sess = request.session.get(\u0026#39;captcha\u0026#39;, \u0026#39;\u0026#39;) if captcha_from_sess.lower() != captcha_from_user.lower(): hint = \u0026#39;请输入正确的验证码\u0026#39; else: username = form.cleaned_data[\u0026#39;username\u0026#39;] password = form.cleaned_data[\u0026#39;password\u0026#39;] user = User.objects.filter(username=username, password=password).first() if user: # 登录成功后将用户编号和用户名保存在session中 request.session[\u0026#39;userid\u0026#39;] = user.no request.session[\u0026#39;username\u0026#39;] = user.username return redirect(\u0026#39;/\u0026#39;) else: hint = \u0026#39;用户名或密码错误\u0026#39; else: hint = \u0026#39;请输入有效的登录信息\u0026#39; return render(request, \u0026#39;login.html\u0026#39;, {\u0026#39;hint\u0026#39;: hint}) 上面的代码中，我们设定了登录成功后会在session中保存用户的编号（userid）和用户名（username），页面会重定向到首页。接下来我们可以稍微对首页的代码进行调整，在页面的右上角显示出登录用户的用户名。我们将这段代码单独写成了一个名为header.html的HTML文件，首页中可以通过在\u0026lt;body\u0026gt;标签中添加{% include 'header.html' %}来包含这个页面，代码如下所示。\n\u0026lt;div class=\u0026#34;user\u0026#34;\u0026gt; {% if request.session.userid %} \u0026lt;span\u0026gt;{{ request.session.username }}\u0026lt;/span\u0026gt; \u0026lt;a href=\u0026#34;/logout\u0026#34;\u0026gt;注销\u0026lt;/a\u0026gt; {% else %} \u0026lt;a href=\u0026#34;/login\u0026#34;\u0026gt;登录\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp; {% endif %} \u0026lt;a href=\u0026#34;/register\u0026#34;\u0026gt;注册\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; 如果用户没有登录，页面会显示登录和注册的超链接；而用户登录成功后，页面上会显示用户名和注销的链接，注销链接对应的视图函数如下所示，URL的映射与之前讲过的类似，不再赘述。\ndef logout(request): \u0026#34;\u0026#34;\u0026#34;注销\u0026#34;\u0026#34;\u0026#34; request.session.flush() return redirect(\u0026#39;/\u0026#39;) 上面的代码通过session对象flush方法来销毁session，一方面清除了服务器上session对象保存的用户数据，一方面将保存在浏览器cookie中的sessionid删除掉，稍后我们会对如何读写cookie的操作加以说明。\n我们可以通过项目使用的数据库中名为django_session 的表来找到所有的session，该表的结构如下所示：\n   session_key session_data expire_date     c9g2gt5cxo0k2evykgpejhic5ae7bfpl MmI4YzViYjJhOGMyMDJkY2M5Yzg3\u0026hellip; 2019-05-25 23:16:13.898522    其中，第1列就是浏览器cookie中保存的sessionid；第2列是经过BASE64编码后的session中的数据，如果使用Python的base64对其进行解码，解码的过程和结果如下所示。\n\u0026gt;\u0026gt;\u0026gt; import base64 \u0026gt;\u0026gt;\u0026gt; base64.b64decode(\u0026#39;MmI4YzViYjJhOGMyMDJkY2M5Yzg3ZWIyZGViZmUzYmYxNzdlNDdmZjp7ImNhcHRjaGEiOiJzS3d0Iiwibm8iOjEsInVzZXJuYW1lIjoiamFja2ZydWVkIn0=\u0026#39;) \u0026#39;2b8c5bb2a8c202dcc9c87eb2debfe3bf177e47ff:{\u0026#34;captcha\u0026#34;:\u0026#34;sKwt\u0026#34;,\u0026#34;no\u0026#34;:1,\u0026#34;username\u0026#34;:\u0026#34;jackfrued\u0026#34;}\u0026#39; 第3列是session的过期时间，session过期后浏览器保存的cookie中的sessionid就会失效，但是数据库中的这条对应的记录仍然会存在，如果想清除过期的数据，可以使用下面的命令。\npython manage.py clearsessions Django框架默认的session过期时间为两周（1209600秒），如果想修改这个时间，可以在项目的配置文件中添加如下所示的代码。\n# 配置会话的超时时间为1天（86400秒） SESSION_COOKIE_AGE = 86400 有很多对安全性要求较高的应用都必须在关闭浏览器窗口时让会话过期，不再保留用户的任何信息，如果希望在关闭浏览器窗口时就让会话过期（cookie中的sessionid失效），可以加入如下所示的配置。\n# 设置为True在关闭浏览器窗口时session就过期 SESSION_EXPIRE_AT_BROWSER_CLOSE = True 如果不希望将session的数据保存在数据库中，可以将其放入缓存中，对应的配置如下所示，缓存的配置和使用我们在后面讲解。\n# 配置将会话对象放到缓存中存储 SESSION_ENGINE = \u0026#39;django.contrib.sessions.backends.cache\u0026#39; # 配置使用哪一组缓存来保存会话 SESSION_CACHE_ALIAS = \u0026#39;default\u0026#39; 如果要修改session数据默认的序列化方式，可以将默认的JSONSerializer修改为PickleSerializer。\nSESSION_SERIALIZER = \u0026#39;django.contrib.sessions.serializers.PickleSerializer\u0026#39; 在视图函数中读写cookie Django封装的HttpRequest和HttpResponse对象分别提供了读写cookie的操作。\nHttpRequest封装的属性和方法：\n COOKIES属性 - 该属性包含了HTTP请求携带的所有cookie。 get_signed_cookie方法 - 获取带签名的cookie，如果签名验证失败，会产生BadSignature异常。  HttpResponse封装的方法：\n set_cookie方法 - 该方法可以设置一组键值对并将其最终将写入浏览器。 set_signed_cookie方法 - 跟上面的方法作用相似，但是会对cookie进行签名来达到防篡改的作用。因为如果篡改了cookie中的数据，在不知道密钥和盐的情况下是无法生成有效的签名，这样服务器在读取cookie时会发现数据与签名不一致从而产生BadSignature异常。需要说明的是，这里所说的密钥就是我们在Django项目配置文件中指定的SECRET_KEY，而盐是程序中设定的一个字符串，你愿意设定为什么都可以，只要是一个有效的字符串。  上面提到的方法，如果不清楚它们的具体用法，可以自己查阅一下Django的官方文档，没有什么资料比官方文档能够更清楚的告诉你这些方法到底如何使用。\n刚才我们说过了，激活SessionMiddleware之后，每个HttpRequest对象都会绑定一个session属性，它是一个类似字典的对象，除了保存用户数据之外还提供了检测浏览器是否支持cookie的方法，包括：\n set_test_cookie方法 - 设置用于测试的cookie。 test_cookie_worked方法 - 检测测试cookie是否工作。 delete_test_cookie方法 - 删除用于测试的cookie。 set_expiry方法 - 设置会话的过期时间。 get_expire_age/get_expire_date方法 - 获取会话的过期时间。 clear_expired方法 - 清理过期的会话。  下面是在执行登录之前检查浏览器是否支持cookie的代码。\ndef login(request): if request.method == \u0026#39;POST\u0026#39;: if request.session.test_cookie_worked(): request.session.delete_test_cookie() # Add your code to perform login process here else: return HttpResponse(\u0026#34;Please enable cookies and try again.\u0026#34;) request.session.set_test_cookie() return render_to_response(\u0026#39;login.html\u0026#39;) Cookie的替代品 之前我们说过了，cookie的名声一直都不怎么好，当然我们在实际开发中是不会在cookie中保存用户的敏感信息（如用户的密码、信用卡的账号等）的，而且保存在cookie中的数据一般也会做好编码和签名的工作。即便如此，HTML5中还是给出了用于替代cookie的技术方案，其中使用得最为广泛的就是localStorage和sessionStorage，相信从名字上你就能听出二者的差别，存储在localStorage的数据可以长期保留；而存储在sessionStorage的数据会在浏览器关闭时会被清除 。关于这些cookie替代品的用法，建议大家查阅MDN来进行了解。\n"},{"idx":36,"href":"/python100days/docs/Day41-55/46-%E6%8A%A5%E8%A1%A8%E5%92%8C%E6%97%A5%E5%BF%97/","title":"46 报表和日志","content":" 报表和日志 导出Excel报表 报表就是用表格、图表等格式来动态显示数据，所以有人用这样的公式来描述报表：\n报表 = 多样的格式 + 动态的数据  有很多的三方库支持在Python程序中写Excel文件，包括xlwt、xlwings、openpyxl、xlswriter、pandas等，其中的xlwt虽然只支持写xls格式的Excel文件，但在性能方面的表现还是不错的。下面我们就以xlwt为例，来演示如何在Django项目中导出Excel报表，例如导出一个包含所有老师信息的Excel表格。\ndef export_teachers_excel(request): # 创建工作簿 wb = xlwt.Workbook() # 添加工作表 sheet = wb.add_sheet(\u0026#39;老师信息表\u0026#39;) # 查询所有老师的信息(注意：这个地方稍后需要优化) queryset = Teacher.objects.all() # 向Excel表单中写入表头 colnames = (\u0026#39;姓名\u0026#39;, \u0026#39;介绍\u0026#39;, \u0026#39;好评数\u0026#39;, \u0026#39;差评数\u0026#39;, \u0026#39;学科\u0026#39;) for index, name in enumerate(colnames): sheet.write(0, index, name) # 向单元格中写入老师的数据 props = (\u0026#39;name\u0026#39;, \u0026#39;detail\u0026#39;, \u0026#39;good_count\u0026#39;, \u0026#39;bad_count\u0026#39;, \u0026#39;subject\u0026#39;) for row, teacher in enumerate(queryset): for col, prop in enumerate(props): value = getattr(teacher, prop, \u0026#39;\u0026#39;) if isinstance(value, Subject): value = value.name sheet.write(row + 1, col, value) # 保存Excel buffer = BytesIO() wb.save(buffer) # 将二进制数据写入响应的消息体中并设置MIME类型 resp = HttpResponse(buffer.getvalue(), content_type=\u0026#39;application/vnd.ms-excel\u0026#39;) # 中文文件名需要处理成百分号编码 filename = quote(\u0026#39;老师.xls\u0026#39;) # 通过响应头告知浏览器下载该文件以及对应的文件名 resp[\u0026#39;content-disposition\u0026#39;] = f\u0026#39;attachment; filename=\u0026#34;{filename}\u0026#34;\u0026#39; return resp 映射URL。\nurlpatterns = [ # 此处省略上面的代码 path(\u0026#39;excel/\u0026#39;, views.export_teachers_excel), # 此处省略下面的代码 ] 生成前端统计图表 如果项目中需要生成前端统计图表，可以使用百度的ECharts。具体的做法是后端通过提供数据接口返回统计图表所需的数据，前端使用ECharts来渲染出柱状图、折线图、饼图、散点图等图表。例如我们要生成一个统计所有老师好评数和差评数的报表，可以按照下面的方式来做。\ndef get_teachers_data(request): # 查询所有老师的信息(注意：这个地方稍后也需要优化) queryset = Teacher.objects.all() # 用生成式将老师的名字放在一个列表中 names = [teacher.name for teacher in queryset] # 用生成式将老师的好评数放在一个列表中 good = [teacher.good_count for teacher in queryset] # 用生成式将老师的差评数放在一个列表中 bad = [teacher.bad_count for teacher in queryset] # 返回JSON格式的数据 return JsonResponse({\u0026#39;names\u0026#39;: names, \u0026#39;good\u0026#39;: good, \u0026#39;bad\u0026#39;: bad}) 映射URL。\nurlpatterns = [ # 此处省略上面的代码 path(\u0026#39;teachers_data/\u0026#39;, views.export_teachers_excel), # 此处省略下面的代码 ] 使用ECharts生成柱状图。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;老师评价统计\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;main\u0026#34; style=\u0026#34;width: 600px; height: 400px\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;p\u0026gt; \u0026lt;a href=\u0026#34;/\u0026#34;\u0026gt;返回首页\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.bootcss.com/echarts/4.2.1-rc1/echarts.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; var myChart = echarts.init(document.querySelector(\u0026#39;#main\u0026#39;)) fetch(\u0026#39;/teachers_data/\u0026#39;) .then(resp =\u0026gt; resp.json()) .then(json =\u0026gt; { var option = { color: [\u0026#39;#f00\u0026#39;, \u0026#39;#00f\u0026#39;], title: { text: \u0026#39;老师评价统计图\u0026#39; }, tooltip: {}, legend: { data:[\u0026#39;好评\u0026#39;, \u0026#39;差评\u0026#39;] }, xAxis: { data: json.names }, yAxis: {}, series: [ { name: \u0026#39;好评\u0026#39;, type: \u0026#39;bar\u0026#39;, data: json.good }, { name: \u0026#39;差评\u0026#39;, type: \u0026#39;bar\u0026#39;, data: json.bad } ] } myChart.setOption(option) }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 运行效果如下图所示。\n配置日志 项目开发阶段，显示足够的调试信息以辅助开发人员调试代码还是非常必要的；项目上线以后，将系统运行时出现的警告、错误等信息记录下来以备相关人员了解系统运行状况并维护代码也是很有必要的。要做好这两件事件，我们需要为Django项目配置日志。\nDjango的日志配置基本可以参照官方文档再结合项目实际需求来进行，这些内容基本上可以从官方文档上复制下来，然后进行局部的调整即可，下面给出一些参考配置。\nLOGGING = { \u0026#39;version\u0026#39;: 1, # 是否禁用已经存在的日志器 \u0026#39;disable_existing_loggers\u0026#39;: False, # 日志格式化器 \u0026#39;formatters\u0026#39;: { \u0026#39;simple\u0026#39;: { \u0026#39;format\u0026#39;: \u0026#39;%(asctime)s%(module)s.%(funcName)s: %(message)s\u0026#39;, \u0026#39;datefmt\u0026#39;: \u0026#39;%Y-%m-%d%H:%M:%S\u0026#39;, }, \u0026#39;verbose\u0026#39;: { \u0026#39;format\u0026#39;: \u0026#39;%(asctime)s%(levelname)s[%(process)d-%(threadName)s] \u0026#39; \u0026#39;%(module)s.%(funcName)sline %(lineno)d: %(message)s\u0026#39;, \u0026#39;datefmt\u0026#39;: \u0026#39;%Y-%m-%d%H:%M:%S\u0026#39;, } }, # 日志过滤器 \u0026#39;filters\u0026#39;: { # 只有在Django配置文件中DEBUG值为True时才起作用 \u0026#39;require_debug_true\u0026#39;: { \u0026#39;()\u0026#39;: \u0026#39;django.utils.log.RequireDebugTrue\u0026#39;, }, }, # 日志处理器 \u0026#39;handlers\u0026#39;: { # 输出到控制台 \u0026#39;console\u0026#39;: { \u0026#39;class\u0026#39;: \u0026#39;logging.StreamHandler\u0026#39;, \u0026#39;level\u0026#39;: \u0026#39;DEBUG\u0026#39;, \u0026#39;filters\u0026#39;: [\u0026#39;require_debug_true\u0026#39;], \u0026#39;formatter\u0026#39;: \u0026#39;simple\u0026#39;, }, # 输出到文件(每周切割一次) \u0026#39;file1\u0026#39;: { \u0026#39;class\u0026#39;: \u0026#39;logging.handlers.TimedRotatingFileHandler\u0026#39;, \u0026#39;filename\u0026#39;: \u0026#39;access.log\u0026#39;, \u0026#39;when\u0026#39;: \u0026#39;W0\u0026#39;, \u0026#39;backupCount\u0026#39;: 12, \u0026#39;formatter\u0026#39;: \u0026#39;simple\u0026#39;, \u0026#39;level\u0026#39;: \u0026#39;INFO\u0026#39;, }, # 输出到文件(每天切割一次) \u0026#39;file2\u0026#39;: { \u0026#39;class\u0026#39;: \u0026#39;logging.handlers.TimedRotatingFileHandler\u0026#39;, \u0026#39;filename\u0026#39;: \u0026#39;error.log\u0026#39;, \u0026#39;when\u0026#39;: \u0026#39;D\u0026#39;, \u0026#39;backupCount\u0026#39;: 31, \u0026#39;formatter\u0026#39;: \u0026#39;verbose\u0026#39;, \u0026#39;level\u0026#39;: \u0026#39;WARNING\u0026#39;, }, }, # 日志器记录器 \u0026#39;loggers\u0026#39;: { \u0026#39;django\u0026#39;: { # 需要使用的日志处理器 \u0026#39;handlers\u0026#39;: [\u0026#39;console\u0026#39;, \u0026#39;file1\u0026#39;, \u0026#39;file2\u0026#39;], # 是否向上传播日志信息 \u0026#39;propagate\u0026#39;: True, # 日志级别(不一定是最终的日志级别) \u0026#39;level\u0026#39;: \u0026#39;DEBUG\u0026#39;, }, } } 大家可能已经注意到了，上面日志配置中的formatters是日志格式化器，它代表了如何格式化输出日志，其中格式占位符分别表示：\n %(name)s - 记录器的名称 %(levelno)s - 数字形式的日志记录级别 %(levelname)s - 日志记录级别的文本名称 %(filename)s - 执行日志记录调用的源文件的文件名称 %(pathname)s - 执行日志记录调用的源文件的路径名称 %(funcName)s - 执行日志记录调用的函数名称 %(module)s - 执行日志记录调用的模块名称 %(lineno)s - 执行日志记录调用的行号 %(created)s - 执行日志记录的时间 %(asctime)s - 日期和时间 %(msecs)s - 毫秒部分 %(thread)d - 线程ID（整数） %(threadName)s - 线程名称 %(process)d - 进程ID （整数）  日志配置中的handlers用来指定日志处理器，简单的说就是指定将日志输出到控制台还是文件又或者是网络上的服务器，可用的处理器包括：\n logging.StreamHandler(stream=None) - 可以向类似与sys.stdout或者sys.stderr的任何文件对象输出信息 logging.FileHandler(filename, mode=\u0026lsquo;a\u0026rsquo;, encoding=None, delay=False) - 将日志消息写入文件 logging.handlers.DatagramHandler(host, port) - 使用UDP协议，将日志信息发送到指定主机和端口的网络主机上 logging.handlers.HTTPHandler(host, url) - 使用HTTP的GET或POST方法将日志消息上传到一台HTTP 服务器 logging.handlers.RotatingFileHandler(filename, mode=\u0026lsquo;a\u0026rsquo;, maxBytes=0, backupCount=0, encoding=None, delay=False) - 将日志消息写入文件，如果文件的大小超出maxBytes指定的值，那么将重新生成一个文件来记录日志 logging.handlers.SocketHandler(host, port) - 使用TCP协议，将日志信息发送到指定主机和端口的网络主机上 logging.handlers.SMTPHandler(mailhost, fromaddr, toaddrs, subject, credentials=None, secure=None, timeout=1.0) - 将日志输出到指定的邮件地址 logging.MemoryHandler(capacity, flushLevel=ERROR, target=None, flushOnClose=True) - 将日志输出到内存指定的缓冲区中  上面每个日志处理器都指定了一个名为“level”的属性，它代表了日志的级别，不同的日志级别反映出日志中记录信息的严重性。Python中定义了六个级别的日志，按照从低到高的顺序依次是：NOTSET、DEBUG、INFO、WARNING、ERROR、CRITICAL。\n最后配置的日志记录器是用来真正输出日志的，Django框架提供了如下所示的内置记录器：\n django - 在Django层次结构中的所有消息记录器 django.request - 与请求处理相关的日志消息。5xx响应被视为错误消息；4xx响应被视为为警告消息 django.server - 与通过runserver调用的服务器所接收的请求相关的日志消息。5xx响应被视为错误消息；4xx响应被记录为警告消息；其他一切都被记录为INFO django.template - 与模板渲染相关的日志消息 django.db.backends - 有与数据库交互产生的日志消息，如果希望显示ORM框架执行的SQL语句，就可以使用该日志记录器。  日志记录器中配置的日志级别有可能不是最终的日志级别，因为还要参考日志处理器中配置的日志级别，取二者中级别较高者作为最终的日志级别。\n配置Django-Debug-Toolbar Django-Debug-Toolbar是项目开发阶段辅助调试和优化的神器，只要配置了它，就可以很方便的查看到如下表所示的项目运行信息，这些信息对调试项目和优化Web应用性能都是至关重要的。\n   项目 说明     Versions Django的版本   Time 显示视图耗费的时间   Settings 配置文件中设置的值   Headers HTTP请求头和响应头的信息   Request 和请求相关的各种变量及其信息   StaticFiles 静态文件加载情况   Templates 模板的相关信息   Cache 缓存的使用情况   Signals Django内置的信号信息   Logging 被记录的日志信息   SQL 向数据库发送的SQL语句及其执行时间     安装Django-Debug-Toolbar。\npip install django-debug-toolbar 配置 - 修改settings.py。\nINSTALLED_APPS = [ \u0026#39;debug_toolbar\u0026#39;, ] MIDDLEWARE = [ \u0026#39;debug_toolbar.middleware.DebugToolbarMiddleware\u0026#39;, ] DEBUG_TOOLBAR_CONFIG = { # 引入jQuery库 \u0026#39;JQUERY_URL\u0026#39;: \u0026#39;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js\u0026#39;, # 工具栏是否折叠 \u0026#39;SHOW_COLLAPSED\u0026#39;: True, # 是否显示工具栏 \u0026#39;SHOW_TOOLBAR_CALLBACK\u0026#39;: lambda x: True, } 配置 - 修改urls.py。\nif settings.DEBUG: import debug_toolbar urlpatterns.insert(0, path(\u0026#39;__debug__/\u0026#39;, include(debug_toolbar.urls))) 使用 - 如下图所示，在配置好Django-Debug-Toolbar之后，页面右侧会看到一个调试工具栏，上面包括了如前所述的各种调试信息，包括执行时间、项目设置、请求头、SQL、静态资源、模板、缓存、信号等，查看起来非常的方便。\n  优化ORM代码 在配置了日志或Django-Debug-Toolbar之后，我们可以查看一下之前将老师数据导出成Excel报表的视图函数执行情况，这里我们关注的是ORM框架生成的SQL查询到底是什么样子的，相信这里的结果会让你感到有一些意外。执行Teacher.objects.all()之后我们可以注意到，在控制台看到的或者通过Django-Debug-Toolbar输出的SQL是下面这样的：\nSELECT `tb_teacher`.`no`, `tb_teacher`.`name`, `tb_teacher`.`detail`, `tb_teacher`.`photo`, `tb_teacher`.`good_count`, `tb_teacher`.`bad_count`, `tb_teacher`.`sno` FROM `tb_teacher`; args=() SELECT `tb_subject`.`no`, `tb_subject`.`name`, `tb_subject`.`intro`, `tb_subject`.`create_date`, `tb_subject`.`is_hot` FROM `tb_subject` WHERE `tb_subject`.`no` = 101; args=(101,) SELECT `tb_subject`.`no`, `tb_subject`.`name`, `tb_subject`.`intro`, `tb_subject`.`create_date`, `tb_subject`.`is_hot` FROM `tb_subject` WHERE `tb_subject`.`no` = 101; args=(101,) SELECT `tb_subject`.`no`, `tb_subject`.`name`, `tb_subject`.`intro`, `tb_subject`.`create_date`, `tb_subject`.`is_hot` FROM `tb_subject` WHERE `tb_subject`.`no` = 101; args=(101,) SELECT `tb_subject`.`no`, `tb_subject`.`name`, `tb_subject`.`intro`, `tb_subject`.`create_date`, `tb_subject`.`is_hot` FROM `tb_subject` WHERE `tb_subject`.`no` = 101; args=(101,) SELECT `tb_subject`.`no`, `tb_subject`.`name`, `tb_subject`.`intro`, `tb_subject`.`create_date`, `tb_subject`.`is_hot` FROM `tb_subject` WHERE `tb_subject`.`no` = 103; args=(103,) SELECT `tb_subject`.`no`, `tb_subject`.`name`, `tb_subject`.`intro`, `tb_subject`.`create_date`, `tb_subject`.`is_hot` FROM `tb_subject` WHERE `tb_subject`.`no` = 103; args=(103,) 这里的问题通常被称为“1+N查询”（或“N+1查询”），原本获取老师的数据只需要一条SQL，但是由于老师关联了学科，当我们查询到N条老师的数据时，Django的ORM框架又向数据库发出了N条SQL去查询老师所属学科的信息。每条SQL执行都会有较大的开销而且会给数据库服务器带来压力，如果能够在一条SQL中完成老师和学科的查询肯定是更好的做法，这一点也很容易做到，相信大家已经想到怎么做了。是的，我们可以使用连接查询，但是在使用Django的ORM框架时如何做到这一点呢？对于多对一关联（如投票应用中的老师和学科），我们可以使用QuerySet的用select_related()方法来加载关联对象；而对于多对多关联（如电商网站中的订单和商品），我们可以使用prefetch_related()方法来加载关联对象。\n在导出老师Excel报表的视图函数中，我们可以按照下面的方式优化代码。\nqueryset = Teacher.objects.all().select_related(\u0026#39;subject\u0026#39;) 事实上，用ECharts生成前端报表的视图函数中，查询老师好评和差评数据的操作也能够优化，因为在这个例子中，我们只需要获取老师的姓名、好评数和差评数这三项数据，但是在默认的情况生成的SQL会查询老师表的所有字段。可以用QuerySet的only()方法来指定需要查询的属性，也可以用QuerySet的defer()方法来指定暂时不需要查询的属性，这样生成的SQL会通过投影操作来指定需要查询的列，从而改善查询性能，代码如下所示：\nqueryset = Teacher.objects.all().only(\u0026#39;name\u0026#39;, \u0026#39;good_count\u0026#39;, \u0026#39;bad_count\u0026#39;) 当然，如果要统计出每个学科的老师好评和差评的平均数，利用Django的ORM框架也能够做到，代码如下所示：\nqueryset = Teacher.objects.values(\u0026#39;subject\u0026#39;).annotate( good=Avg(\u0026#39;good_count\u0026#39;), bad=Avg(\u0026#39;bad_count\u0026#39;)) 这里获得的QuerySet中的元素是字典对象，每个字典中有三组键值对，分别是代表学科编号的subject、代表好评数的good和代表差评数的bad。如果想要获得学科的名称而不是编号，可以按照如下所示的方式调整代码：\nqueryset = Teacher.objects.values(\u0026#39;subject__name\u0026#39;).annotate( good=Avg(\u0026#39;good_count\u0026#39;), bad=Avg(\u0026#39;bad_count\u0026#39;)) 可见，Django的ORM框架允许我们用面向对象的方式完成关系数据库中的分组和聚合查询。\n"},{"idx":37,"href":"/python100days/docs/Day41-55/47-%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%BA%94%E7%94%A8/","title":"47 中间件的应用","content":" 中间件的应用 实现登录验证 我们继续来完善投票应用。在上一个章节中，我们在用户登录成功后通过session保留了用户信息，接下来我们可以应用做一些调整，要求在为老师投票时必须要先登录，登录过的用户可以投票，否则就将用户引导到登录页面，为此我们可以这样修改视图函数。\ndef praise_or_criticize(request: HttpRequest): \u0026#34;\u0026#34;\u0026#34;投票\u0026#34;\u0026#34;\u0026#34; if \u0026#39;username\u0026#39; in request.session: try: tno = int(request.GET.get(\u0026#39;tno\u0026#39;, \u0026#39;0\u0026#39;)) teacher = Teacher.objects.get(no=tno) if request.path.startswith(\u0026#39;/praise\u0026#39;): teacher.good_count += 1 else: teacher.bad_count += 1 teacher.save() data = {\u0026#39;code\u0026#39;: 200, \u0026#39;message\u0026#39;: \u0026#39;操作成功\u0026#39;} except (ValueError, Teacher.DoesNotExist): data = {\u0026#39;code\u0026#39;: 404, \u0026#39;message\u0026#39;: \u0026#39;操作失败\u0026#39;} else: data = {\u0026#39;code\u0026#39;: 401, \u0026#39;message\u0026#39;: \u0026#39;请先登录\u0026#39;} return JsonResponse(data) 前端页面在收到{'code': 401, 'message': '请先登录'}后，可以将用户引导到登录页面，修改后的teacher.html页面的JavaScript代码部门如下所示。\n\u0026lt;script\u0026gt; $(() =\u0026gt; { $(\u0026#39;.comment \u0026gt; a\u0026#39;).on(\u0026#39;click\u0026#39;, (evt) =\u0026gt; { evt.preventDefault() let a = $(evt.target) $.getJSON(a.attr(\u0026#39;href\u0026#39;), (json) =\u0026gt; { if (json.code == 200) { let span = a.next() span.text(parseInt(span.text()) + 1) } else if (json.code == 401) { location.href = \u0026#39;/login/?backurl=\u0026#39; + location.href } else { alert(json.message) } }) }) }) \u0026lt;/script\u0026gt;  注意：为了在登录成功之后能够回到刚才投票的页面，我们在跳转登录时设置了一个backurl参数，把当前浏览器中的URL作为返回的页面地址。\n 这样我们已经实现了用户必须登录才能投票的限制，但是一个新的问题来了。如果我们的应用中有很多功能都需要用户先登录才能执行，例如将前面导出Excel报表和查看统计图表的功能都加以登录限制，那么我们是不是需要在每个视图函数中添加代码来检查session中是否包含了登录用户的信息呢？答案是否定的，如果这样做了，我们的视图函数中必然会充斥着大量的重复代码。编程大师*Martin Fowler*曾经说过：代码有很多种坏味道，重复是最坏的一种。在Django项目中，我们可以把验证用户是否登录这样的重复性代码放到中间件中。\nDjango中间件概述 中间件是安插在Web应用请求和响应过程之间的组件，它在整个Web应用中扮演了拦截过滤器的角色，通过中间件可以拦截请求和响应，并对请求和响应进行过滤（简单的说就是执行额外的处理）。通常，一个中间件组件只专注于完成一件特定的事，例如：Django框架通过SessionMiddleware中间件实现了对session的支持，又通过AuthenticationMiddleware中间件实现了基于session的请求认证。通过把多个中间件组合在一起，我们可以完成更为复杂的任务，Django框架就是这么做的。\nDjango项目的配置文件中就包含了对中间件的配置，代码如下所示。\nMIDDLEWARE = [ \u0026#39;django.middleware.security.SecurityMiddleware\u0026#39;, \u0026#39;django.contrib.sessions.middleware.SessionMiddleware\u0026#39;, \u0026#39;django.middleware.common.CommonMiddleware\u0026#39;, \u0026#39;django.middleware.csrf.CsrfViewMiddleware\u0026#39;, \u0026#39;django.contrib.auth.middleware.AuthenticationMiddleware\u0026#39;, \u0026#39;django.contrib.messages.middleware.MessageMiddleware\u0026#39;, \u0026#39;django.middleware.clickjacking.XFrameOptionsMiddleware\u0026#39;, ] 我们稍微为大家解释一下这些中间件的作用：\n CommonMiddleware - 基础设置中间件，可以处理以下一些配置参数。  DISALLOWED_USER_AGENTS - 不被允许的用户代理（浏览器） APPEND_SLASH - 是否追加/ USE_ETAG - 浏览器缓存相关  SecurityMiddleware - 安全相关中间件，可以处理和安全相关的配置项。  SECURE_HSTS_SECONDS - 强制使用HTTPS的时间 SECURE_HSTS_INCLUDE_SUBDOMAINS - HTTPS是否覆盖子域名 SECURE_CONTENT_TYPE_NOSNIFF - 是否允许浏览器推断内容类型 SECURE_BROWSER_XSS_FILTER - 是否启用跨站脚本攻击过滤器 SECURE_SSL_REDIRECT - 是否重定向到HTTPS连接 SECURE_REDIRECT_EXEMPT - 免除重定向到HTTPS  SessionMiddleware - 会话中间件。 CsrfViewMiddleware - 通过生成令牌，防范跨请求份伪的造中间件。 XFrameOptionsMiddleware - 通过设置请求头参数，防范点击劫持攻击的中间件。  在请求的过程中，上面的中间件会按照书写的顺序从上到下执行，然后是URL解析，最后请求才会来到视图函数；在响应的过程中，上面的中间件会按照书写的顺序从下到上执行，与请求时中间件执行的顺序正好相反。\n自定义中间件 Django中的中间件有两种实现方式：基于类的实现方式和基于函数的实现方式，后者更接近于装饰器的写法。装饰器实际上是代理模式的应用，将横切关注功能（与正常业务逻辑没有必然联系的功能，例如：身份认证、日志记录、编码转换之类的功能）置于代理中，由代理对象来完成被代理对象的行为并添加额外的功能。中间件对用户请求和响应进行拦截过滤并增加额外的处理，在这一点上它跟装饰器是完全一致的，所以基于函数的写法来实现中间件就跟装饰器的写法几乎一模一样。下面我们用自定义的中间件来实现用户登录验证的功能。\n\u0026#34;\u0026#34;\u0026#34; middlewares.py \u0026#34;\u0026#34;\u0026#34; from django.http import JsonResponse from django.shortcuts import redirect # 需要登录才能访问的资源路径 LOGIN_REQUIRED_URLS = { \u0026#39;/praise/\u0026#39;, \u0026#39;/criticize/\u0026#39;, \u0026#39;/excel/\u0026#39;, \u0026#39;/teachers_data/\u0026#39;, } def check_login_middleware(get_resp): def wrapper(request, *args, **kwargs): # 请求的资源路径在上面的集合中 if request.path in LOGIN_REQUIRED_URLS: # 会话中包含userid则视为已经登录 if \u0026#39;userid\u0026#39; not in request.session: # 判断是不是Ajax请求 if request.is_ajax(): # Ajax请求返回JSON数据提示用户登录 return JsonResponse({\u0026#39;code\u0026#39;: 10003, \u0026#39;hint\u0026#39;: \u0026#39;请先登录\u0026#39;}) else: backurl = request.get_full_path() # 非Ajax请求直接重定向到登录页 return redirect(f\u0026#39;/login/?backurl={backurl}\u0026#39;) return get_resp(request, *args, **kwargs) return wrapper 修改配置文件，激活中间件使其生效。\nMIDDLEWARE = [ \u0026#39;django.middleware.security.SecurityMiddleware\u0026#39;, \u0026#39;django.contrib.sessions.middleware.SessionMiddleware\u0026#39;, \u0026#39;django.middleware.common.CommonMiddleware\u0026#39;, \u0026#39;django.middleware.csrf.CsrfViewMiddleware\u0026#39;, \u0026#39;django.contrib.auth.middleware.AuthenticationMiddleware\u0026#39;, \u0026#39;django.contrib.messages.middleware.MessageMiddleware\u0026#39;, \u0026#39;django.middleware.clickjacking.XFrameOptionsMiddleware\u0026#39;, \u0026#39;debug_toolbar.middleware.DebugToolbarMiddleware\u0026#39;, \u0026#39;vote.middlewares.check_login_middleware\u0026#39;, ] 注意上面这个中间件列表中元素的顺序，当收到来自用户的请求时，中间件按照从上到下的顺序依次执行，这行完这些中间件以后，请求才会最终到达视图函数。当然，在这个过程中，用户的请求可以被拦截，就像上面我们自定义的中间件那样，如果用户在没有登录的情况下访问了受保护的资源，中间件会将请求直接重定向到登录页，后面的中间件和视图函数将不再执行。在响应用户请求的过程中，上面的中间件会按照从下到上的顺序依次执行，这样的话我们还可以对响应做进一步的处理。\n中间件执行的顺序是非常重要的，对于有依赖关系的中间件必须保证被依赖的中间件要置于依赖它的中间件的前面，就好比我们刚才自定义的中间件要放到SessionMiddleware的后面，因为我们要依赖这个中间件为请求绑定的session对象才能判定用户是否登录。\n小结 至此，除了对用户投票数量加以限制的功能外，这个投票应用就算基本完成了，整个项目的完整代码请参考https://github.com/jackfrued/django1902，其中用户注册时使用的手机验证码功能请大家使用自己注册的短信平台替代它。如果需要投票应用完整的视频讲解，可以在首页扫码打赏后留言联系作者获取视频下载地址，谢谢大家的理解和支持。\n"},{"idx":38,"href":"/python100days/docs/Day41-55/48-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/","title":"48 前后端分离开发入门","content":" 前后端分离开发入门 在传统的Web应用开发中，大多数的程序员会将浏览器作为前后端的分界线。将浏览器中为用户进行页面展示的部分称之为前端，而将运行在服务器，为前端提供业务逻辑和数据准备的所有代码统称为后端。所谓前后端分离的开发，就是前后端工程师约定好数据交互接口，并行的进行开发和测试，后端只提供数据，不负责将数据渲染到页面上，前端通过HTTP请求获取数据并负责将数据渲染到页面上，这个工作是交给浏览器中的JavaScript代码来完成。\n使用前后端分离开发有诸多的好处，下面我们简要的说下这些好处：\n 提升开发效率。前后端分离以后，可以实现前后端代码的解耦，只要前后端沟通约定好应用所需接口以及接口参数，便可以开始并行开发，无需等待对方的开发工作结束。在这种情况下，前后端工程师都可以只专注于自己的开发工作，有助于打造出更好的团队。除此之外，在前后端分离的开发模式下，即使需求发生变更，只要接口与数据格式不变，后端开发人员就不需要修改代码，只要前端进行变动即可。 增强代码的可维护性。前后端分离后，应用的代码不再是前后端混合，只有在运行期才会有调用依赖关系，这样的话维护代码的工作将变得轻松愉快很多，再不会牵一发而动全身。当你的代码变得简明且整洁时，代码的可读性和可维护性都会有质的提升。 支持多终端和服务化架构。前后端分离后，同一套数据接口可以为不同的终端提供服务，更有助于打造多终端应用；此外，由于后端提供的接口之间可以通过HTTP(S)进行调用，有助于打造服务化架构（包括微服务）。  接下来我们就用前后端分离的方式来改写之前的投票应用。\n返回JSON格式的数据 刚才说过，在前后端分离的开发模式下，后端需要为前端提供数据接口，这些接口通常返回JSON格式的数据。在Django项目中，我们可以先将对象处理成字典，然后就可以利用Django封装的JsonResponse向浏览器返回JSON格式的数据，具体的做法如下所示。\ndef show_subjects(request): queryset = Subject.objects.all() subjects = [] for subject in queryset: subjects.append({ \u0026#39;no\u0026#39;: subject.no, \u0026#39;name\u0026#39;: subject.name, \u0026#39;intro\u0026#39;: subject.intro, \u0026#39;isHot\u0026#39;: subject.is_hot }) return JsonResponse(subjects, safe=False) 上面的代码中，我们通过循环遍历查询学科得到的QuerySet对象，将每个学科的数据处理成一个字典，在将字典保存在名为subjects的列表容器中，最后利用JsonResponse完成对列表的序列化，向浏览器返回JSON格式的数据。由于JsonResponse序列化的是一个列表而不是字典，所以需要指定safe参数的值为False才能完成对subjects的序列化，否则会产生TypeError异常。\n可能大家已经发现了，自己写代码将一个对象转成字典是比较麻烦的，如果对象的属性很多而且某些属性又关联到一个比较复杂的对象时，情况会变得更加糟糕。为此我们可以使用一个名为bpmappers的三方库来简化将对象转成字典的操作，这个三方库本身也提供了对Django框架的支持。\n安装三方库bpmappers。\npip install bpmappers 编写映射器（实现对象到字典转换）。\nfrom bpmappers.djangomodel import ModelMapper from poll2.models import Subject class SubjectMapper(ModelMapper): class Meta: model = Subject 修改视图函数。\ndef show_subjects(request): queryset = Subject.objects.all() subjects = [] for subject in queryset: subjects.append(SubjectMapper(subject).as_dict()) return JsonResponse(subjects, safe=False) 配置URL映射，然后访问该接口，可以得到如下所示的JSON格式数据。\n[ { \u0026#34;no\u0026#34;: 101, \u0026#34;name\u0026#34;: \u0026#34;Python全栈+人工智能\u0026#34;, \u0026#34;intro\u0026#34;: \u0026#34;Python是一种计算机程序设计语言。是一种面向对象的动态类型语言，最初被设计用于编写自动化脚本(shell)，随着版本的不断更新和语言新功能的添加，越来越多被用于独立的、大型项目的开发。\u0026#34;, \u0026#34;create_date\u0026#34;: \u0026#34;2017-08-01\u0026#34;, \u0026#34;is_hot\u0026#34;: true }, // 此处省略下面的内容 ] 如果不希望在JSON数据中显示学科的成立时间，我们可以在映射器中排除create_date属性；如果希望将是否为热门学科对应的键取名为isHot（默认的名字是is_hot），也可以通过修改映射器来做到。具体的做法如下所示：\nfrom bpmappers import RawField from bpmappers.djangomodel import ModelMapper from poll2.models import Subject class SubjectMapper(ModelMapper): isHot = RawField(\u0026#39;is_hot\u0026#39;) class Meta: model = Subject exclude = (\u0026#39;create_date\u0026#39;, \u0026#39;is_hot\u0026#39;) 再次查看学科接口返回的JSON数据。\n[ { \u0026#34;no\u0026#34;: 101, \u0026#34;name\u0026#34;: \u0026#34;Python全栈+人工智能\u0026#34;, \u0026#34;intro\u0026#34;: \u0026#34;Python是一种计算机程序设计语言。是一种面向对象的动态类型语言，最初被设计用于编写自动化脚本(shell)，随着版本的不断更新和语言新功能的添加，越来越多被用于独立的、大型项目的开发。\u0026#34;, \u0026#34;isHot\u0026#34;: true }, // 此处省略下面的内容 ] 关于bpmappers详细的使用指南，请参考它的官方文档，这个官方文档是用日语书写的，可以使用浏览器的翻译功能将它翻译成你熟悉的语言即可。\n使用Vue.js渲染页面 关于Vue.js的知识，我们在第21天到第30天的内容中已经介绍过了，这里我们不再进行赘述。如果希望全面的了解和学习Vue.js，建议阅读它的官方教程或者在YouTube上搜索Vue.js的新手教程（Crash Course）进行学习。\n重新改写subjects.html页面，使用Vue.js来渲染页面。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;学科\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;所有学科\u0026lt;/h1\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div v-for=\u0026#34;subject in subjects\u0026#34;\u0026gt; \u0026lt;h3\u0026gt; \u0026lt;a :href=\u0026#34;getTeachersHref(subject.no)\u0026#34;\u0026gt;{{ subject.name }}\u0026lt;/a\u0026gt; \u0026lt;img v-if=\u0026#34;subject.isHot\u0026#34; src=\u0026#34;/static/images/hot.png\u0026#34; width=\u0026#34;32\u0026#34;\u0026gt; \u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{{ subject.intro }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.bootcss.com/vue/2.6.10/vue.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { subjects: [] }, created() { fetch(\u0026#39;/subjects/\u0026#39;) .then(resp =\u0026gt; resp.json()) .then(json =\u0026gt; this.subjects = json) }, methods: { getTeachersHref(sno) { return `/static/teachers.html/?sno=${sno}` } } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 前后端分离的开发需要将前端页面作为静态资源进行部署，项目实际上线的时候，我们会对整个Web应用进行动静分离，静态资源通过Nginx或Apache服务器进行部署，生成动态内容的Python程序部署在uWSGI或者Gunicorn服务器上，对动态内容的请求由Nginx或Apache路由到uWSGI或Gunicorn服务器上。\n在开发阶段，我们通常会使用Django自带的测试服务器，如果要尝试前后端分离，可以先将静态页面放在之前创建的放静态资源的目录下，具体的做法可以参考项目完整代码。\n"},{"idx":39,"href":"/python100days/docs/Day41-55/49-RESTful%E6%9E%B6%E6%9E%84%E5%92%8CDRF%E5%85%A5%E9%97%A8/","title":"49 R E S Tful架构和 D R F入门","content":" RESTful架构和DRF入门 "},{"idx":40,"href":"/python100days/docs/Day41-55/50-RESTful%E6%9E%B6%E6%9E%84%E5%92%8CDRF%E8%BF%9B%E9%98%B6/","title":"50 R E S Tful架构和 D R F进阶","content":" RESTful架构和DRF进阶 "},{"idx":41,"href":"/python100days/docs/Day41-55/51-%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98/","title":"51 使用缓存","content":" 使用缓存 "},{"idx":42,"href":"/python100days/docs/Day41-55/52-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91/","title":"52 文件上传和富文本编辑","content":" 文件上传和富文本编辑 "},{"idx":43,"href":"/python100days/docs/Day41-55/53-%E7%9F%AD%E4%BF%A1%E5%92%8C%E9%82%AE%E4%BB%B6/","title":"53 短信和邮件","content":" 短信和邮件 "},{"idx":44,"href":"/python100days/docs/Day41-55/54-%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/","title":"54 异步任务和定时任务","content":" 异步任务和定时任务 "},{"idx":45,"href":"/python100days/docs/Day41-55/55-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%92%8C%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF/","title":"55 单元测试和项目上线","content":" 单元测试和项目上线 "},{"idx":46,"href":"/python100days/docs/Day56-60/56-Flask%E5%85%A5%E9%97%A8/","title":"56 Flask入门","content":" Flask入门 "},{"idx":47,"href":"/python100days/docs/Day56-60/57-%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"57 模板的使用","content":" 模板的使用 "},{"idx":48,"href":"/python100days/docs/Day56-60/58-%E8%A1%A8%E5%8D%95%E7%9A%84%E5%A4%84%E7%90%86/","title":"58 表单的处理","content":" 表单的处理 "},{"idx":49,"href":"/python100days/docs/Day56-60/59-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/","title":"59 数据库操作","content":" 数据库操作 "},{"idx":50,"href":"/python100days/docs/Day56-60/60-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/","title":"60 项目实战","content":" 项目实战 "},{"idx":51,"href":"/python100days/docs/Day61-65/61-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/","title":"61 预备知识","content":" 预备知识 并发编程 所谓并发编程就是让程序中有多个部分能够并发或同时执行，并发编程带来的好处不言而喻，其中最为关键的两点是提升了执行效率和改善了用户体验。下面简单阐述一下Python中实现并发编程的三种方式：\n 多线程：Python中通过threading模块的Thread类并辅以Lock、Condition、Event、Semaphore和Barrier等类来支持多线程编程。Python解释器通过GIL（全局解释器锁）来防止多个线程同时执行本地字节码，这个锁对于CPython（Python解释器的官方实现）是必须的，因为CPython的内存管理并不是线程安全的。因为GIL的存在，Python的多线程并不能利用CPU的多核特性。\n 多进程：使用多进程可以有效的解决GIL的问题，Python中的multiprocessing模块提供了Process类来实现多进程，其他的辅助类跟threading模块中的类类似，由于进程间的内存是相互隔离的（操作系统对进程的保护），进程间通信（共享数据）必须使用管道、套接字等方式，这一点从编程的角度来讲是比较麻烦的，为此，Python的multiprocessing模块提供了一个名为Queue的类，它基于管道和锁机制提供了多个进程共享的队列。\n\u0026#34;\u0026#34;\u0026#34; 用下面的命令运行程序并查看执行时间，例如： time python3 example06.py real 0m20.657s user 1m17.749s sys 0m0.158s 使用多进程后实际执行时间为20.657秒，而用户时间1分17.749秒约为实际执行时间的4倍 这就证明我们的程序通过多进程使用了CPU的多核特性，而且这台计算机配置了4核的CPU \u0026#34;\u0026#34;\u0026#34; import concurrent.futures import math PRIMES = [ 1116281, 1297337, 104395303, 472882027, 533000389, 817504243, 982451653, 112272535095293, 112582705942171, 112272535095293, 115280095190773, 115797848077099, 1099726899285419 ] * 5 def is_prime(num): \u0026#34;\u0026#34;\u0026#34;判断素数\u0026#34;\u0026#34;\u0026#34; assert num \u0026gt; 0 for i in range(2, int(math.sqrt(num)) + 1): if num % i == 0: return False return num != 1 def main(): \u0026#34;\u0026#34;\u0026#34;主函数\u0026#34;\u0026#34;\u0026#34; with concurrent.futures.ProcessPoolExecutor() as executor: for number, prime in zip(PRIMES, executor.map(is_prime, PRIMES)): print(\u0026#39;%dis prime: %s\u0026#39; % (number, prime)) if __name__ == \u0026#39;__main__\u0026#39;: main() 异步编程（异步I/O）：所谓异步编程是通过调度程序从任务队列中挑选任务，调度程序以交叉的形式执行这些任务，我们并不能保证任务将以某种顺序去执行，因为执行顺序取决于队列中的一项任务是否愿意将CPU处理时间让位给另一项任务。异步编程通常通过多任务协作处理的方式来实现，由于执行时间和顺序的不确定，因此需要通过钩子函数（回调函数）或者Future对象来获取任务执行的结果。目前我们使用的Python 3通过asyncio模块以及await和async关键字（Python 3.5中引入，Python 3.7中正式成为关键字）提供了对异步I/O的支持。\nimport asyncio async def fetch(host): \u0026#34;\u0026#34;\u0026#34;从指定的站点抓取信息(协程函数)\u0026#34;\u0026#34;\u0026#34; print(f\u0026#39;Start fetching {host}\\n\u0026#39;) # 跟服务器建立连接 reader, writer = await asyncio.open_connection(host, 80) # 构造请求行和请求头 writer.write(b\u0026#39;GET / HTTP/1.1\\r\\n\u0026#39;) writer.write(f\u0026#39;Host: {host}\\r\\n\u0026#39;.encode()) writer.write(b\u0026#39;\\r\\n\u0026#39;) # 清空缓存区(发送请求) await writer.drain() # 接收服务器的响应(读取响应行和响应头) line = await reader.readline() while line != b\u0026#39;\\r\\n\u0026#39;: print(line.decode().rstrip()) line = await reader.readline() print(\u0026#39;\\n\u0026#39;) writer.close() def main(): \u0026#34;\u0026#34;\u0026#34;主函数\u0026#34;\u0026#34;\u0026#34; urls = (\u0026#39;www.sohu.com\u0026#39;, \u0026#39;www.douban.com\u0026#39;, \u0026#39;www.163.com\u0026#39;) # 获取系统默认的事件循环 loop = asyncio.get_event_loop() # 用生成式语法构造一个包含多个协程对象的列表 tasks = [fetch(url) for url in urls] # 通过asyncio模块的wait函数将协程列表包装成Task（Future子类）并等待其执行完成 # 通过事件循环的run_until_complete方法运行任务直到Future完成并返回它的结果 loop.run_until_complete(asyncio.wait(tasks)) loop.close() if __name__ == \u0026#39;__main__\u0026#39;: main()   说明：目前大多数网站都要求基于HTTPS通信，因此上面例子中的网络请求不一定能收到正常的响应，也就是说响应状态码不一定是200，有可能是3xx或者4xx。当然我们这里的重点不在于获得网站响应的内容，而是帮助大家理解asyncio模块以及async和await两个关键字的使用。\n 我们对三种方式的使用场景做一个简单的总结。\n以下情况需要使用多线程：\n 程序需要维护许多共享的状态（尤其是可变状态），Python中的列表、字典、集合都是线程安全的，所以使用线程而不是进程维护共享状态的代价相对较小。 程序会花费大量时间在I/O操作上，没有太多并行计算的需求且不需占用太多的内存。  以下情况需要使用多进程：\n 程序执行计算密集型任务（如：字节码操作、数据处理、科学计算）。 程序的输入可以并行的分成块，并且可以将运算结果合并。 程序在内存使用方面没有任何限制且不强依赖于I/O操作（如：读写文件、套接字等）。  最后，如果程序不需要真正的并发性或并行性，而是更多的依赖于异步处理和回调时，异步I/O就是一种很好的选择。另一方面，当程序中有大量的等待与休眠时，也应该考虑使用异步I/O。\n 扩展：关于进程，还需要做一些补充说明。首先，为了控制进程的执行，操作系统内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程使之继续执行，这种行为被称为进程切换（也叫调度）。进程切换是比较耗费资源的操作，因为在进行切换时首先要保存当前进程的上下文（内核再次唤醒该进程时所需要的状态，包括：程序计数器、状态寄存器、数据栈等），然后还要恢复准备执行的进程的上下文。正在执行的进程由于期待的某些事件未发生，如请求系统资源失败、等待某个操作完成、新数据尚未到达等原因会主动由运行状态变为阻塞状态，当进程进入阻塞状态，是不占用CPU资源的。这些知识对于理解到底选择哪种方式进行并发编程也是很重要的。\n I/O模式和事件驱动 对于一次I/O操作（以读操作为例），数据会先被拷贝到操作系统内核的缓冲区中，然后从操作系统内核的缓冲区拷贝到应用程序的缓冲区（这种方式称为标准I/O或缓存I/O，大多数文件系统的默认I/O都是这种方式），最后交给进程。所以说，当一个读操作发生时（写操作与之类似），它会经历两个阶段：(1)等待数据准备就绪；(2)将数据从内核拷贝到进程中。\n由于存在这两个阶段，因此产生了以下几种I/O模式：\n 阻塞 I/O（blocking I/O）：进程发起读操作，如果内核数据尚未就绪，进程会阻塞等待数据直到内核数据就绪并拷贝到进程的内存中。 非阻塞 I/O（non-blocking I/O）：进程发起读操作，如果内核数据尚未就绪，进程不阻塞而是收到内核返回的错误信息，进程收到错误信息可以再次发起读操作，一旦内核数据准备就绪，就立即将数据拷贝到了用户内存中，然后返回。 多路I/O复用（ I/O multiplexing）：监听多个I/O对象，当I/O对象有变化（数据就绪）的时候就通知用户进程。多路I/O复用的优势并不在于单个I/O操作能处理得更快，而是在于能处理更多的I/O操作。 异步 I/O（asynchronous I/O）：进程发起读操作后就可以去做别的事情了，内核收到异步读操作后会立即返回，所以用户进程不阻塞，当内核数据准备就绪时，内核发送一个信号给用户进程，告诉它读操作完成了。  通常，我们编写一个处理用户请求的服务器程序时，有以下三种方式可供选择：\n 每收到一个请求，创建一个新的进程，来处理该请求； 每收到一个请求，创建一个新的线程，来处理该请求； 每收到一个请求，放入一个事件列表，让主进程通过非阻塞I/O方式来处理请求  第1种方式实现比较简单，但由于创建进程开销比较大，会导致服务器性能比较差；第2种方式，由于要涉及到线程的同步，有可能会面临竞争、死锁等问题；第3种方式，就是所谓事件驱动的方式，它利用了多路I/O复用和异步I/O的优点，虽然代码逻辑比前面两种都复杂，但能达到最好的性能，这也是目前大多数网络服务器采用的方式。\n"},{"idx":52,"href":"/python100days/docs/Day61-65/62-Tornado%E5%85%A5%E9%97%A8/","title":"62 Tornado入门","content":" Tornado入门 Tornado概述 Python的Web框架种类繁多（比Python语言的关键字还要多），但在众多优秀的Web框架中，Tornado框架最适合用来开发需要处理长连接和应对高并发的Web应用。Tornado框架在设计之初就考虑到性能问题，通过对非阻塞I/O和epoll（Linux 2.5.44内核引入的一种多路I/O复用方式，旨在实现高性能网络服务，在BSD和macOS中是kqueue）的运用，Tornado可以处理大量的并发连接，更轻松的应对C10K（万级并发）问题，是非常理想的实时通信Web框架。\n 扩展：基于线程的Web服务器产品（如：Apache）会维护一个线程池来处理用户请求，当用户请求到达时就为该请求分配一个线程，如果线程池中没有空闲线程了，那么可以通过创建新的线程来应付新的请求，但前提是系统尚有空闲的内存空间，显然这种方式很容易将服务器的空闲内存耗尽（大多数Linux发行版本中，默认的线程栈大小为8M）。想象一下，如果我们要开发一个社交类应用，这类应用中，通常需要显示实时更新的消息、对象状态的变化和各种类型的通知，那也就意味着客户端需要保持请求连接来接收服务器的各种响应，在这种情况下，服务器上的工作线程很容易被耗尽，这也就意味着新的请求很有可能无法得到响应。\n Tornado框架源于FriendFeed网站，在FriendFeed网站被Facebook收购之后得以开源，正式发布的日期是2009年9月10日。Tornado能让你能够快速开发高速的Web应用，如果你想编写一个可扩展的社交应用、实时分析引擎，或RESTful API，那么Tornado框架就是很好的选择。Tornado其实不仅仅是一个Web开发的框架，它还是一个高性能的事件驱动网络访问引擎，内置了高性能的HTTP服务器和客户端（支持同步和异步请求），同时还对WebSocket提供了完美的支持。\n了解和学习Tornado最好的资料就是它的官方文档，在tornadoweb.org上面有很多不错的例子，你也可以在Github上找到Tornado的源代码和历史版本。\n5分钟上手Tornado  创建并激活虚拟环境。\nmkdir hello-tornado cd hello-tornado python3 -m venv venv source venv/bin/activate 安装Tornado。\npip install tornado 编写Web应用。\n\u0026#34;\u0026#34;\u0026#34; example01.py \u0026#34;\u0026#34;\u0026#34; import tornado.ioloop import tornado.web class MainHandler(tornado.web.RequestHandler): def get(self): self.write(\u0026#39;\u0026lt;h1\u0026gt;Hello, world!\u0026lt;/h1\u0026gt;\u0026#39;) def main(): app = tornado.web.Application(handlers=[(r\u0026#39;/\u0026#39;, MainHandler), ]) app.listen(8888) tornado.ioloop.IOLoop.current().start() if __name__ == \u0026#39;__main__\u0026#39;: main() 运行并访问应用。\npython example01.py  在上面的例子中，代码example01.py通过定义一个继承自RequestHandler的类（MainHandler）来处理用户请求，当请求到达时，Tornado会实例化这个类（创建MainHandler对象），并调用与HTTP请求方法（GET、POST等）对应的方法，显然上面的MainHandler只能处理GET请求，在收到GET请求时，它会将一段HTML的内容写入到HTTP响应中。main函数的第1行代码创建了Tornado框架中Application类的实例，它代表了我们的Web应用，而创建该实例最为重要的参数就是handlers，该参数告知Application对象，当收到一个请求时应该通过哪个类的对象来处理这个请求。在上面的例子中，当通过HTTP的GET请求访问站点根路径时，就会调用MainHandler的get方法。 main函数的第2行代码通过Application对象的listen方法指定了监听HTTP请求的端口。main函数的第3行代码用于获取Tornado框架的IOLoop实例并启动它，该实例代表一个条件触发的I/O循环，用于持续的接收来自于客户端的请求。\n 扩展：在Python 3中，IOLoop实例的本质就是asyncio的事件循环，该事件循环在非Windows系统中就是SelectorEventLoop对象，它基于selectors模块（高级I/O复用模块），会使用当前操作系统最高效的I/O复用选择器，例如在Linux环境下它使用EpollSelector，而在macOS和BSD环境下它使用的是KqueueSelector；在Python 2中，IOLoop直接使用select模块（低级I/O复用模块）的epoll或kqueue函数，如果这两种方式都不可用，则调用select函数实现多路I/O复用。当然，如果要支持高并发，你的系统最好能够支持epoll或者kqueue这两种多路I/O复用方式中的一种。\n 如果希望通过命令行参数来指定Web应用的监听端口，可以对上面的代码稍作修改。\n\u0026#34;\u0026#34;\u0026#34; example01.py \u0026#34;\u0026#34;\u0026#34; import tornado.ioloop import tornado.web from tornado.options import define, options, parse_command_line # 定义默认端口 define(\u0026#39;port\u0026#39;, default=8000, type=int) class MainHandler(tornado.web.RequestHandler): def get(self): self.write(\u0026#39;\u0026lt;h1\u0026gt;Hello, world!\u0026lt;/h1\u0026gt;\u0026#39;) def main(): # python example01.py --port=8000 parse_command_line() app = tornado.web.Application(handlers=[(r\u0026#39;/\u0026#39;, MainHandler), ]) app.listen(options.port) tornado.ioloop.IOLoop.current().start() if __name__ == \u0026#39;__main__\u0026#39;: main() 在启动Web应用时，如果没有指定端口，将使用define函数中设置的默认端口8000，如果要指定端口，可以使用下面的方式来启动Web应用。\npython example01.py --port=8000 路由解析 上面我们曾经提到过创建Application实例时需要指定handlers参数，这个参数非常重要，它应该是一个元组的列表，元组中的第一个元素是正则表达式，它用于匹配用户请求的资源路径；第二个元素是RequestHandler的子类。在刚才的例子中，我们只在handlers列表中放置了一个元组，事实上我们可以放置多个元组来匹配不同的请求（资源路径），而且可以使用正则表达式的捕获组来获取匹配的内容并将其作为参数传入到get、post这些方法中。\n\u0026#34;\u0026#34;\u0026#34; example02.py \u0026#34;\u0026#34;\u0026#34; import os import random import tornado.ioloop import tornado.web from tornado.options import define, options, parse_command_line # 定义默认端口 define(\u0026#39;port\u0026#39;, default=8000, type=int) class SayingHandler(tornado.web.RequestHandler): \u0026#34;\u0026#34;\u0026#34;自定义请求处理器\u0026#34;\u0026#34;\u0026#34; def get(self): sayings = [ \u0026#39;世上没有绝望的处境，只有对处境绝望的人\u0026#39;, \u0026#39;人生的道路在态度的岔口一分为二，从此通向成功或失败\u0026#39;, \u0026#39;所谓措手不及，不是说没有时间准备，而是有时间的时候没有准备\u0026#39;, \u0026#39;那些你认为不靠谱的人生里，充满你没有勇气做的事\u0026#39;, \u0026#39;在自己喜欢的时间里，按照自己喜欢的方式，去做自己喜欢做的事，这便是自由\u0026#39;, \u0026#39;有些人不属于自己，但是遇见了也弥足珍贵\u0026#39; ] # 渲染index.html模板页 self.render(\u0026#39;index.html\u0026#39;, message=random.choice(sayings)) class WeatherHandler(tornado.web.RequestHandler): \u0026#34;\u0026#34;\u0026#34;自定义请求处理器\u0026#34;\u0026#34;\u0026#34; def get(self, city): # Tornado框架会自动处理百分号编码的问题 weathers = { \u0026#39;北京\u0026#39;: {\u0026#39;temperature\u0026#39;: \u0026#39;-4~4\u0026#39;, \u0026#39;pollution\u0026#39;: \u0026#39;195 中度污染\u0026#39;}, \u0026#39;成都\u0026#39;: {\u0026#39;temperature\u0026#39;: \u0026#39;3~9\u0026#39;, \u0026#39;pollution\u0026#39;: \u0026#39;53 良\u0026#39;}, \u0026#39;深圳\u0026#39;: {\u0026#39;temperature\u0026#39;: \u0026#39;20~25\u0026#39;, \u0026#39;pollution\u0026#39;: \u0026#39;25 优\u0026#39;}, \u0026#39;广州\u0026#39;: {\u0026#39;temperature\u0026#39;: \u0026#39;18~23\u0026#39;, \u0026#39;pollution\u0026#39;: \u0026#39;56 良\u0026#39;}, \u0026#39;上海\u0026#39;: {\u0026#39;temperature\u0026#39;: \u0026#39;6~8\u0026#39;, \u0026#39;pollution\u0026#39;: \u0026#39;65 良\u0026#39;} } if city in weathers: self.render(\u0026#39;weather.html\u0026#39;, city=city, weather=weathers[city]) else: self.render(\u0026#39;index.html\u0026#39;, message=f\u0026#39;没有{city}的天气信息\u0026#39;) class ErrorHandler(tornado.web.RequestHandler): \u0026#34;\u0026#34;\u0026#34;自定义请求处理器\u0026#34;\u0026#34;\u0026#34; def get(self): # 重定向到指定的路径 self.redirect(\u0026#39;/saying\u0026#39;) def main(): \u0026#34;\u0026#34;\u0026#34;主函数\u0026#34;\u0026#34;\u0026#34; parse_command_line() app = tornado.web.Application( # handlers是按列表中的顺序依次进行匹配的 handlers=[ (r\u0026#39;/saying/?\u0026#39;, SayingHandler), (r\u0026#39;/weather/([^/]{2,})/?\u0026#39;, WeatherHandler), (r\u0026#39;/.+\u0026#39;, ErrorHandler), ], # 通过template_path参数设置模板页的路径 template_path=os.path.join(os.path.dirname(__file__), \u0026#39;templates\u0026#39;) ) app.listen(options.port) tornado.ioloop.IOLoop.current().start() if __name__ == \u0026#39;__main__\u0026#39;: main() 模板页index.html。\n\u0026lt;!-- index.html --\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Tornado基础\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;{{message}}\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 模板页weather.html。\n\u0026lt;!-- weather.html --\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Tornado基础\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;{{city}}\u0026lt;/h1\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;h2\u0026gt;温度：{{weather[\u0026#39;temperature\u0026#39;]}}摄氏度\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;污染指数：{{weather[\u0026#39;pollution\u0026#39;]}}\u0026lt;/h2\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Tornado的模板语法与其他的Web框架中使用的模板语法并没有什么实质性的区别，而且目前的Web应用开发更倡导使用前端渲染的方式来减轻服务器的负担，所以这里我们并不对模板语法和后端渲染进行深入的讲解。\n请求处理器 通过上面的代码可以看出，RequestHandler是处理用户请求的核心类，通过重写get、post、put、delete等方法可以处理不同类型的HTTP请求，除了这些方法之外，RequestHandler还实现了很多重要的方法，下面是部分方法的列表：\n get_argument / get_arguments / get_body_argument / get_body_arguments / get_query_arugment / get_query_arguments：获取请求参数。 set_status / send_error / set_header / add_header / clear_header / clear：操作状态码和响应头。 write / flush / finish / write_error：和输出相关的方法。 render / render_string：渲染模板。 redirect：请求重定向。 get_cookie / set_cookie / get_secure_cookie / set_secure_cookie / create_signed_value / clear_cookie / clear_all_cookies：操作Cookie。  我们用上面讲到的这些方法来完成下面的需求，访问页面时，如果Cookie中没有读取到用户信息则要求用户填写个人信息，如果从Cookie中读取到用户信息则直接显示用户信息。\n\u0026#34;\u0026#34;\u0026#34; example03.py \u0026#34;\u0026#34;\u0026#34; import os import re import tornado.ioloop import tornado.web from tornado.options import define, options, parse_command_line # 定义默认端口 define(\u0026#39;port\u0026#39;, default=8000, type=int) users = {} class User(object): \u0026#34;\u0026#34;\u0026#34;用户\u0026#34;\u0026#34;\u0026#34; def __init__(self, nickname, gender, birthday): self.nickname = nickname self.gender = gender self.birthday = birthday class MainHandler(tornado.web.RequestHandler): \u0026#34;\u0026#34;\u0026#34;自定义请求处理器\u0026#34;\u0026#34;\u0026#34; def get(self): # 从Cookie中读取用户昵称 nickname = self.get_cookie(\u0026#39;nickname\u0026#39;) if nickname in users: self.render(\u0026#39;userinfo.html\u0026#39;, user=users[nickname]) else: self.render(\u0026#39;userform.html\u0026#39;, hint=\u0026#39;请填写个人信息\u0026#39;) class UserHandler(tornado.web.RequestHandler): \u0026#34;\u0026#34;\u0026#34;自定义请求处理器\u0026#34;\u0026#34;\u0026#34; def post(self): # 从表单参数中读取用户昵称、性别和生日信息 nickname = self.get_body_argument(\u0026#39;nickname\u0026#39;).strip() gender = self.get_body_argument(\u0026#39;gender\u0026#39;) birthday = self.get_body_argument(\u0026#39;birthday\u0026#39;) # 检查用户昵称是否有效 if not re.fullmatch(r\u0026#39;\\w{6,20}\u0026#39;, nickname): self.render(\u0026#39;userform.html\u0026#39;, hint=\u0026#39;请输入有效的昵称\u0026#39;) elif nickname in users: self.render(\u0026#39;userform.html\u0026#39;, hint=\u0026#39;昵称已经被使用过\u0026#39;) else: users[nickname] = User(nickname, gender, birthday) # 将用户昵称写入Cookie并设置有效期为7天 self.set_cookie(\u0026#39;nickname\u0026#39;, nickname, expires_days=7) self.render(\u0026#39;userinfo.html\u0026#39;, user=users[nickname]) def main(): \u0026#34;\u0026#34;\u0026#34;主函数\u0026#34;\u0026#34;\u0026#34; parse_command_line() app = tornado.web.Application( handlers=[ (r\u0026#39;/\u0026#39;, MainHandler), (r\u0026#39;/register\u0026#39;, UserHandler) ], template_path=os.path.join(os.path.dirname(__file__), \u0026#39;templates\u0026#39;) ) app.listen(options.port) tornado.ioloop.IOLoop.current().start() if __name__ == \u0026#39;__main__\u0026#39;: main() 模板页userform.html。\n\u0026lt;!-- userform.html --\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Tornado基础\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .em { color: red; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;填写用户信息\u0026lt;/h1\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;p class=\u0026#34;em\u0026#34;\u0026gt;{{hint}}\u0026lt;/p\u0026gt; \u0026lt;form action=\u0026#34;/register\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;p\u0026gt; \u0026lt;label\u0026gt;昵称：\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;nickname\u0026#34;\u0026gt; （字母数字下划线，6-20个字符） \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;label\u0026gt;性别：\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; value=\u0026#34;男\u0026#34; checked\u0026gt;男 \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; value=\u0026#34;女\u0026#34;\u0026gt;女 \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;label\u0026gt;生日：\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;date\u0026#34; name=\u0026#34;birthday\u0026#34; value=\u0026#34;1990-01-01\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;确定\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 模板页userinfo.html。\n\u0026lt;!-- userinfo.html --\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Tornado基础\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;用户信息\u0026lt;/h1\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;h2\u0026gt;昵称：{{user.nickname}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;性别：{{user.gender}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;出生日期：{{user.birthday}}\u0026lt;/h2\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;"},{"idx":53,"href":"/python100days/docs/Day61-65/63-%E5%BC%82%E6%AD%A5%E5%8C%96/","title":"63 异步化","content":" 异步化 在前面的例子中，我们并没有对RequestHandler中的get或post方法进行异步处理，这就意味着，一旦在get或post方法中出现了耗时间的操作，不仅仅是当前请求被阻塞，按照Tornado框架的工作模式，其他的请求也会被阻塞，所以我们需要对耗时间的操作进行异步化处理。\n在Tornado稍早一些的版本中，可以用装饰器实现请求方法的异步化或协程化来解决这个问题。\n 给RequestHandler的请求处理函数添加@tornado.web.asynchronous装饰器，如下所示：\nclass AsyncReqHandler(RequestHandler): @tornado.web.asynchronous def get(self): http = httpclient.AsyncHTTPClient() http.fetch(\u0026#34;http://example.com/\u0026#34;, self._on_download) def _on_download(self, response): do_something_with_response(response) self.render(\u0026#34;template.html\u0026#34;) 给RequestHandler的请求处理函数添加@tornado.gen.coroutine装饰器，如下所示：\nclass GenAsyncHandler(RequestHandler): @tornado.gen.coroutine def get(self): http_client = AsyncHTTPClient() response = yield http_client.fetch(\u0026#34;http://example.com\u0026#34;) do_something_with_response(response) self.render(\u0026#34;template.html\u0026#34;) 使用@return_future装饰器，如下所示：\n@return_future def future_func(arg1, arg2, callback): # Do stuff (possibly asynchronous) callback(result) async def caller(): await future_func(arg1, arg2)  在Tornado 5.x版本中，这几个装饰器都被标记为deprcated（过时），我们可以通过Python 3.5中引入的async和await（在Python 3.7中已经成为正式的关键字）来达到同样的效果。当然，要实现异步化还得靠其他的支持异步操作的三方库来支持，如果请求处理函数中用到了不支持异步操作的三方库，就需要靠自己写包装类来支持异步化。\n下面的代码演示了在读写数据库时如何实现请求处理的异步化。我们用到的数据库建表语句如下所示：\ncreate database hrs default charset utf8; use hrs; /* 创建部门表 */ create table tb_dept ( dno int not null comment \u0026#39;部门编号\u0026#39;, dname varchar(10) not null comment \u0026#39;部门名称\u0026#39;, dloc varchar(20) not null comment \u0026#39;部门所在地\u0026#39;, primary key (dno) ); insert into tb_dept values (10, \u0026#39;会计部\u0026#39;, \u0026#39;北京\u0026#39;), (20, \u0026#39;研发部\u0026#39;, \u0026#39;成都\u0026#39;), (30, \u0026#39;销售部\u0026#39;, \u0026#39;重庆\u0026#39;), (40, \u0026#39;运维部\u0026#39;, \u0026#39;深圳\u0026#39;); 我们通过下面的代码实现了查询和新增部门两个操作。\nimport json import aiomysql import tornado import tornado.web from tornado.ioloop import IOLoop from tornado.options import define, parse_command_line, options define(\u0026#39;port\u0026#39;, default=8000, type=int) async def connect_mysql(): return await aiomysql.connect( host=\u0026#39;120.77.222.217\u0026#39;, port=3306, db=\u0026#39;hrs\u0026#39;, user=\u0026#39;root\u0026#39;, password=\u0026#39;123456\u0026#39;, ) class HomeHandler(tornado.web.RequestHandler): async def get(self, no): async with self.settings[\u0026#39;mysql\u0026#39;].cursor(aiomysql.DictCursor) as cursor: await cursor.execute(\u0026#34;select * from tb_dept where dno=%s\u0026#34;, (no, )) if cursor.rowcount == 0: self.finish(json.dumps({ \u0026#39;code\u0026#39;: 20001, \u0026#39;mesg\u0026#39;: f\u0026#39;没有编号为{no}的部门\u0026#39; })) return row = await cursor.fetchone() self.finish(json.dumps(row)) async def post(self, *args, **kwargs): no = self.get_argument(\u0026#39;no\u0026#39;) name = self.get_argument(\u0026#39;name\u0026#39;) loc = self.get_argument(\u0026#39;loc\u0026#39;) conn = self.settings[\u0026#39;mysql\u0026#39;] try: async with conn.cursor() as cursor: await cursor.execute(\u0026#39;insert into tb_dept values (%s, %s, %s)\u0026#39;, (no, name, loc)) await conn.commit() except aiomysql.MySQLError: self.finish(json.dumps({ \u0026#39;code\u0026#39;: 20002, \u0026#39;mesg\u0026#39;: \u0026#39;添加部门失败请确认部门信息\u0026#39; })) else: self.set_status(201) self.finish() def make_app(config): return tornado.web.Application( handlers=[(r\u0026#39;/api/depts/(.*)\u0026#39;, HomeHandler), ], **config ) def main(): parse_command_line() app = make_app({ \u0026#39;debug\u0026#39;: True, \u0026#39;mysql\u0026#39;: IOLoop.current().run_sync(connect_mysql) }) app.listen(options.port) IOLoop.current().start() if __name__ == \u0026#39;__main__\u0026#39;: main() 上面的代码中，我们用到了aiomysql这个三方库，它基于pymysql封装，实现了对MySQL操作的异步化。操作Redis可以使用aioredis，访问MongoDB可以使用motor，这些都是支持异步操作的三方库。\n"},{"idx":54,"href":"/python100days/docs/Day61-65/64-WebSocket%E7%9A%84%E5%BA%94%E7%94%A8/","title":"64 Web Socket的应用","content":" WebSocket的应用 Tornado的异步特性使其非常适合处理高并发的业务，同时也适合那些需要在客户端和服务器之间维持长连接的业务。传统的基于HTTP协议的Web应用，服务器和客户端（浏览器）的通信只能由客户端发起，这种单向请求注定了如果服务器有连续的状态变化，客户端（浏览器）是很难得知的。事实上，今天的很多Web应用都需要服务器主动向客户端（浏览器）发送数据，我们将这种通信方式称之为“推送”。过去很长一段时间，程序员都是用定时轮询（Polling）或长轮询（Long Polling）等方式来实现“推送”，但是这些都不是真正意义上的“推送”，而且浪费资源且效率低下。在HTML5时代，可以通过一种名为WebSocket的技术在服务器和客户端（浏览器）之间维持传输数据的长连接，这种方式可以实现真正的“推送”服务。\nWebSocket简介 WebSocket 协议在2008年诞生，2011年成为国际标准（RFC 6455），现在的浏览器都能够支持它，它可以实现浏览器和服务器之间的全双工通信。我们之前学习或了解过Python的Socket编程，通过Socket编程，可以基于TCP或UDP进行数据传输；而WebSocket与之类似，只不过它是基于HTTP来实现通信握手，使用TCP来进行数据传输。WebSocket的出现打破了HTTP请求和响应只能一对一通信的模式，也改变了服务器只能被动接受客户端请求的状况。目前有很多Web应用是需要服务器主动向客户端发送信息的，例如股票信息的网站可能需要向浏览器发送股票涨停通知，社交网站可能需要向用户发送好友上线提醒或聊天信息。\nWebSocket的特点如下所示：\n 建立在TCP协议之上，服务器端的实现比较容易。 与HTTP协议有着良好的兼容性，默认端口是80（WS）和443（WSS），通信握手阶段采用HTTP协议，能通过各种 HTTP 代理服务器（不容易被防火墙阻拦）。 数据格式比较轻量，性能开销小，通信高效。 可以发送文本，也可以发送二进制数据。 没有同源策略的限制，客户端（浏览器）可以与任意服务器通信。  WebSocket服务器端编程 Tornado框架中有一个tornado.websocket.WebSocketHandler类专门用于处理来自WebSocket的请求，通过继承该类并重写open、on_message、on_close 等方法来处理WebSocket通信，下面我们对WebSocketHandler的核心方法做一个简单的介绍。\n open(*args, **kwargs)方法：建立新的WebSocket连接后，Tornado框架会调用该方法，该方法的参数与RequestHandler的get方法的参数类似，这也就意味着在open方法中可以执行获取请求参数、读取Cookie信息这样的操作。\n on_message(message)方法：建立WebSocket之后，当收到来自客户端的消息时，Tornado框架会调用该方法，这样就可以对收到的消息进行对应的处理，必须重写这个方法。\n on_close()方法：当WebSocket被关闭时，Tornado框架会调用该方法，在该方法中可以通过close_code和close_reason了解关闭的原因。\n write_message(message, binary=False)方法：将指定的消息通过WebSocket发送给客户端，可以传递utf-8字符序列或者字节序列，如果message是一个字典，将会执行JSON序列化。正常情况下，该方法会返回一个Future对象；如果WebSocket被关闭了，将引发WebSocketClosedError。\n set_nodelay(value)方法：默认情况下，因为TCP的Nagle算法会导致短小的消息被延迟发送，在考虑到交互性的情况下就要通过将该方法的参数设置为True来避免延迟。\n close(code=None, reason=None)方法：主动关闭WebSocket，可以指定状态码（详见RFC 6455 7.4.1节）和原因。\n  WebSocket客户端编程  创建WebSocket对象。\nvar webSocket = new WebSocket(\u0026#39;ws://localhost:8000/ws\u0026#39;);    说明：webSocket对象的readyState属性表示该对象当前状态，取值为CONNECTING-正在连接，OPEN-连接成功可以通信，CLOSING-正在关闭，CLOSED-已经关闭。\n  编写回调函数。\nwebSocket.onopen = function(evt) { webSocket.send(\u0026#39;...\u0026#39;); }; webSocket.onmessage = function(evt) { console.log(evt.data); }; webSocket.onclose = function(evt) {}; webSocket.onerror = function(evt) {};    说明：如果要绑定多个事件回调函数，可以用addEventListener方法。另外，通过事件对象的data属性获得的数据可能是字符串，也有可能是二进制数据，可以通过webSocket对象的binaryType属性（blob、arraybuffer）或者通过typeof、instanceof运算符检查类型进行判定。\n 项目：Web聊天室 \u0026#34;\u0026#34;\u0026#34; handlers.py - 用户登录和聊天的处理器 \u0026#34;\u0026#34;\u0026#34; import tornado.web import tornado.websocket nicknames = set() connections = {} class LoginHandler(tornado.web.RequestHandler): def get(self): self.render(\u0026#39;login.html\u0026#39;, hint=\u0026#39;\u0026#39;) def post(self): nickname = self.get_argument(\u0026#39;nickname\u0026#39;) if nickname in nicknames: self.render(\u0026#39;login.html\u0026#39;, hint=\u0026#39;昵称已被使用，请更换昵称\u0026#39;) self.set_secure_cookie(\u0026#39;nickname\u0026#39;, nickname) self.render(\u0026#39;chat.html\u0026#39;) class ChatHandler(tornado.websocket.WebSocketHandler): def open(self): nickname = self.get_secure_cookie(\u0026#39;nickname\u0026#39;).decode() nicknames.add(nickname) for conn in connections.values(): conn.write_message(f\u0026#39;~~~{nickname}进入了聊天室~~~\u0026#39;) connections[nickname] = self def on_message(self, message): nickname = self.get_secure_cookie(\u0026#39;nickname\u0026#39;).decode() for conn in connections.values(): if conn is not self: conn.write_message(f\u0026#39;{nickname}说：{message}\u0026#39;) def on_close(self): nickname = self.get_secure_cookie(\u0026#39;nickname\u0026#39;).decode() del connections[nickname] nicknames.remove(nickname) for conn in connections.values(): conn.write_message(f\u0026#39;~~~{nickname}离开了聊天室~~~\u0026#39;)\u0026#34;\u0026#34;\u0026#34; run_chat_server.py - 聊天服务器 \u0026#34;\u0026#34;\u0026#34; import os import tornado.web import tornado.ioloop from handlers import LoginHandler, ChatHandler if __name__ == \u0026#39;__main__\u0026#39;: app = tornado.web.Application( handlers=[(r\u0026#39;/login\u0026#39;, LoginHandler), (r\u0026#39;/chat\u0026#39;, ChatHandler)], template_path=os.path.join(os.path.dirname(__file__), \u0026#39;templates\u0026#39;), static_path=os.path.join(os.path.dirname(__file__), \u0026#39;static\u0026#39;), cookie_secret=\u0026#39;MWM2MzEyOWFlOWRiOWM2MGMzZThhYTk0ZDNlMDA0OTU=\u0026#39;, ) app.listen(8888) tornado.ioloop.IOLoop.current().start()\u0026lt;!-- login.html --\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Tornado聊天室\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .hint { color: red; font-size: 0.8em; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div id=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;进入聊天室\u0026lt;/h1\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;p class=\u0026#34;hint\u0026#34;\u0026gt;{{hint}}\u0026lt;/p\u0026gt; \u0026lt;form method=\u0026#34;post\u0026#34; action=\u0026#34;/login\u0026#34;\u0026gt; \u0026lt;label\u0026gt;昵称：\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;请输入你的昵称\u0026#34; name=\u0026#34;nickname\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;登录\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;\u0026lt;!-- chat.html --\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Tornado聊天室\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;聊天室\u0026lt;/h1\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;div\u0026gt; \u0026lt;textarea id=\u0026#34;contents\u0026#34; rows=\u0026#34;20\u0026#34; cols=\u0026#34;120\u0026#34; readonly\u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;send\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;content\u0026#34; size=\u0026#34;50\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;send\u0026#34; value=\u0026#34;发送\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p\u0026gt; \u0026lt;a id=\u0026#34;quit\u0026#34; href=\u0026#34;javascript:void(0);\u0026#34;\u0026gt;退出聊天室\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; $(function() { // 将内容追加到指定的文本区  function appendContent($ta, message) { var contents = $ta.val(); contents += \u0026#39;\\n\u0026#39; + message; $ta.val(contents); $ta[0].scrollTop = $ta[0].scrollHeight; } // 通过WebSocket发送消息  function sendMessage() { message = $(\u0026#39;#content\u0026#39;).val().trim(); if (message.length \u0026gt; 0) { ws.send(message); appendContent($(\u0026#39;#contents\u0026#39;), \u0026#39;我说：\u0026#39; + message); $(\u0026#39;#content\u0026#39;).val(\u0026#39;\u0026#39;); } } // 创建WebSocket对象  var ws= new WebSocket(\u0026#39;ws://localhost:8888/chat\u0026#39;); // 连接建立后执行的回调函数  ws.onopen = function(evt) { $(\u0026#39;#contents\u0026#39;).val(\u0026#39;~~~欢迎您进入聊天室~~~\u0026#39;); }; // 收到消息后执行的回调函数  ws.onmessage = function(evt) { appendContent($(\u0026#39;#contents\u0026#39;), evt.data); }; // 为发送按钮绑定点击事件回调函数  $(\u0026#39;#send\u0026#39;).on(\u0026#39;click\u0026#39;, sendMessage); // 为文本框绑定按下回车事件回调函数  $(\u0026#39;#content\u0026#39;).on(\u0026#39;keypress\u0026#39;, function(evt) { keycode = evt.keyCode || evt.which; if (keycode == 13) { sendMessage(); } }); // 为退出聊天室超链接绑定点击事件回调函数  $(\u0026#39;#quit\u0026#39;).on(\u0026#39;click\u0026#39;, function(evt) { ws.close(); location.href = \u0026#39;/login\u0026#39;; }); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;"},{"idx":55,"href":"/python100days/docs/Day61-65/65-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/","title":"65 项目实战","content":" 项目实战 "},{"idx":56,"href":"/python100days/docs/Day66-75/66-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%92%8C%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/","title":"66 网络爬虫和相关工具","content":" 网络爬虫和相关工具 网络爬虫的概念 网络爬虫（web crawler），以前经常称之为网络蜘蛛（spider），是按照一定的规则自动浏览万维网并获取信息的机器人程序（或脚本），曾经被广泛的应用于互联网搜索引擎。使用过互联网和浏览器的人都知道，网页中除了供用户阅读的文字信息之外，还包含一些超链接。网络爬虫系统正是通过网页中的超链接信息不断获得网络上的其它页面。正因如此，网络数据采集的过程就像一个爬虫或者蜘蛛在网络上漫游，所以才被形象的称为网络爬虫或者网络蜘蛛。\n爬虫的应用领域 在理想的状态下，所有ICP（Internet Content Provider）都应该为自己的网站提供API接口来共享它们允许其他程序获取的数据，在这种情况下爬虫就不是必需品，国内比较有名的电商平台（如淘宝、京东等）、社交平台（如腾讯微博等）等网站都提供了自己的Open API，但是这类Open API通常会对可以抓取的数据以及抓取数据的频率进行限制。对于大多数的公司而言，及时的获取行业相关数据是企业生存的重要环节之一，然而大部分企业在行业数据方面的匮乏是其与生俱来的短板，合理的利用爬虫来获取数据并从中提取出有商业价值的信息是至关重要的。当然爬虫还有很多重要的应用领域，下面列举了其中的一部分：\n 搜索引擎 新闻聚合 社交应用 舆情监控 行业数据  合法性和背景调研 爬虫合法性探讨  网络爬虫领域目前还属于拓荒阶段，虽然互联网世界已经通过自己的游戏规则建立起一定的道德规范(Robots协议，全称是“网络爬虫排除标准”)，但法律部分还在建立和完善中，也就是说，现在这个领域暂时还是灰色地带。 “法不禁止即为许可”，如果爬虫就像浏览器一样获取的是前端显示的数据（网页上的公开信息）而不是网站后台的私密敏感信息，就不太担心法律法规的约束，因为目前大数据产业链的发展速度远远超过了法律的完善程度。 在爬取网站的时候，需要限制自己的爬虫遵守Robots协议，同时控制网络爬虫程序的抓取数据的速度；在使用数据的时候，必须要尊重网站的知识产权（从Web 2.0时代开始，虽然Web上的数据很多都是由用户提供的，但是网站平台是投入了运营成本的，当用户在注册和发布内容时，平台通常就已经获得了对数据的所有权、使用权和分发权）。如果违反了这些规定，在打官司的时候败诉几率相当高。  Robots.txt文件 大多数网站都会定义robots.txt文件，下面以淘宝的robots.txt文件为例，看看该网站对爬虫有哪些限制。\n User-agent: Baiduspider Allow: /article Allow: /oshtml Disallow: /product/ Disallow: / User-Agent: Googlebot Allow: /article Allow: /oshtml Allow: /product Allow: /spu Allow: /dianpu Allow: /oversea Allow: /list Disallow: / User-agent: Bingbot Allow: /article Allow: /oshtml Allow: /product Allow: /spu Allow: /dianpu Allow: /oversea Allow: /list Disallow: / User-Agent: 360Spider Allow: /article Allow: /oshtml Disallow: / User-Agent: Yisouspider Allow: /article Allow: /oshtml Disallow: / User-Agent: Sogouspider Allow: /article Allow: /oshtml Allow: /product Disallow: / User-Agent: Yahoo! Slurp Allow: /product Allow: /spu Allow: /dianpu Allow: /oversea Allow: /list Disallow: / User-Agent: * Disallow: /  注意上面robots.txt第一段的最后一行，通过设置“Disallow: /”禁止百度爬虫访问除了“Allow”规定页面外的其他所有页面。因此当你在百度搜索“淘宝”的时候，搜索结果下方会出现：“由于该网站的robots.txt文件存在限制指令（限制搜索引擎抓取），系统无法提供该页面的内容描述”。百度作为一个搜索引擎，至少在表面上遵守了淘宝网的robots.txt协议，所以用户不能从百度上搜索到淘宝内部的产品信息。\n相关工具介绍 HTTP协议 在开始讲解爬虫之前，我们稍微对HTTP（超文本传输协议）做一些回顾，因为我们在网页上看到的内容通常是浏览器执行HTML语言得到的结果，而HTTP就是传输HTML数据的协议。HTTP和其他很多应用级协议一样是构建在TCP（传输控制协议）之上的，它利用了TCP提供的可靠的传输服务实现了Web应用中的数据交换。按照维基百科上的介绍，设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法，也就是说这个协议是浏览器和Web服务器之间传输的数据的载体。关于这个协议的详细信息以及目前的发展状况，大家可以阅读阮一峰老师的《HTTP 协议入门》、《互联网协议入门》系列以及《图解HTTPS协议》进行了解，下图是我在四川省网络通信技术重点实验室工作期间用开源协议分析工具Ethereal（抓包工具WireShark的前身）截取的访问百度首页时的HTTP请求和响应的报文（协议数据），由于Ethereal截取的是经过网络适配器的数据，因此可以清晰的看到从物理链路层到应用层的协议数据。\nHTTP请求（请求行+请求头+空行+[消息体]）：\nHTTP响应（响应行+响应头+空行+消息体）：\n 说明：但愿这两张如同泛黄照片般的截图帮助你大概的了解到HTTP是一个怎样的协议。\n 相关工具  Chrome Developer Tools：谷歌浏览器内置的开发者工具。   POSTMAN：功能强大的网页调试与RESTful请求工具。   HTTPie：命令行HTTP客户端。\npip3 install httpiehttp --header http://www.scu.edu.cn HTTP/1.1 200 OK Accept-Ranges: bytes Cache-Control: private, max-age=600 Connection: Keep-Alive Content-Encoding: gzip Content-Language: zh-CN Content-Length: 14403 Content-Type: text/html Date: Sun, 27 May 2018 15:38:25 GMT ETag: \u0026#34;e6ec-56d3032d70a32-gzip\u0026#34; Expires: Sun, 27 May 2018 15:48:25 GMT Keep-Alive: timeout=5, max=100 Last-Modified: Sun, 27 May 2018 13:44:22 GMT Server: VWebServer Vary: User-Agent,Accept-Encoding X-Frame-Options: SAMEORIGIN BuiltWith：识别网站所用技术的工具。\npip3 install builtwith\u0026gt;\u0026gt;\u0026gt; import builtwith \u0026gt;\u0026gt;\u0026gt; builtwith.parse(\u0026#39;http://www.bootcss.com/\u0026#39;) {\u0026#39;web-servers\u0026#39;: [\u0026#39;Nginx\u0026#39;], \u0026#39;font-scripts\u0026#39;: [\u0026#39;Font Awesome\u0026#39;], \u0026#39;javascript-frameworks\u0026#39;: [\u0026#39;Lo-dash\u0026#39;, \u0026#39;Underscore.js\u0026#39;, \u0026#39;Vue.js\u0026#39;, \u0026#39;Zepto\u0026#39;, \u0026#39;jQuery\u0026#39;], \u0026#39;web-frameworks\u0026#39;: [\u0026#39;Twitter Bootstrap\u0026#39;]} \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; import ssl \u0026gt;\u0026gt;\u0026gt; ssl._create_default_https_context = ssl._create_unverified_context \u0026gt;\u0026gt;\u0026gt; builtwith.parse(\u0026#39;https://www.jianshu.com/\u0026#39;) {\u0026#39;web-servers\u0026#39;: [\u0026#39;Tengine\u0026#39;], \u0026#39;web-frameworks\u0026#39;: [\u0026#39;Twitter Bootstrap\u0026#39;, \u0026#39;Ruby on Rails\u0026#39;], \u0026#39;programming-languages\u0026#39;: [\u0026#39;Ruby\u0026#39;]} python-whois：查询网站所有者的工具。\npip3 install python-whois\u0026gt;\u0026gt;\u0026gt; import whois \u0026gt;\u0026gt;\u0026gt; whois.whois(\u0026#39;baidu.com\u0026#39;) {\u0026#39;domain_name\u0026#39;: [\u0026#39;BAIDU.COM\u0026#39;, \u0026#39;baidu.com\u0026#39;], \u0026#39;registrar\u0026#39;: \u0026#39;MarkMonitor, Inc.\u0026#39;, \u0026#39;whois_server\u0026#39;: \u0026#39;whois.markmonitor.com\u0026#39;, \u0026#39;referral_url\u0026#39;: None, \u0026#39;updated_date\u0026#39;: [datetime.datetime(2017, 7, 28, 2, 36, 28), datetime.datetime(2017, 7, 27, 19, 36, 28)], \u0026#39;creation_date\u0026#39;: [datetime.datetime(1999, 10, 11, 11, 5, 17), datetime.datetime(1999, 10, 11, 4, 5, 17)], \u0026#39;expiration_date\u0026#39;: [datetime.datetime(2026, 10, 11, 11, 5, 17), datetime.datetime(2026, 10, 11, 0, 0)], \u0026#39;name_servers\u0026#39;: [\u0026#39;DNS.BAIDU.COM\u0026#39;, \u0026#39;NS2.BAIDU.COM\u0026#39;, \u0026#39;NS3.BAIDU.COM\u0026#39;, \u0026#39;NS4.BAIDU.COM\u0026#39;, \u0026#39;NS7.BAIDU.COM\u0026#39;, \u0026#39;dns.baidu.com\u0026#39;, \u0026#39;ns4.baidu.com\u0026#39;, \u0026#39;ns3.baidu.com\u0026#39;, \u0026#39;ns7.baidu.com\u0026#39;, \u0026#39;ns2.baidu.com\u0026#39;], \u0026#39;status\u0026#39;: [\u0026#39;clientDeleteProhibited https://icann.org/epp#clientDeleteProhibited\u0026#39;, \u0026#39;clientTransferProhibited https://icann.org/epp#clientTransferProhibited\u0026#39;, \u0026#39;clientUpdateProhibited https://icann.org/epp#clientUpdateProhibited\u0026#39;, \u0026#39;serverDeleteProhibited https://icann.org/epp#serverDeleteProhibited\u0026#39;, \u0026#39;serverTransferProhibited https://icann.org/epp#serverTransferProhibited\u0026#39;, \u0026#39;serverUpdateProhibited https://icann.org/epp#serverUpdateProhibited\u0026#39;, \u0026#39;clientUpdateProhibited (https://www.icann.org/epp#clientUpdateProhibited)\u0026#39;, \u0026#39;clientTransferProhibited (https://www.icann.org/epp#clientTransferProhibited)\u0026#39;, \u0026#39;clientDeleteProhibited (https://www.icann.org/epp#clientDeleteProhibited)\u0026#39;, \u0026#39;serverUpdateProhibited (https://www.icann.org/epp#serverUpdateProhibited)\u0026#39;, \u0026#39;serverTransferProhibited (https://www.icann.org/epp#serverTransferProhibited)\u0026#39;, \u0026#39;serverDeleteProhibited (https://www.icann.org/epp#serverDeleteProhibited)\u0026#39;], \u0026#39;emails\u0026#39;: [\u0026#39;abusecomplaints@markmonitor.com\u0026#39;, \u0026#39;whoisrelay@markmonitor.com\u0026#39;], \u0026#39;dnssec\u0026#39;: \u0026#39;unsigned\u0026#39;, \u0026#39;name\u0026#39;: None, \u0026#39;org\u0026#39;: \u0026#39;Beijing Baidu Netcom Science Technology Co., Ltd.\u0026#39;, \u0026#39;address\u0026#39;: None, \u0026#39;city\u0026#39;: None, \u0026#39;state\u0026#39;: \u0026#39;Beijing\u0026#39;, \u0026#39;zipcode\u0026#39;: None, \u0026#39;country\u0026#39;: \u0026#39;CN\u0026#39;} robotparser：解析robots.txt的工具。\n\u0026gt;\u0026gt;\u0026gt; from urllib import robotparser \u0026gt;\u0026gt;\u0026gt; parser = robotparser.RobotFileParser() \u0026gt;\u0026gt;\u0026gt; parser.set_url(\u0026#39;https://www.taobao.com/robots.txt\u0026#39;) \u0026gt;\u0026gt;\u0026gt; parser.read() \u0026gt;\u0026gt;\u0026gt; parser.can_fetch(\u0026#39;Baiduspider\u0026#39;, \u0026#39;http://www.taobao.com/article\u0026#39;) True \u0026gt;\u0026gt;\u0026gt; parser.can_fetch(\u0026#39;Baiduspider\u0026#39;, \u0026#39;http://www.taobao.com/product\u0026#39;) False  一个简单的爬虫 一个基本的爬虫通常分为数据采集（网页下载）、数据处理（网页解析）和数据存储（将有用的信息持久化）三个部分的内容，当然更为高级的爬虫在数据采集和处理时会使用并发编程或分布式技术，这就需要有调度器（安排线程或进程执行对应的任务）、后台管理程序（监控爬虫的工作状态以及检查数据抓取的结果）等的参与。\n一般来说，爬虫的工作流程包括以下几个步骤：\n 设定抓取目标（种子页面/起始页面）并获取网页。 当服务器无法访问时，按照指定的重试次数尝试重新下载页面。 在需要的时候设置用户代理或隐藏真实IP，否则可能无法访问页面。 对获取的页面进行必要的解码操作然后抓取出需要的信息。 在获取的页面中通过某种方式（如正则表达式）抽取出页面中的链接信息。 对链接进行进一步的处理（获取页面并重复上面的动作）。 将有用的信息进行持久化以备后续的处理。  下面的例子给出了一个从“搜狐体育”上获取NBA新闻标题和链接的爬虫。\nfrom urllib.error import URLError from urllib.request import urlopen import re import pymysql import ssl from pymysql import Error def decode_page(page_bytes, charsets=(\u0026#39;utf-8\u0026#39;,)): \u0026#34;\u0026#34;\u0026#34;通过指定的字符集对页面进行解码(不是每个网站都将字符集设置为utf-8)\u0026#34;\u0026#34;\u0026#34; page_html = None for charset in charsets: try: page_html = page_bytes.decode(charset) break except UnicodeDecodeError: pass # logging.error(\u0026#39;Decode:\u0026#39;, error) return page_html def get_page_html(seed_url, *, retry_times=3, charsets=(\u0026#39;utf-8\u0026#39;,)): \u0026#34;\u0026#34;\u0026#34;获取页面的HTML代码(通过递归实现指定次数的重试操作)\u0026#34;\u0026#34;\u0026#34; page_html = None try: page_html = decode_page(urlopen(seed_url).read(), charsets) except URLError: # logging.error(\u0026#39;URL:\u0026#39;, error) if retry_times \u0026gt; 0: return get_page_html(seed_url, retry_times=retry_times - 1, charsets=charsets) return page_html def get_matched_parts(page_html, pattern_str, pattern_ignore_case=re.I): \u0026#34;\u0026#34;\u0026#34;从页面中提取需要的部分(通常是链接也可以通过正则表达式进行指定)\u0026#34;\u0026#34;\u0026#34; pattern_regex = re.compile(pattern_str, pattern_ignore_case) return pattern_regex.findall(page_html) if page_html else [] def start_crawl(seed_url, match_pattern, *, max_depth=-1): \u0026#34;\u0026#34;\u0026#34;开始执行爬虫程序并对指定的数据进行持久化操作\u0026#34;\u0026#34;\u0026#34; conn = pymysql.connect(host=\u0026#39;localhost\u0026#39;, port=3306, database=\u0026#39;crawler\u0026#39;, user=\u0026#39;root\u0026#39;, password=\u0026#39;123456\u0026#39;, charset=\u0026#39;utf8\u0026#39;) try: with conn.cursor() as cursor: url_list = [seed_url] # 通过下面的字典避免重复抓取并控制抓取深度 visited_url_list = {seed_url: 0} while url_list: current_url = url_list.pop(0) depth = visited_url_list[current_url] if depth != max_depth: # 尝试用utf-8/gbk/gb2312三种字符集进行页面解码 page_html = get_page_html(current_url, charsets=(\u0026#39;utf-8\u0026#39;, \u0026#39;gbk\u0026#39;, \u0026#39;gb2312\u0026#39;)) links_list = get_matched_parts(page_html, match_pattern) param_list = [] for link in links_list: if link not in visited_url_list: visited_url_list[link] = depth + 1 page_html = get_page_html(link, charsets=(\u0026#39;utf-8\u0026#39;, \u0026#39;gbk\u0026#39;, \u0026#39;gb2312\u0026#39;)) headings = get_matched_parts(page_html, r\u0026#39;\u0026lt;h1\u0026gt;(.*)\u0026lt;span\u0026#39;) if headings: param_list.append((headings[0], link)) cursor.executemany(\u0026#39;insert into tb_result values (default, %s, %s)\u0026#39;, param_list) conn.commit() except Error: pass # logging.error(\u0026#39;SQL:\u0026#39;, error) finally: conn.close() def main(): \u0026#34;\u0026#34;\u0026#34;主函数\u0026#34;\u0026#34;\u0026#34; ssl._create_default_https_context = ssl._create_unverified_context start_crawl(\u0026#39;http://sports.sohu.com/nba_a.shtml\u0026#39;, r\u0026#39;\u0026lt;a[^\u0026gt;]+test=a\\s[^\u0026gt;]*href=[\u0026#34;\\\u0026#39;](.*?)[\u0026#34;\\\u0026#39;]\u0026#39;, max_depth=2) if __name__ == \u0026#39;__main__\u0026#39;: main() 由于使用了MySQL实现持久化操作，所以要先启动MySQL服务器并创建名为crawler的数据库和名为tb_result的二维表才能运行该程序。\n爬虫注意事项 通过上面的例子，我们对爬虫已经有了一个感性的认识，在编写爬虫时有以下一些注意事项：\n 处理相对链接。有的时候我们从页面中获取的链接不是一个完整的绝对链接而是一个相对链接，这种情况下需要将其与URL前缀进行拼接（urllib.parse中的urljoin()函数可以完成此项操作）。\n 设置代理服务。有些网站会限制访问的区域（例如美国的Netflix屏蔽了很多国家的访问），有些爬虫需要隐藏自己的身份，在这种情况下可以设置使用代理服务器，代理服务器有免费的服务器和付费的商业服务器，但后者稳定性和可用性都更好，强烈建议在商业项目中使用付费的代理服务器。可以通过修改urllib.request中的ProxyHandler来为请求设置代理服务器。\n 限制下载速度。如果我们的爬虫获取网页的速度过快，可能就会面临被封禁或者产生“损害动产”的风险（这个可能会导致吃官司且败诉），可以在两次下载之间添加延时从而对爬虫进行限速。\n 避免爬虫陷阱。有些网站会动态生成页面内容，这会导致产生无限多的页面（例如在线万年历通常会有无穷无尽的链接）。可以通过记录到达当前页面经过了多少个链接（链接深度）来解决该问题，当达到事先设定的最大深度时爬虫就不再像队列中添加该网页中的链接了。\n SSL相关问题。在使用urlopen打开一个HTTPS链接时会验证一次SSL证书，如果不做出处理会产生错误提示“SSL: CERTIFICATE_VERIFY_FAILED”，可以通过以下两种方式加以解决：\n 使用未经验证的上下文\nimport ssl request = urllib.request.Request(url=\u0026#39;...\u0026#39;, headers={...}) context = ssl._create_unverified_context() web_page = urllib.request.urlopen(request, context=context) 设置全局性取消证书验证\nimport ssl ssl._create_default_https_context = ssl._create_unverified_context   "},{"idx":57,"href":"/python100days/docs/Day66-75/67-%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%92%8C%E8%A7%A3%E6%9E%90/","title":"67 数据采集和解析","content":" 数据采集和解析 通过上一个章节的讲解，我们已经了解到了开发一个爬虫需要做的工作以及一些常见的问题，下面我们给出一个爬虫开发相关技术的清单以及这些技术涉及到的标准库和第三方库，稍后我们会一一介绍这些内容。\n 下载数据 - urllib / requests / aiohttp。 解析数据 - re / lxml / beautifulsoup4 / pyquery。 缓存和持久化 - pymysql / sqlalchemy / peewee/ redis / pymongo。 生成数字签名 - hashlib。 序列化和压缩 - pickle / json / zlib。 调度器 - 多进程（multiprocessing） / 多线程（threading）。  HTML页面 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Home\u0026lt;/title\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; /* 此处省略层叠样式表代码 */ \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;wrapper\u0026#34;\u0026gt; \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;Yoko\u0026#39;s Kitchen\u0026lt;/h1\u0026gt; \u0026lt;nav\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;\u0026#34; class=\u0026#34;current\u0026#34;\u0026gt;Home\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;Classes\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;Catering\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;About\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;Contact\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;section class=\u0026#34;courses\u0026#34;\u0026gt; \u0026lt;article\u0026gt; \u0026lt;figure\u0026gt; \u0026lt;img src=\u0026#34;images/bok-choi.jpg\u0026#34; alt=\u0026#34;Bok Choi\u0026#34; /\u0026gt; \u0026lt;figcaption\u0026gt;Bok Choi\u0026lt;/figcaption\u0026gt; \u0026lt;/figure\u0026gt; \u0026lt;hgroup\u0026gt; \u0026lt;h2\u0026gt;Japanese Vegetarian\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;Five week course in London\u0026lt;/h3\u0026gt; \u0026lt;/hgroup\u0026gt; \u0026lt;p\u0026gt;A five week introduction to traditional Japanese vegetarian meals, teaching you a selection of rice and noodle dishes.\u0026lt;/p\u0026gt; \u0026lt;/article\u0026gt; \u0026lt;article\u0026gt; \u0026lt;figure\u0026gt; \u0026lt;img src=\u0026#34;images/teriyaki.jpg\u0026#34; alt=\u0026#34;Teriyaki sauce\u0026#34; /\u0026gt; \u0026lt;figcaption\u0026gt;Teriyaki Sauce\u0026lt;/figcaption\u0026gt; \u0026lt;/figure\u0026gt; \u0026lt;hgroup\u0026gt; \u0026lt;h2\u0026gt;Sauces Masterclass\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;One day workshop\u0026lt;/h3\u0026gt; \u0026lt;/hgroup\u0026gt; \u0026lt;p\u0026gt;An intensive one-day course looking at how to create the most delicious sauces for use in a range of Japanese cookery.\u0026lt;/p\u0026gt; \u0026lt;/article\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;aside\u0026gt; \u0026lt;section class=\u0026#34;popular-recipes\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;Popular Recipes\u0026lt;/h2\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;Yakitori (grilled chicken)\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;Tsukune (minced chicken patties)\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;Okonomiyaki (savory pancakes)\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;Mizutaki (chicken stew)\u0026lt;/a\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section class=\u0026#34;contact-details\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;Contact\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Yoko\u0026#39;s Kitchen\u0026lt;br\u0026gt; 27 Redchurch Street\u0026lt;br\u0026gt; Shoreditch\u0026lt;br\u0026gt; London E2 7DP\u0026lt;/p\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/aside\u0026gt; \u0026lt;footer\u0026gt; \u0026amp;copy; 2011 Yoko\u0026#39;s Kitchen \u0026lt;/footer\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 此处省略JavaScript代码  \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 如果你对上面的代码并不感到陌生，那么你一定知道HTML页面通常由三部分构成，分别是用来承载内容的Tag（标签）、负责渲染页面的CSS（层叠样式表）以及控制交互式行为的JavaScript。通常，我们可以在浏览器的右键菜单中通过“查看网页源代码”的方式获取网页的代码并了解页面的结构；当然，我们也可以通过浏览器提供的开发人员工具来了解更多的信息。\n使用requests获取页面  GET请求和POST请求。\n URL参数和请求头。\n 复杂的POST请求（文件上传）。\n 操作Cookie。\n 设置代理服务器。\n   说明：关于requests的详细用法可以参考它的官方文档。\n 页面解析 几种解析方式的比较    解析方式 对应的模块 速度 使用难度 备注     正则表达式解析 re 快 困难 常用正则表达式在线正则表达式测试   XPath解析 lxml 快 一般 需要安装C语言依赖库唯一支持XML的解析器   CSS选择器解析 bs4 / pyquery 不确定 简单      说明：BeautifulSoup可选的解析器包括：Python标准库（html.parser）、lxml的HTML解析器、lxml的XML解析器和html5lib。\n 使用正则表达式解析页面 如果你对正则表达式没有任何的概念，那么推荐先阅读[《正则表达式30分钟入门教程》]()，然后再阅读我们之前讲解在Python中如何使用正则表达式一文。\nXPath解析和lxml XPath是在XML文档中查找信息的一种语法，它使用路径表达式来选取XML文档中的节点或者节点集。这里所说的XPath节点包括元素、属性、文本、命名空间、处理指令、注释、根节点等。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;bookstore\u0026gt; \u0026lt;book\u0026gt; \u0026lt;title lang=\u0026#34;eng\u0026#34;\u0026gt;Harry Potter\u0026lt;/title\u0026gt; \u0026lt;price\u0026gt;29.99\u0026lt;/price\u0026gt; \u0026lt;/book\u0026gt; \u0026lt;book\u0026gt; \u0026lt;title lang=\u0026#34;eng\u0026#34;\u0026gt;Learning XML\u0026lt;/title\u0026gt; \u0026lt;price\u0026gt;39.95\u0026lt;/price\u0026gt; \u0026lt;/book\u0026gt; \u0026lt;/bookstore\u0026gt; 对于上面的XML文件，我们可以用如下所示的XPath语法获取文档中的节点。\n   路径表达式 结果     bookstore 选取 bookstore 元素的所有子节点。   /bookstore 选取根元素 bookstore。注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！   bookstore/book 选取属于 bookstore 的子元素的所有 book 元素。   //book 选取所有 book 子元素，而不管它们在文档中的位置。   bookstore//book 选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。   //@lang 选取名为 lang 的所有属性。    在使用XPath语法时，还可以使用XPath中的谓词。\n   路径表达式 结果     /bookstore/book[1] 选取属于 bookstore 子元素的第一个 book 元素。   /bookstore/book[last()] 选取属于 bookstore 子元素的最后一个 book 元素。   /bookstore/book[last()-1] 选取属于 bookstore 子元素的倒数第二个 book 元素。   /bookstore/book[position()\u0026lt;3] 选取最前面的两个属于 bookstore 元素的子元素的 book 元素。   //title[@lang] 选取所有拥有名为 lang 的属性的 title 元素。   //title[@lang=\u0026lsquo;eng\u0026rsquo;] 选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。   /bookstore/book[price\u0026gt;35.00] 选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。   /bookstore/book[price\u0026gt;35.00]/title 选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。    XPath还支持通配符用法，如下所示。\n   路径表达式 结果     /bookstore/* 选取 bookstore 元素的所有子元素。   //* 选取文档中的所有元素。   //title[@*] 选取所有带有属性的 title 元素。    如果要选取多个节点，可以使用如下所示的方法。\n   路径表达式 结果     //book/title | //book/price 选取 book 元素的所有 title 和 price 元素。   //title | //price 选取文档中的所有 title 和 price 元素。   /bookstore/book/title | //price 选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素。     说明：上面的例子来自于菜鸟教程网站上XPath教程，有兴趣的读者可以自行阅读原文。\n 当然，如果不理解或者不太熟悉XPath语法，可以在Chrome浏览器中按照如下所示的方法查看元素的XPath语法。\nBeautifulSoup的使用 BeautifulSoup是一个可以从HTML或XML文件中提取数据的Python库。它能够通过你喜欢的转换器实现惯用的文档导航、查找、修改文档的方式。\n 遍历文档树  获取标签 获取标签属性 获取标签内容 获取子（孙）节点 获取父节点/祖先节点 获取兄弟节点  搜索树节点  find / find_all select_one / select    说明：更多内容可以参考BeautifulSoup的官方文档。\n PyQuery的使用 pyquery相当于jQuery的Python实现，可以用于解析HTML网页。\n实例 - 获取知乎发现上的问题链接 from urllib.parse import urljoin import re import requests from bs4 import BeautifulSoup def main(): headers = {\u0026#39;user-agent\u0026#39;: \u0026#39;Baiduspider\u0026#39;} proxies = { \u0026#39;http\u0026#39;: \u0026#39;http://122.114.31.177:808\u0026#39; } base_url = \u0026#39;https://www.zhihu.com/\u0026#39; seed_url = urljoin(base_url, \u0026#39;explore\u0026#39;) resp = requests.get(seed_url, headers=headers, proxies=proxies) soup = BeautifulSoup(resp.text, \u0026#39;lxml\u0026#39;) href_regex = re.compile(r\u0026#39;^/question\u0026#39;) link_set = set() for a_tag in soup.find_all(\u0026#39;a\u0026#39;, {\u0026#39;href\u0026#39;: href_regex}): if \u0026#39;href\u0026#39; in a_tag.attrs: href = a_tag.attrs[\u0026#39;href\u0026#39;] full_url = urljoin(base_url, href) link_set.add(full_url) print(\u0026#39;Total %dquestion pages found.\u0026#39; % len(link_set)) if __name__ == \u0026#39;__main__\u0026#39;: main()"},{"idx":58,"href":"/python100days/docs/Day66-75/68-%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE/","title":"68 存储数据","content":" 存储数据 存储海量数据 数据持久化的首选方案应该是关系型数据库，关系型数据库的产品很多，包括：Oracle、MySQL、SQLServer、PostgreSQL等。如果要存储海量的低价值数据，文档数据库也是不错的选择，MongoDB是文档数据库中的佼佼者，之前我们已经讲解过MongDB的相关知识，在此不再进行赘述。\n数据缓存 通过《网络数据采集和解析》一文，我们已经知道了如何从指定的页面中抓取数据，以及如何保存抓取的结果，但是我们没有考虑过这么一种情况，就是我们可能需要从已经抓取过的页面中提取出更多的数据，重新去下载这些页面对于规模不大的网站倒是问题也不大，但是如果能够把这些页面缓存起来，对应用的性能会有明显的改善。可以使用Redis来提供高速缓存服务，关于Redis的知识，我们在《NoSQL入门》一文中已经做过简要的介绍。\n实例 - 缓存知乎发现上的链接和页面代码 from hashlib import sha1 from urllib.parse import urljoin import pickle import re import requests import zlib from bs4 import BeautifulSoup from redis import Redis def main(): # 指定种子页面 base_url = \u0026#39;https://www.zhihu.com/\u0026#39; seed_url = urljoin(base_url, \u0026#39;explore\u0026#39;) # 创建Redis客户端 client = Redis(host=\u0026#39;1.2.3.4\u0026#39;, port=6379, password=\u0026#39;1qaz2wsx\u0026#39;) # 设置用户代理(否则访问会被拒绝) headers = {\u0026#39;user-agent\u0026#39;: \u0026#39;Baiduspider\u0026#39;} # 通过requests模块发送GET请求并指定用户代理 resp = requests.get(seed_url, headers=headers) # 创建BeautifulSoup对象并指定使用lxml作为解析器 soup = BeautifulSoup(resp.text, \u0026#39;lxml\u0026#39;) href_regex = re.compile(r\u0026#39;^/question\u0026#39;) # 将URL处理成SHA1摘要(长度固定更简短) hasher_proto = sha1() # 查找所有href属性以/question打头的a标签 for a_tag in soup.find_all(\u0026#39;a\u0026#39;, {\u0026#39;href\u0026#39;: href_regex}): # 获取a标签的href属性值并组装完整的URL href = a_tag.attrs[\u0026#39;href\u0026#39;] full_url = urljoin(base_url, href) # 传入URL生成SHA1摘要 hasher = hasher_proto.copy() hasher.update(full_url.encode(\u0026#39;utf-8\u0026#39;)) field_key = hasher.hexdigest() # 如果Redis的键\u0026#39;zhihu\u0026#39;对应的hash数据类型中没有URL的摘要就访问页面并缓存 if not client.hexists(\u0026#39;zhihu\u0026#39;, field_key): html_page = requests.get(full_url, headers=headers).text # 对页面进行序列化和压缩操作 zipped_page = zlib.compress(pickle.dumps(html_page)) # 使用hash数据类型保存URL摘要及其对应的页面代码 client.hset(\u0026#39;zhihu\u0026#39;, field_key, zipped_page) # 显示总共缓存了多少个页面 print(\u0026#39;Total %dquestion pages found.\u0026#39; % client.hlen(\u0026#39;zhihu\u0026#39;)) if __name__ == \u0026#39;__main__\u0026#39;: main()"},{"idx":59,"href":"/python100days/docs/Day66-75/69-%E5%B9%B6%E5%8F%91%E4%B8%8B%E8%BD%BD/","title":"69 并发下载","content":" 并发下载 多线程和多进程回顾 在前面的《进程和线程》一文中，我们已经对在Python中使用多进程和多线程实现并发编程进行了简明的讲解，在此我们补充几个知识点。\nthreading.local类 使用线程时最不愿意遇到的情况就是多个线程竞争资源，在这种情况下为了保证资源状态的正确性，我们可能需要对资源进行加锁保护的处理，这一方面会导致程序失去并发性，另外如果多个线程竞争多个资源时，还有可能因为加锁方式的不当导致死锁。要解决多个线程竞争资源的问题，其中一个方案就是让每个线程都持有资源的副本（拷贝），这样每个线程可以操作自己所持有的资源，从而规避对资源的竞争。\n要实现将资源和持有资源的线程进行绑定的操作，最简单的做法就是使用threading模块的local类，在网络爬虫开发中，就可以使用local类为每个线程绑定一个MySQL数据库连接或Redis客户端对象，这样通过线程可以直接获得这些资源，既解决了资源竞争的问题，又避免了在函数和方法调用时传递这些资源。具体的请参考本章多线程爬取“手机搜狐网”（Redis版）的实例代码。\nconcurrent.futures模块 Python3.2带来了concurrent.futures 模块，这个模块包含了线程池和进程池、管理并行编程任务、处理非确定性的执行流程、进程/线程同步等功能。关于这部分的内容推荐大家阅读《Python并行编程》。\n分布式进程 使用多进程的时候，可以将进程部署在多个主机节点上，Python的multiprocessing模块不但支持多进程，其中managers子模块还支持把多进程部署到多个节点上。当然，要部署分布式进程，首先需要一个服务进程作为调度者，进程之间通过网络进行通信来实现对进程的控制和调度，由于managers模块已经对这些做出了很好的封装，因此在无需了解网络通信细节的前提下，就可以编写分布式多进程应用。具体的请参照本章分布式多进程爬取“手机搜狐网”的实例代码。\n协程和异步I/O 协程的概念 协程（coroutine）通常又称之为微线程或纤程，它是相互协作的一组子程序（函数）。所谓相互协作指的是在执行函数A时，可以随时中断去执行函数B，然后又中断继续执行函数A。注意，这一过程并不是函数调用（因为没有调用语句），整个过程看似像多线程，然而协程只有一个线程执行。协程通过yield关键字和 send()操作来转移执行权，协程之间不是调用者与被调用者的关系。\n协程的优势在于以下两点：\n 执行效率极高，因为子程序（函数）切换不是线程切换，由程序自身控制，没有切换线程的开销。 不需要多线程的锁机制，因为只有一个线程，也不存在竞争资源的问题，当然也就不需要对资源加锁保护，因此执行效率高很多。   说明：协程适合处理的是I/O密集型任务，处理CPU密集型任务并不是它的长处，如果要提升CPU的利用率可以考虑“多进程+协程”的模式。\n 历史回顾  Python 2.2：第一次提出了生成器（最初称之为迭代器）的概念（PEP 255）。 Python 2.5：引入了将对象发送回暂停了的生成器这一特性即生成器的send()方法（PEP 342）。 Python 3.3：添加了yield from特性，允许从迭代器中返回任何值（注意生成器本身也是迭代器），这样我们就可以串联生成器并且重构出更好的生成器。 Python 3.4：引入asyncio.coroutine装饰器用来标记作为协程的函数，协程函数和asyncio及其事件循环一起使用，来实现异步I/O操作。 Python 3.5：引入了async和await，可以使用async def来定义一个协程函数，这个函数中不能包含任何形式的yield语句，但是可以使用return或await从协程中返回值。  示例代码  生成器 - 数据的生产者。\nfrom time import sleep # 倒计数生成器 def countdown(n): while n \u0026gt; 0: yield n n -= 1 def main(): for num in countdown(5): print(f\u0026#39;Countdown: {num}\u0026#39;) sleep(1) print(\u0026#39;Countdown Over!\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: main()  生成器还可以叠加来组成生成器管道，代码如下所示。\n# Fibonacci数生成器 def fib(): a, b = 0, 1 while True: a, b = b, a + b yield a # 偶数生成器 def even(gen): for val in gen: if val % 2 == 0: yield val def main(): gen = even(fib()) for _ in range(10): print(next(gen)) if __name__ == \u0026#39;__main__\u0026#39;: main()  协程 - 数据的消费者。\nfrom time import sleep # 生成器 - 数据生产者 def countdown_gen(n, consumer): consumer.send(None) while n \u0026gt; 0: consumer.send(n) n -= 1 consumer.send(None) # 协程 - 数据消费者 def countdown_con(): while True: n = yield if n: print(f\u0026#39;Countdown {n}\u0026#39;) sleep(1) else: print(\u0026#39;Countdown Over!\u0026#39;) def main(): countdown_gen(5, countdown_con()) if __name__ == \u0026#39;__main__\u0026#39;: main()   说明：上面代码中countdown_gen函数中的第1行consumer.send(None)是为了激活生成器，通俗的说就是让生成器执行到有yield关键字的地方挂起，当然也可以通过next(consumer)来达到同样的效果。如果不愿意每次都用这样的代码来“预激”生成器，可以写一个包装器来完成该操作，代码如下所示。\n from functools import wraps def coroutine(fn): @wraps(fn) def wrapper(*args, **kwargs): gen = fn(*args, **kwargs) next(gen) return gen return wrapper 这样就可以使用@coroutine装饰器对协程进行预激操作，不需要再写重复代码来激活协程。\n 异步I/O - 非阻塞式I/O操作。\nimport asyncio @asyncio.coroutine def countdown(name, n): while n \u0026gt; 0: print(f\u0026#39;Countdown[{name}]: {n}\u0026#39;) yield from asyncio.sleep(1) n -= 1 def main(): loop = asyncio.get_event_loop() tasks = [ countdown(\u0026#34;A\u0026#34;, 10), countdown(\u0026#34;B\u0026#34;, 5), ] loop.run_until_complete(asyncio.wait(tasks)) loop.close() if __name__ == \u0026#39;__main__\u0026#39;: main() async和await。\nimport asyncio import aiohttp async def download(url): print(\u0026#39;Fetch:\u0026#39;, url) async with aiohttp.ClientSession() as session: async with session.get(url) as resp: print(url, \u0026#39;---\u0026gt;\u0026#39;, resp.status) print(url, \u0026#39;---\u0026gt;\u0026#39;, resp.cookies) print(\u0026#39;\\n\\n\u0026#39;, await resp.text()) def main(): loop = asyncio.get_event_loop() urls = [ \u0026#39;https://www.baidu.com\u0026#39;, \u0026#39;http://www.sohu.com/\u0026#39;, \u0026#39;http://www.sina.com.cn/\u0026#39;, \u0026#39;https://www.taobao.com/\u0026#39;, \u0026#39;https://www.jd.com/\u0026#39; ] tasks = [download(url) for url in urls] loop.run_until_complete(asyncio.wait(tasks)) loop.close() if __name__ == \u0026#39;__main__\u0026#39;: main()  上面的代码使用了AIOHTTP这个非常著名的第三方库，它实现了HTTP客户端和HTTP服务器的功能，对异步操作提供了非常好的支持，有兴趣可以阅读它的官方文档。\n实例 - 多线程爬取“手机搜狐网”所有页面 下面我们把之间讲的所有知识结合起来，用面向对象的方式实现一个爬取“手机搜狐网”的多线程爬虫。\nimport pickle import zlib from enum import Enum, unique from hashlib import sha1 from random import random from threading import Thread, current_thread, local from time import sleep from urllib.parse import urlparse import pymongo import redis import requests from bs4 import BeautifulSoup from bson import Binary @unique class SpiderStatus(Enum): IDLE = 0 WORKING = 1 def decode_page(page_bytes, charsets=(\u0026#39;utf-8\u0026#39;,)): page_html = None for charset in charsets: try: page_html = page_bytes.decode(charset) break except UnicodeDecodeError: pass return page_html class Retry(object): def __init__(self, *, retry_times=3, wait_secs=5, errors=(Exception, )): self.retry_times = retry_times self.wait_secs = wait_secs self.errors = errors def __call__(self, fn): def wrapper(*args, **kwargs): for _ in range(self.retry_times): try: return fn(*args, **kwargs) except self.errors as e: print(e) sleep((random() + 1) * self.wait_secs) return None return wrapper class Spider(object): def __init__(self): self.status = SpiderStatus.IDLE @Retry() def fetch(self, current_url, *, charsets=(\u0026#39;utf-8\u0026#39;, ), user_agent=None, proxies=None): thread_name = current_thread().name print(f\u0026#39;[{thread_name}]: {current_url}\u0026#39;) headers = {\u0026#39;user-agent\u0026#39;: user_agent} if user_agent else {} resp = requests.get(current_url, headers=headers, proxies=proxies) return decode_page(resp.content, charsets) \\ if resp.status_code == 200 else None def parse(self, html_page, *, domain=\u0026#39;m.sohu.com\u0026#39;): soup = BeautifulSoup(html_page, \u0026#39;lxml\u0026#39;) for a_tag in soup.body.select(\u0026#39;a[href]\u0026#39;): parser = urlparse(a_tag.attrs[\u0026#39;href\u0026#39;]) scheme = parser.scheme or \u0026#39;http\u0026#39; netloc = parser.netloc or domain if scheme != \u0026#39;javascript\u0026#39; and netloc == domain: path = parser.path query = \u0026#39;?\u0026#39; + parser.query if parser.query else \u0026#39;\u0026#39; full_url = f\u0026#39;{scheme}://{netloc}{path}{query}\u0026#39; redis_client = thread_local.redis_client if not redis_client.sismember(\u0026#39;visited_urls\u0026#39;, full_url): redis_client.rpush(\u0026#39;m_sohu_task\u0026#39;, full_url) def extract(self, html_page): pass def store(self, data_dict): # redis_client = thread_local.redis_client # mongo_db = thread_local.mongo_db pass class SpiderThread(Thread): def __init__(self, name, spider): super().__init__(name=name, daemon=True) self.spider = spider def run(self): redis_client = redis.Redis(host=\u0026#39;1.2.3.4\u0026#39;, port=6379, password=\u0026#39;1qaz2wsx\u0026#39;) mongo_client = pymongo.MongoClient(host=\u0026#39;1.2.3.4\u0026#39;, port=27017) thread_local.redis_client = redis_client thread_local.mongo_db = mongo_client.msohu while True: current_url = redis_client.lpop(\u0026#39;m_sohu_task\u0026#39;) while not current_url: current_url = redis_client.lpop(\u0026#39;m_sohu_task\u0026#39;) self.spider.status = SpiderStatus.WORKING current_url = current_url.decode(\u0026#39;utf-8\u0026#39;) if not redis_client.sismember(\u0026#39;visited_urls\u0026#39;, current_url): redis_client.sadd(\u0026#39;visited_urls\u0026#39;, current_url) html_page = self.spider.fetch(current_url) if html_page not in [None, \u0026#39;\u0026#39;]: hasher = hasher_proto.copy() hasher.update(current_url.encode(\u0026#39;utf-8\u0026#39;)) doc_id = hasher.hexdigest() sohu_data_coll = mongo_client.msohu.webpages if not sohu_data_coll.find_one({\u0026#39;_id\u0026#39;: doc_id}): sohu_data_coll.insert_one({ \u0026#39;_id\u0026#39;: doc_id, \u0026#39;url\u0026#39;: current_url, \u0026#39;page\u0026#39;: Binary(zlib.compress(pickle.dumps(html_page))) }) self.spider.parse(html_page) self.spider.status = SpiderStatus.IDLE def is_any_alive(spider_threads): return any([spider_thread.spider.status == SpiderStatus.WORKING for spider_thread in spider_threads]) thread_local = local() hasher_proto = sha1() def main(): redis_client = redis.Redis(host=\u0026#39;1.2.3.4\u0026#39;, port=6379, password=\u0026#39;1qaz2wsx\u0026#39;) if not redis_client.exists(\u0026#39;m_sohu_task\u0026#39;): redis_client.rpush(\u0026#39;m_sohu_task\u0026#39;, \u0026#39;http://m.sohu.com/\u0026#39;) spider_threads = [SpiderThread(\u0026#39;thread-%d\u0026#39; % i, Spider()) for i in range(10)] for spider_thread in spider_threads: spider_thread.start() while redis_client.exists(\u0026#39;m_sohu_task\u0026#39;) or is_any_alive(spider_threads): sleep(5) print(\u0026#39;Over!\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: main()"},{"idx":60,"href":"/python100days/docs/Day66-75/70-%E8%A7%A3%E6%9E%90%E5%8A%A8%E6%80%81%E5%86%85%E5%AE%B9/","title":"70 解析动态内容","content":" 解析动态内容 根据权威机构发布的全球互联网可访问性审计报告，全球约有四分之三的网站其内容或部分内容是通过JavaScript动态生成的，这就意味着在浏览器窗口中“查看网页源代码”时无法在HTML代码中找到这些内容，也就是说我们之前用的抓取数据的方式无法正常运转了。解决这样的问题基本上有两种方案，一是JavaScript逆向工程；另一种是渲染JavaScript获得渲染后的内容。\nJavaScript逆向工程 下面我们以“360图片”网站为例，说明什么是JavaScript逆向工程。其实所谓的JavaScript逆向工程就是找到通过Ajax技术动态获取数据的接口。在浏览器中输入http://image.so.com/z?ch=beauty就可以打开“360图片”的“美女”版块，如下图所示。\n但是当我们在浏览器中通过右键菜单“显示网页源代码”的时候，居然惊奇的发现页面的HTML代码中连一个\u0026lt;img\u0026gt;标签都没有，那么我们看到的图片是怎么显示出来的呢？原来所有的图片都是通过JavaScript动态加载的，而在浏览器的“开发人员工具”的“网络”中可以找到获取这些图片数据的网络API接口，如下图所示。\n那么结论就很简单了，只要我们找到了这些网络API接口，那么就能通过这些接口获取到数据，当然实际开发的时候可能还要对这些接口的参数以及接口返回的数据进行分析，了解每个参数的意义以及返回的JSON数据的格式，这样才能在我们的爬虫中使用这些数据。\n关于如何从网络API中获取JSON格式的数据并提取出我们需要的内容，在之前的《文件和异常》一文中已经讲解过了，这里不再进行赘述。\n使用Selenium 尽管很多网站对自己的网络API接口进行了保护，增加了获取数据的难度，但是只要经过足够的努力，绝大多数还是可以被逆向工程的，但是在实际开发中，我们可以通过浏览器渲染引擎来避免这些繁琐的工作，WebKit就是一个利用的渲染引擎。\nWebKit的代码始于1998年的KHTML项目，当时它是Konqueror浏览器的渲染引擎。2001年，苹果公司从这个项目的代码中衍生出了WebKit并应用于Safari浏览器，早期的Chrome浏览器也使用了该内核。在Python中，我们可以通过Qt框架获得WebKit引擎并使用它来渲染页面获得动态内容，关于这个内容请大家自行阅读《爬虫技术:动态页面抓取超级指南》一文。\n如果没有打算用上面所说的方式来渲染页面并获得动态内容，其实还有一种替代方案就是使用自动化测试工具Selenium，它提供了浏览器自动化的API接口，这样就可以通过操控浏览器来获取动态内容。首先可以使用pip来安装Selenium。\npip3 install selenium 下面以“阿里V任务”的“直播服务”为例，来演示如何使用Selenium获取到动态内容并抓取主播图片。\nimport requests from bs4 import BeautifulSoup def main(): resp = requests.get(\u0026#39;https://v.taobao.com/v/content/live?catetype=704\u0026amp;from=taonvlang\u0026#39;) soup = BeautifulSoup(resp.text, \u0026#39;lxml\u0026#39;) for img_tag in soup.select(\u0026#39;img[src]\u0026#39;): print(img_tag.attrs[\u0026#39;src\u0026#39;]) if __name__ == \u0026#39;__main__\u0026#39;: main() 运行上面的程序会发现没有任何的输出，因为页面的HTML代码上根本找不到\u0026lt;img\u0026gt;标签。接下来我们使用Selenium来获取到页面上的动态内容，再提取主播图片。\nfrom bs4 import BeautifulSoup from selenium import webdriver from selenium.webdriver.common.keys import Keys def main(): driver = webdriver.Chrome() driver.get(\u0026#39;https://v.taobao.com/v/content/live?catetype=704\u0026amp;from=taonvlang\u0026#39;) soup = BeautifulSoup(driver.page_source, \u0026#39;lxml\u0026#39;) for img_tag in soup.body.select(\u0026#39;img[src]\u0026#39;): print(img_tag.attrs[\u0026#39;src\u0026#39;]) if __name__ == \u0026#39;__main__\u0026#39;: main() 在上面的程序中，我们通过Selenium实现对Chrome浏览器的操控，如果要操控其他的浏览器，可以创对应的浏览器对象，例如Firefox、IE等。运行上面的程序，如果看到如下所示的错误提示，那是说明我们还没有将Chrome浏览器的驱动添加到PATH环境变量中，也没有在程序中指定Chrome浏览器驱动所在的位置。\nselenium.common.exceptions.WebDriverException: Message: \u0026#39;chromedriver\u0026#39; executable needs to be in PATH. Please see https://sites.google.com/a/chromium.org/chromedriver/home 为了解决上面的问题，可以到Selenium的官方网站找到浏览器驱动的下载链接并下载需要的驱动，在Linux或macOS系统下可以通过下面的命令来设置PATH环境变量，Windows下配置环境变量也非常简单，不清楚的可以自行了解。\nexport PATH=$PATH:/Users/Hao/Downloads/Tools/chromedriver/ 其中/Users/Hao/Downloads/Tools/chromedriver/就是chromedriver所在的路径。\n"},{"idx":61,"href":"/python100days/docs/Day66-75/71-%E8%A1%A8%E5%8D%95%E4%BA%A4%E4%BA%92%E5%92%8C%E9%AA%8C%E8%AF%81%E7%A0%81%E5%A4%84%E7%90%86/","title":"71 表单交互和验证码处理","content":" 表单交互和验证码处理 提交表单 手动提交 自动提交 验证码处理 加载验证码 光学字符识别 光学字符识别（OCR）是从图像中抽取文本的工具，可以应用于公安、电信、物流、金融等诸多行业，例如识别车牌，身份证扫描识别、名片信息提取等。在爬虫开发中，如果遭遇了有文字验证码的表单，就可以利用OCR来进行验证码处理。Tesseract-OCR引擎最初是由惠普公司开发的光学字符识别系统，目前发布在Github上，由Google赞助开发。\n处理更复杂的验证码 很多网站为了分别出提供验证码的是人还是机器使用了更为复杂的验证码，例如拼图验证码、点触验证码、九宫格验证码等。关于这方面的知识，在崔庆才同学的《Python 3网络爬虫开发实战》有较为详细的讲解，有兴趣的可以购买阅读。\n验证码处理服务 "},{"idx":62,"href":"/python100days/docs/Day66-75/72-Scrapy%E5%85%A5%E9%97%A8/","title":"72 Scrapy入门","content":" Scrapy爬虫框架入门 Scrapy概述 Scrapy是Python开发的一个非常流行的网络爬虫框架，可以用来抓取Web站点并从页面中提取结构化的数据，被广泛的用于数据挖掘、数据监测和自动化测试等领域。下图展示了Scrapy的基本架构，其中包含了主要组件和系统的数据处理流程（图中带数字的红色箭头）。\n组件  Scrapy引擎（Engine）：Scrapy引擎是用来控制整个系统的数据处理流程。 调度器（Scheduler）：调度器从Scrapy引擎接受请求并排序列入队列，并在Scrapy引擎发出请求后返还给它们。 下载器（Downloader）：下载器的主要职责是抓取网页并将网页内容返还给蜘蛛（Spiders）。 蜘蛛（Spiders）：蜘蛛是有Scrapy用户自定义的用来解析网页并抓取特定URL返回的内容的类，每个蜘蛛都能处理一个域名或一组域名，简单的说就是用来定义特定网站的抓取和解析规则。 条目管道（Item Pipeline）：条目管道的主要责任是负责处理有蜘蛛从网页中抽取的数据条目，它的主要任务是清理、验证和存储数据。当页面被蜘蛛解析后，将被发送到条目管道，并经过几个特定的次序处理数据。每个条目管道组件都是一个Python类，它们获取了数据条目并执行对数据条目进行处理的方法，同时还需要确定是否需要在条目管道中继续执行下一步或是直接丢弃掉不处理。条目管道通常执行的任务有：清理HTML数据、验证解析到的数据（检查条目是否包含必要的字段）、检查是不是重复数据（如果重复就丢弃）、将解析到的数据存储到数据库（关系型数据库或NoSQL数据库）中。 中间件（Middlewares）：中间件是介于Scrapy引擎和其他组件之间的一个钩子框架，主要是为了提供自定义的代码来拓展Scrapy的功能，包括下载器中间件和蜘蛛中间件。  数据处理流程 Scrapy的整个数据处理流程由Scrapy引擎进行控制，通常的运转流程包括以下的步骤：\n 引擎询问蜘蛛需要处理哪个网站，并让蜘蛛将第一个需要处理的URL交给它。\n 引擎让调度器将需要处理的URL放在队列中。\n 引擎从调度那获取接下来进行爬取的页面。\n 调度将下一个爬取的URL返回给引擎，引擎将它通过下载中间件发送到下载器。\n 当网页被下载器下载完成以后，响应内容通过下载中间件被发送到引擎；如果下载失败了，引擎会通知调度器记录这个URL，待会再重新下载。\n 引擎收到下载器的响应并将它通过蜘蛛中间件发送到蜘蛛进行处理。\n 蜘蛛处理响应并返回爬取到的数据条目，此外还要将需要跟进的新的URL发送给引擎。\n 引擎将抓取到的数据条目送入条目管道，把新的URL发送给调度器放入队列中。\n  上述操作中的2-8步会一直重复直到调度器中没有需要请求的URL，爬虫停止工作。\n安装和使用Scrapy 可以先创建虚拟环境并在虚拟环境下使用pip安装scrapy。\n 项目的目录结构如下图所示。\n(venv) $ tree . |____ scrapy.cfg |____ douban | |____ spiders | | |____ __init__.py | | |____ __pycache__ | |____ __init__.py | |____ __pycache__ | |____ middlewares.py | |____ settings.py | |____ items.py | |____ pipelines.py  说明：Windows系统的命令行提示符下有tree命令，但是Linux和MacOS的终端是没有tree命令的，可以用下面给出的命令来定义tree命令，其实是对find命令进行了定制并别名为tree。\nalias tree=\u0026quot;find . -print | sed -e 's;[^/]*/;|____;g;s;____|; |;g'\u0026quot;\nLinux系统也可以通过yum或其他的包管理工具来安装tree。\nyum install tree\n 根据刚才描述的数据处理流程，基本上需要我们做的有以下几件事情：\n 在items.py文件中定义字段，这些字段用来保存数据，方便后续的操作。\n# -*- coding: utf-8 -*- # Define here the models for your scraped items # # See documentation in: # https://doc.scrapy.org/en/latest/topics/items.html import scrapy class DoubanItem(scrapy.Item): name = scrapy.Field() year = scrapy.Field() score = scrapy.Field() director = scrapy.Field() classification = scrapy.Field() actor = scrapy.Field() 在spiders文件夹中编写自己的爬虫。\n(venv) $ scrapy genspider movie movie.douban.com --template=crawl# -*- coding: utf-8 -*- import scrapy from scrapy.selector import Selector from scrapy.linkextractors import LinkExtractor from scrapy.spiders import CrawlSpider, Rule from douban.items import DoubanItem class MovieSpider(CrawlSpider): name = \u0026#39;movie\u0026#39; allowed_domains = [\u0026#39;movie.douban.com\u0026#39;] start_urls = [\u0026#39;https://movie.douban.com/top250\u0026#39;] rules = ( Rule(LinkExtractor(allow=(r\u0026#39;https://movie.douban.com/top250\\?start=\\d+.*\u0026#39;))), Rule(LinkExtractor(allow=(r\u0026#39;https://movie.douban.com/subject/\\d+\u0026#39;)), callback=\u0026#39;parse_item\u0026#39;), ) def parse_item(self, response): sel = Selector(response) item = DoubanItem() item[\u0026#39;name\u0026#39;]=sel.xpath(\u0026#39;//*[@id=\u0026#34;content\u0026#34;]/h1/span[1]/text()\u0026#39;).extract() item[\u0026#39;year\u0026#39;]=sel.xpath(\u0026#39;//*[@id=\u0026#34;content\u0026#34;]/h1/span[2]/text()\u0026#39;).re(r\u0026#39;\\((\\d+)\\)\u0026#39;) item[\u0026#39;score\u0026#39;]=sel.xpath(\u0026#39;//*[@id=\u0026#34;interest_sectl\u0026#34;]/div/p[1]/strong/text()\u0026#39;).extract() item[\u0026#39;director\u0026#39;]=sel.xpath(\u0026#39;//*[@id=\u0026#34;info\u0026#34;]/span[1]/a/text()\u0026#39;).extract() item[\u0026#39;classification\u0026#39;]= sel.xpath(\u0026#39;//span[@property=\u0026#34;v:genre\u0026#34;]/text()\u0026#39;).extract() item[\u0026#39;actor\u0026#39;]= sel.xpath(\u0026#39;//*[@id=\u0026#34;info\u0026#34;]/span[3]/a[1]/text()\u0026#39;).extract() return item   说明：上面我们通过Scrapy提供的爬虫模板创建了Spider，其中的rules中的LinkExtractor对象会自动完成对新的链接的解析，该对象中有一个名为extract_link的回调方法。Scrapy支持用XPath语法和CSS选择器进行数据解析，对应的方法分别是xpath和css，上面我们使用了XPath语法对页面进行解析，如果不熟悉XPath语法可以看看后面的补充说明。\n 到这里，我们已经可以通过下面的命令让爬虫运转起来。\n(venv)$ scrapy crawl movie 可以在控制台看到爬取到的数据，如果想将这些数据保存到文件中，可以通过-o参数来指定文件名，Scrapy支持我们将爬取到的数据导出成JSON、CSV、XML、pickle、marshal等格式。\n(venv)$ scrapy crawl moive -o result.json  在pipelines.py中完成对数据进行持久化的操作。\n# -*- coding: utf-8 -*- # Define your item pipelines here # # Don\u0026#39;t forget to add your pipeline to the ITEM_PIPELINES setting # See: https://doc.scrapy.org/en/latest/topics/item-pipeline.html import pymongo from scrapy.exceptions import DropItem from scrapy.conf import settings from scrapy import log class DoubanPipeline(object): def __init__(self): connection = pymongo.MongoClient(settings[\u0026#39;MONGODB_SERVER\u0026#39;], settings[\u0026#39;MONGODB_PORT\u0026#39;]) db = connection[settings[\u0026#39;MONGODB_DB\u0026#39;]] self.collection = db[settings[\u0026#39;MONGODB_COLLECTION\u0026#39;]] def process_item(self, item, spider): #Remove invalid data valid = True for data in item: if not data: valid = False raise DropItem(\u0026#34;Missing %sof blogpost from %s\u0026#34; %(data, item[\u0026#39;url\u0026#39;])) if valid: #Insert data into database new_moive=[{ \u0026#34;name\u0026#34;:item[\u0026#39;name\u0026#39;][0], \u0026#34;year\u0026#34;:item[\u0026#39;year\u0026#39;][0], \u0026#34;score\u0026#34;:item[\u0026#39;score\u0026#39;], \u0026#34;director\u0026#34;:item[\u0026#39;director\u0026#39;], \u0026#34;classification\u0026#34;:item[\u0026#39;classification\u0026#39;], \u0026#34;actor\u0026#34;:item[\u0026#39;actor\u0026#39;] }] self.collection.insert(new_moive) log.msg(\u0026#34;Item wrote to MongoDB database %s/%s\u0026#34; % (settings[\u0026#39;MONGODB_DB\u0026#39;], settings[\u0026#39;MONGODB_COLLECTION\u0026#39;]), level=log.DEBUG, spider=spider) return item  利用Pipeline我们可以完成以下操作：\n 清理HTML数据，验证爬取的数据。 丢弃重复的不必要的内容。 将爬取的结果进行持久化操作。   修改settings.py文件对项目进行配置。\n# -*- coding: utf-8 -*- # Scrapy settings for douban project # # For simplicity, this file contains only settings considered important or # commonly used. You can find more settings consulting the documentation: # # https://doc.scrapy.org/en/latest/topics/settings.html # https://doc.scrapy.org/en/latest/topics/downloader-middleware.html # https://doc.scrapy.org/en/latest/topics/spider-middleware.html BOT_NAME = \u0026#39;douban\u0026#39; SPIDER_MODULES = [\u0026#39;douban.spiders\u0026#39;] NEWSPIDER_MODULE = \u0026#39;douban.spiders\u0026#39; # Crawl responsibly by identifying yourself (and your website) on the user-agent USER_AGENT = \u0026#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_3) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.54 Safari/536.5\u0026#39; # Obey robots.txt rules ROBOTSTXT_OBEY = True # Configure maximum concurrent requests performed by Scrapy (default: 16) # CONCURRENT_REQUESTS = 32 # Configure a delay for requests for the same website (default: 0) # See https://doc.scrapy.org/en/latest/topics/settings.html#download-delay # See also autothrottle settings and docs DOWNLOAD_DELAY = 3 RANDOMIZE_DOWNLOAD_DELAY = True # The download delay setting will honor only one of: # CONCURRENT_REQUESTS_PER_DOMAIN = 16 # CONCURRENT_REQUESTS_PER_IP = 16 # Disable cookies (enabled by default) COOKIES_ENABLED = True MONGODB_SERVER = \u0026#39;120.77.222.217\u0026#39; MONGODB_PORT = 27017 MONGODB_DB = \u0026#39;douban\u0026#39; MONGODB_COLLECTION = \u0026#39;movie\u0026#39; # Disable Telnet Console (enabled by default) # TELNETCONSOLE_ENABLED = False # Override the default request headers: # DEFAULT_REQUEST_HEADERS = { # \u0026#39;Accept\u0026#39;: \u0026#39;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\u0026#39;, # \u0026#39;Accept-Language\u0026#39;: \u0026#39;en\u0026#39;, # } # Enable or disable spider middlewares # See https://doc.scrapy.org/en/latest/topics/spider-middleware.html # SPIDER_MIDDLEWARES = { # \u0026#39;douban.middlewares.DoubanSpiderMiddleware\u0026#39;: 543, # } # Enable or disable downloader middlewares # See https://doc.scrapy.org/en/latest/topics/downloader-middleware.html # DOWNLOADER_MIDDLEWARES = { # \u0026#39;douban.middlewares.DoubanDownloaderMiddleware\u0026#39;: 543, # } # Enable or disable extensions # See https://doc.scrapy.org/en/latest/topics/extensions.html # EXTENSIONS = { # \u0026#39;scrapy.extensions.telnet.TelnetConsole\u0026#39;: None, # } # Configure item pipelines # See https://doc.scrapy.org/en/latest/topics/item-pipeline.html ITEM_PIPELINES = { \u0026#39;douban.pipelines.DoubanPipeline\u0026#39;: 400, } LOG_LEVEL = \u0026#39;DEBUG\u0026#39; # Enable and configure the AutoThrottle extension (disabled by default) # See https://doc.scrapy.org/en/latest/topics/autothrottle.html #AUTOTHROTTLE_ENABLED = True # The initial download delay #AUTOTHROTTLE_START_DELAY = 5 # The maximum download delay to be set in case of high latencies #AUTOTHROTTLE_MAX_DELAY = 60 # The average number of requests Scrapy should be sending in parallel to # each remote server #AUTOTHROTTLE_TARGET_CONCURRENCY = 1.0 # Enable showing throttling stats for every response received: #AUTOTHROTTLE_DEBUG = False # Enable and configure HTTP caching (disabled by default) # See https://doc.scrapy.org/en/latest/topics/downloader-middleware.html#httpcache-middleware-settings HTTPCACHE_ENABLED = True HTTPCACHE_EXPIRATION_SECS = 0 HTTPCACHE_DIR = \u0026#39;httpcache\u0026#39; HTTPCACHE_IGNORE_HTTP_CODES = [] HTTPCACHE_STORAGE = \u0026#39;scrapy.extensions.httpcache.FilesystemCacheStorage\u0026#39;  "},{"idx":63,"href":"/python100days/docs/Day66-75/73-Scrapy%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/","title":"73 Scrapy高级应用","content":" Scrapy爬虫框架高级应用 Spider的用法 在Scrapy框架中，我们自定义的蜘蛛都继承自scrapy.spiders.Spider，这个类有一系列的属性和方法，具体如下所示：\n name：爬虫的名字。 allowed_domains：允许爬取的域名，不在此范围的链接不会被跟进爬取。 start_urls：起始URL列表，当我们没有重写start_requests()方法时，就会从这个列表开始爬取。 custom_settings：用来存放蜘蛛专属配置的字典，这里的设置会覆盖全局的设置。 crawler：由from_crawler()方法设置的和蜘蛛对应的Crawler对象，Crawler对象包含了很多项目组件，利用它我们可以获取项目的配置信息，如调用crawler.settings.get()方法。 settings：用来获取爬虫全局设置的变量。 start_requests()：此方法用于生成初始请求，它返回一个可迭代对象。该方法默认是使用GET请求访问起始URL，如果起始URL需要使用POST请求来访问就必须重写这个方法。 parse()：当Response没有指定回调函数时，该方法就会被调用，它负责处理Response对象并返回结果，从中提取出需要的数据和后续的请求，该方法需要返回类型为Request或Item的可迭代对象（生成器当前也包含在其中，因此根据实际需要可以用return或yield来产生返回值）。 closed()：当蜘蛛关闭时，该方法会被调用，通常用来做一些释放资源的善后操作。  中间件的应用 下载中间件 蜘蛛中间件 Scrapy对接Selenium Scrapy部署到Docker "},{"idx":64,"href":"/python100days/docs/Day66-75/74-Scrapy%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9E%E7%8E%B0/","title":"74 Scrapy分布式实现","content":" Scrapy爬虫框架分布式实现 分布式爬虫原理 Scrapy分布式实现  安装Scrapy-Redis。 配置Redis服务器。 修改配置文件。  SCHEDULER = \u0026lsquo;scrapy_redis.scheduler.Scheduler\u0026rsquo; DUPEFILTER_CLASS = \u0026lsquo;scrapy_redis.dupefilter.RFPDupeFilter\u0026rsquo; REDIS_HOST = \u0026lsquo;1.2.3.4\u0026rsquo; REDIS_PORT = 6379 REDIS_PASSWORD = \u0026lsquo;1qaz2wsx\u0026rsquo; SCHEDULER_QUEUE_CLASS = \u0026lsquo;scrapy_redis.queue.FifoQueue\u0026rsquo; SCHEDULER_PERSIST = True（通过持久化支持接续爬取） SCHEDULER_FLUSH_ON_START = True（每次启动时重新爬取）   Scrapyd分布式部署  安装Scrapyd 修改配置文件  mkdir /etc/scrapyd vim /etc/scrapyd/scrapyd.conf  安装Scrapyd-Client  将项目打包成Egg文件。 将打包的Egg文件通过addversion.json接口部署到Scrapyd上。   "},{"idx":65,"href":"/python100days/docs/Day66-75/75-%E7%88%AC%E8%99%AB%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/","title":"75 爬虫项目实战","content":" 爬虫项目实战 "},{"idx":66,"href":"/python100days/docs/Day76-90/76-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/","title":"76 机器学习基础","content":" 机器学习基础 所谓“机器学习”就是利用计算机将纷繁复杂的数据处理成有用的信息，这样就可以发掘出数据带来的意义以及隐藏在数据背后的规律。现如今，“机器学习”和“大数据”可以说是IT行业中最热点的两个词汇，而无论是“机器学习”还是“大数据”最终要解决的问题本质上是一样的，用最为直白的话来说就是用现有的数据去预测将来的状况。\n按照问题的“输入”和“输出”，我们可以将用计算机解决的问题分为四大类：\n 输入的信息是精确的，要求输出最优解。 输入的信息是精确的，无法找到最优解。 输入的信息是模糊的，要求输出最优解。 输入的信息是模糊的，无法找到最优解。  在上面的四大类问题中，第1类问题是计算机最擅长解决的，这类问题其实就是“数值计算”和“逻辑推理”方面的问题，而传统意义上的人工智能也就是利用逻辑推理来解决问题（如早期的“人机对弈”）。一直以来，我们都习惯于将计算机称为“电脑”，而基于“冯诺依曼”体系结构的“电脑”实际上只是实现了“人脑”理性思维这部分的功能，而且在这一点上“电脑”通常是优于“人脑”的，而“人脑”在处理输入模糊信息时表现出来的强大的处理能力，在今天看来也不是“电脑”可以完全企及的。所以我们研究人工智能也好，研究机器学习也好，是希望输入模糊信息时，计算机能够给出满意的甚至是最优的答案。\n至此，我们可以给“机器学习”下一个定义：机器学习是一门专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身性能的学科。机器学习目前已经广泛的应用到生产生活的各个领域，以下列举了一些经典的场景：\n 搜索引擎：根据搜索和使用习惯，优化下一次搜索的结果。 电商网站：自动推荐你可能感兴趣的商品。 贷款申请：通过你最近的金融活动信息进行综合评定。 图像识别：自动识别图片中有没有不和谐的内容。  机器学习可以分为监督学习和非监督学习。监督学习是从给定的训练数据集中学习得到一个函数，当新的数据到来时，可以根据这个函数预测结果，监督学习的训练集包括输入和输出，也可以说是特征和目标。监督学习的目标是由人来标注的，而非监督学习的数据没有类别信息，训练集也没有人为标注结果，通过无监督学习可以减少数据特征的维度，以便我们可以使用二维或三维图形更加直观地展示数据信息 。\n实现机器学习的一般步骤：\n 数据收集 数据准备 数据分析 训练算法 测试算法 应用算法  "},{"idx":67,"href":"/python100days/docs/Day76-90/77-Pandas%E7%9A%84%E5%BA%94%E7%94%A8/","title":"77 Pandas的应用","content":" Pandas的应用 1、Pandas入门 2、Pandas索引 3、Pandas数据清洗之空数据 4、Pandas多层索引 5、Pandas多层索引计算 6、Pandas数据集成concat 7、Pandas数据集成merge 8、Pandas分组聚合操作 9、Pandas数据集成实战 10、美国大选项目 "},{"idx":68,"href":"/python100days/docs/Day76-90/78-NumPy%E5%92%8CSciPy%E7%9A%84%E5%BA%94%E7%94%A8/","title":"78 Num Py和 Sci Py的应用","content":" NumPy和SciPy的应用 "},{"idx":69,"href":"/python100days/docs/Day76-90/79-Matplotlib%E5%92%8C%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/","title":"79 Matplotlib和数据可视化","content":" Matplotlib和数据可视化 数据的处理、分析和可视化已经成为Python近年来最为重要的应用领域之一，其中数据的可视化指的是将数据呈现为漂亮的统计图表，然后进一步发现数据中包含的规律以及隐藏的信息。数据可视化又跟数据挖掘和大数据分析紧密相关，而这些领域以及当下被热议的“深度学习”其最终的目标都是为了实现从过去的数据去对未来的状况进行预测。Python在实现数据可视化方面是非常棒的，即便是使用个人电脑也能够实现对百万级甚至更大体量的数据进行探索的工作，而这些工作都可以在现有的第三方库的基础上来完成（无需“重复的发明轮子”）。Matplotlib就是Python绘图库中的佼佼者，它包含了大量的工具，你可以使用这些工具创建各种图形（包括散点图、折线图、直方图、饼图、雷达图等），Python科学计算社区也经常使用它来完成数据可视化的工作。\n安装matplotlib 可以使用pip来安装matplotlib，命令如下所示。\npip install matplotlib 绘制折线图 # coding: utf-8 import matplotlib.pyplot as plt def main(): # 保存x轴数据的列表 x_values = [x for x in range(1, 11)] # 保存y轴数据的列表 y_values = [x ** 2 for x in range(1, 11)] # 设置图表的标题以及x和y轴的说明 plt.title(\u0026#39;Square Numbers\u0026#39;) plt.xlabel(\u0026#39;Value\u0026#39;, fontsize=18) plt.ylabel(\u0026#39;Square\u0026#39;, fontsize=18) # 设置刻度标记的文字大小 plt.tick_params(axis=\u0026#39;both\u0026#39;, labelsize=16) # 绘制折线图 plt.plot(x_values, y_values) plt.show() if __name__ == \u0026#39;__main__\u0026#39;: main() 运行程序，效果如下图所示。\n如果使用jupyter的notebook，需要使用魔法指令%matplotlib inresline来设置在页面中显示图表，效果如下所示。\n绘制散点图 可以将上面代码中的的plot函数换成scatter函数来绘制散点图，效果如下图所示。\n当然，也可以直接通过plot函数设置绘图的颜色和线条的形状将折线图改造为散点图，对应的代码如下所示，其中参数\u0026rsquo;xr\u0026rsquo;表示每个点的记号是‘x’图形，颜色是红色（red）。\nplt.plot(x_values, y_values, \u0026#39;xr\u0026#39;) 重新运行程序，效果如下图所示。\n可能大家已经注意到了，1和10对应的‘x’记号在图形边角的位置不太明显，要解决这个问题可以通过添加下面的代码调整x轴和y轴的坐标范围。\nplt.axis([0, 12, 0, 120]) 调整后的效果如下图所示。\n绘制正弦曲线 在下面的程序中，我们使用了名为NumPy的第三方库来产生样本并计算正弦值。NumPy是一个运行速度非常快的数学库，主要用于数组计算。它可以让你在Python中使用向量和数学矩阵，以及许多用C语言实现的底层函数。如果想通过Python学习数据科学或者机器学习相关的内容，那么就得先学会使用NumPy。\n# coding: utf-8 import matplotlib.pyplot as plt import numpy as np def main(): # 指定采样的范围以及样本的数量 x_values = np.linspace(0, 2 * np.pi, 1000) # 计算每个样本对应的正弦值 y_values = np.sin(x_values) # 绘制折线图(线条形状为--, 颜色为蓝色) plt.plot(x_values, y_values, \u0026#39;--b\u0026#39;) plt.show() if __name__ == \u0026#39;__main__\u0026#39;: main() 运行程序，效果如下图所示。\n如果要在一个坐标系上绘制多个图像，可以按照如下的方式修改代码。\n# coding: utf-8 import matplotlib.pyplot as plt import numpy as np def main(): x_values = np.linspace(0, 2 * np.pi, 1000) plt.plot(x_values, np.sin(x_values), \u0026#39;--b\u0026#39;) plt.plot(x_values, np.sin(2 * x_values), \u0026#39;--r\u0026#39;) plt.show() if __name__ == \u0026#39;__main__\u0026#39;: main() 修改后的代码运行效果如下图所示。\n如果需要分别在两个坐标系上绘制出两条曲线，可以按照如下的方式操作。\n# coding: utf-8 import matplotlib.pyplot as plt import numpy as np def main(): # 将样本数量减少为50个 x_values = np.linspace(0, 2 * np.pi, 50) # 设置绘图为2行1列活跃区为1区(第一个图) plt.subplot(2, 1, 1) plt.plot(x_values, np.sin(x_values), \u0026#39;o-b\u0026#39;) # 设置绘图为2行1列活跃区为2区(第二个图) plt.subplot(2, 1, 2) plt.plot(x_values, np.sin(2 * x_values), \u0026#39;.-r\u0026#39;) plt.show() if __name__ == \u0026#39;__main__\u0026#39;: main() 效果如下图所示。\n绘制直方图 我们可以通过NumPy的random模块的normal函数来生成正态分布的采样数据，其中的三个参数分别表示期望、标准差和样本数量，然后绘制成直方图，代码如下所示。\n# coding: utf-8 import matplotlib.pyplot as plt import numpy as np def main(): # 通过random模块的normal函数产生1000个正态分布的样本 data = np.random.normal(10.0, 5.0, 1000) # 绘制直方图(直方的数量为10个) plt.hist(data, 10) plt.show() if __name__ == \u0026#39;__main__\u0026#39;: main() 运行效果如下图所示。\n使用Pygal绘制矢量图 矢量图（SVG）是计算机图形学中用点、直线或者多边形等基于数学方程的几何图元表示的图像，也是目前应用得非常多的一种图像文件格式，全称是“Scalable Vector Graphics”。和使用像素表示图像的位图不同，SVG基于XML存储图像数据，它是W3C定义的一种开放标准的矢量图形语言，可以用来设计更为清晰的Web图像，因为SVG与分辨率无关，在任意放大时不会丢失细节或影响清晰度。SVG可以直接用代码来描绘图像，也可以用任何文字处理工具来打开它，通过改变SVG的代码我们可以让图像具备交互功能。\nPython中可以使用Pygal来生成SVG，可以通过pip来安装它。\nfrom random import randint import pygal def roll_dice(n=1): total = 0 for _ in range(n): total += randint(1, 6) return total def main(): results = [] # 将两颗色子摇10000次记录点数 for _ in range(10000): face = roll_dice(2) results.append(face) freqs = [] # 统计2~12点各出现了多少次 for value in range(2, 13): freq = results.count(value) freqs.append(freq) # 绘制柱状图 hist = pygal.Bar() hist.title = \u0026#39;Result of rolling two dice\u0026#39; hist.x_labels = [x for x in range(2, 13)] hist.add(\u0026#39;Frequency\u0026#39;, freqs) # 保存矢量图 hist.render_to_file(\u0026#39;result.svg\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: main() 运行上面的程序，效果如下图所示。\n后记 Matplotlib和NumPy的强大我们在这里也只是窥视了其冰山一角，我们在后续的内容里面还会使用到这两个第三方库，到时候我们再续点为大家介绍其他的功能。\n"},{"idx":70,"href":"/python100days/docs/Day76-90/80-k%E6%9C%80%E8%BF%91%E9%82%BB%E5%88%86%E7%B1%BB/","title":"80 K最近邻分类","content":" k最近邻分类 "},{"idx":71,"href":"/python100days/docs/Day76-90/81-%E5%86%B3%E7%AD%96%E6%A0%91/","title":"81 决策树","content":" 决策树 "},{"idx":72,"href":"/python100days/docs/Day76-90/82-%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB/","title":"82 贝叶斯分类","content":" 贝叶斯分类 "},{"idx":73,"href":"/python100days/docs/Day76-90/83-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/","title":"83 支持向量机","content":" 支持向量机 "},{"idx":74,"href":"/python100days/docs/Day76-90/84-K-%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB/","title":"84 K 均值聚类","content":" K-均值聚类 "},{"idx":75,"href":"/python100days/docs/Day76-90/85-%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/","title":"85 回归分析","content":" 回归分析 "},{"idx":76,"href":"/python100days/docs/Day76-90/86-%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/","title":"86 大数据分析入门","content":" 大数据分析入门 "},{"idx":77,"href":"/python100days/docs/Day76-90/87-%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E8%BF%9B%E9%98%B6/","title":"87 大数据分析进阶","content":" 大数据分析进阶 "},{"idx":78,"href":"/python100days/docs/Day76-90/88-Tensorflow%E5%85%A5%E9%97%A8/","title":"88 Tensorflow入门","content":" Tensorflow入门 "},{"idx":79,"href":"/python100days/docs/Day76-90/89-Tensorflow%E5%AE%9E%E6%88%98/","title":"89 Tensorflow实战","content":" Tensorflow实战 "},{"idx":80,"href":"/python100days/docs/Day76-90/90-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98/","title":"90 推荐系统实战","content":" 推荐系统实战 "},{"idx":81,"href":"/python100days/docs/Day91-100/100-%E8%8B%B1%E8%AF%AD%E9%9D%A2%E8%AF%95/","title":"100 英语面试","content":" 英语面试 以下用I表示面试官（Interviewer），用C表示面试者（Candidate）。\n开场寒暄  I: Thanks for waiting. (Please follow me.)  C: It\u0026rsquo;s no problem.\n I: How are you doing this morning?  C: I\u0026rsquo;m great. / I\u0026rsquo;m doing fine. Thank you. / How about you?\n I: How did you get here?  C: I took the subway here. / I drove here.\n I: Glad to meet you.  C: Glad to meet you. / It\u0026rsquo;s great to finally meet you in person. (之前电话沟通过的)\n正式面试 人力面试  I: Can you tell me a little bit about yourself? (介绍下自己)  原则：不要谈私生活和奇怪的癖好（英雄联盟干到钻石），因为别人更想知道的是你的专业技能（qulifications）和工作经验（experience），所以重点在你之前的公司（company name）、职位（title）、时间（years）和主要职责（major responsibilities）\nC: Thank you for having me. My name is Dachui WANG. I\u0026rsquo;m 25 years old, and I\u0026rsquo;m single. I have a Bachelor\u0026rsquo;s Degree of Computer Science from Tsinghua University. I was a Junior Java Programmer for ABC Technologies during my college life. Then I become an intermediate Java engineer for XYZ Corporation in last two years. Programming is my everyday life and programming is where my passion is. I think I have a good knowledge of Java enterprise application developement using light-weight frameworks like Spring, Guice, Hibernate and other open source middle-ware like Dubbo, Mycat, rocketmq and so on and so forth. I love reading, travelling and playing basketball in my spare time. That\u0026rsquo;s all! Thank you!\n I: How would you describe your personality? (你的性格)  C: I\u0026rsquo;m hard working, eager to learn, and very serious about my work. I enjoy working with other people and I love challenges.\n I: What do you know about our company? (你对我们公司有什么了解)  (需要做功课，了解公司的状况和企业文化，该公司在这个行业中的一个状况，有什么核心业务，主要的竞争对手有哪些)\nC: The one thing that I like the most about our company is your core values. I think they\u0026rsquo;re very important in this industry because …(自由发挥的部分)\u0026hellip; I personally really believe in the cause as well. Of course, I\u0026rsquo;m very interested in your products such as …(功课部分)… and the techniques behind them.\n I: Why are you leaving your last job? (为什么离职)  C: I want to advance my career and I think this job offers more challenges and opportunities for me do to that.\n I: What do you see yourself in 3 or 5 years? (3-5年职业规划)  C: My long term goals involve growing with the company, where I can continue to learn, to take on additional responsibilities and to contribute as much value as I can. I intend to take advantage of all of these.\n I: What\u0026rsquo;s your salary expectation? (期望薪资)  C: My salary expectation is in line with my experience and qualifications. I believe our company will pay me and every other employee fairly. (把球踢给对方先看看对方报价是多少，如果对方非要你报价再说后面的内容) I think 15 thousands RMB or above is fitting for me to leave in Chengdu.\n I: Do you have any questions for me? (问面试官的问题)  C: What\u0026rsquo;s the growth potential for this position?\n技术面试  I: What\u0026rsquo;s difference between an interface and an abstract class? I: What are pass by reference and pass by value? I: What\u0026rsquo;s the difference between process and threads? I: Explain the available thread state in high-level. I: What\u0026rsquo;s deadlocks? How to avoid them? I: How HashMap works in Java? I: What\u0026rsquo;s the difference between ArrayList and LinkedList? (类似的问题还有很多，比如比较HashSet和TreeSet、HashMap和Hashtable) I: Tell me what you know about garbage collection in Java. I: What\u0026rsquo;re two types of exceptions in Java? I: What\u0026rsquo;s the advantage of PreparedStatement over Statement? I: What\u0026rsquo;s the use of CallableStatement? I: What does connection pool mean? I: Explain the life cycle of a Servlet. I: What\u0026rsquo;s the difference between redirect and forward? I: What\u0026rsquo;s EL? What\u0026rsquo;re implicit objects of EL? I: Tell me what you know about Spring framework and its benefits. I: What\u0026rsquo;re different types of dependency injection. I: Are singleton beans thread safe in Spring framework? I: What\u0026rsquo;re the benefits of Spring framework\u0026rsquo;s transaction management? I: Explain what\u0026rsquo;s AOP. I: What\u0026rsquo;s a proxy and how to implement proxy pattern? I: How Spring MVC works? I: What\u0026rsquo;s the working scenario of Hibernate and MyBatis? I: How to implement SOA? I: Make a brief introduction of the projects you are involved before?  上面主要是面试Java程序员的问题，但是整个流程大致如此。\n"},{"idx":82,"href":"/python100days/docs/Day91-100/91-%E5%9B%A2%E9%98%9F%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/","title":"91 团队项目开发准备","content":" 团队项目开发准备 我们经常听到个人开发和团队开发这两个词，所谓个人开发就是一个人把控产品的所有内容；而团队开发则是由多个人组成团队并完成产品的开发。要实施团队开发以下几点是必不可少的：\n 必须对开发过程中的各种事件（例如：谁到什么时间完成了什么事情）进行管理和共享。 各类工作成果以及新的知识技巧等必须在团队内部共享。 管理工作成果的变更，既要防止成果被破坏，又要保证各个成员利用现有成果并行作业。 能够证明团队开发出的软件在任何时候都是可以正常运行的。 尽可能的使用自动化的工作流程，让团队成员能够正确的实施开发、测试和部署。  团队项目开发常见问题 问题1：传统的沟通方式无法确定处理的优先级 例如：使用邮件进行沟通可能出现邮件数量太多导致重要的邮件被埋没，无法管理状态，不知道哪些问题已经解决，哪些问题尚未处理，如果用全文检索邮件的方式来查询相关问题效率过于低下。\n解决方案：使用缺陷管理工具。\n问题2：没有能够用于验证的环境 例如：收到项目正式环境中发生的故障报告后，需要还原正式环境需要花费很长的时间。\n解决方法：实施持续交付。\n问题3：用别名目录管理项目分支 解决方法：实施版本控制。\n问题4：重新制作数据库非常困难 例如：正式环境和开发环境中数据库表结构不一致或者某个表列的顺序不一致。\n解决方法：实施版本控制。\n问题5：不运行系统就无法察觉问题 例如：解决一个bug可能引入其他的bug或者造成系统退化，不正确的使用版本系统覆盖了其他人的修改，修改的内容相互发生了干扰，如果问题不能尽早发现，那么等过去几个月后再想追溯问题就非常麻烦了。\n解决方法：实施持续集成，将团队成员的工作成果经常、持续的进行构建和测试。\n问题6：覆盖了其他成员修正的代码 解决方法：实施版本控制。\n问题7：无法实施代码重构 重构：在不影响代码产生的结果的前提下对代码内部的构造进行调整。\n例如：在实施代码重构时可能引发退化。\n解决方法：大量的可重用的测试并实施持续集成。\n问题8：不知道bug的修正日期无法追踪退化 解决方法：版本控制系统、缺陷管理系统和持续集成之间需要交互，最好能够和自动化部署工具集成到一起来使用。\n问题9：发布过程太复杂 解决方法：实施持续交付。\n基于对上述问题的阐述和分析，我们基本上可以得到以下的结论，在团队开发中版本控制、缺陷管理和持续集成都是非常重要且不可或缺的。\n版本控制 针对上面提到的一些问题，在团队开发的首要前提就是实施版本控制，对必要的信息进行管理，需要管理的内容包括：\n 代码。 需求和设计的相关文档。 数据库模式和初始数据。 配置文件。 库的依赖关系定义。  Git简介 Git是诞生于2005年的一个开源分布式版本控制系统，最初是Linus Torvalds（Linux之父） 为了帮助管理Linux内核开发而开发的一个版本控制软件。Git与常用的版本控制工具Subversion等不同，它采用了分布式版本控制的方式，在没有中央服务器支持的环境下也能够实施版本控制。\n对于有使用Subversion（以下简称为SVN）经验的人来说，Git和SVN一样摒弃了基于锁定模式的版本控制方案（早期的CVS和VSS使用的就是锁定模式）采用了合并模式，而二者的区别在于： 1. Git是分布式的，SVN是集中式的，SVN需要中央服务器才能工作。 2. Git把内容按元数据方式存储，而SVN是按文件，即把文件的元信息隐藏在一个.svn文件夹里。 3. Git分支和SVN的分支不同。 4. Git没有一个全局版本号而SVN有。 5. Git的内容完整性要优于SVN，Git的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。\n安装Git 可以在Git官方网站找到适合自己系统的Git下载链接并进行安装，安装成功后可以在终端中键入下面的命令检查自己的Git版本。\ngit --version 如果之前完全没有接触过Git，可以先阅读《git - 简易指南》来对Git有一个大致的了解。\n本地实施版本控制 可以使用下面的命令将目录创建为Git仓库。\ngit init 当你完成了上述操作后，本地目录就变成了下面的样子，左边是你正在操作的工作目录，而右边是你的本地仓库，中间是工作目录和本地仓库之间的一个暂存区（也称为缓存区）。\n通过git add可以将文件添加到暂存区。\ngit add \u0026lt;file\u0026gt; ... 可以用下面的方式将暂存区的指定文件恢复到工作区。\ngit checkout -- \u0026lt;file\u0026gt; 通过下面的命令可以将暂存区的内容纳入本地仓库。\ngit commit -m \u0026#39;本次提交的说明\u0026#39; 可以使用下面的命令查看文件状态和进行版本比较。\ngit status -s git diff 可以通过git log查看提交日志。\ngit log git log --graph --pretty=oneline --abbrev-commit 如果要回到历史版本，可以使用下面的命令。\ngit reset --hard \u0026lt;commit-id\u0026gt; git reset --hard HEAD^ 其他的一些命令可以参考阮一峰老师的《常用Git命令清单》或者是码云上的《Git大全》。\nGit服务器概述 对于Git来说不像SVN那样一定需要一个中心服务器，刚才我们的操作都是在本地执行的，如果你想通过Git分享你的代码或者与其他人协作，那么就需要服务器的支持。Github为Git提供了远程仓库，它是一个基于Git的代码托管平台，企业用户（付费用户）可以创建仓库，普通用户只能创建公开仓库（代码是可以是他人可见的）。Github是在2008年4月创办的，它上面代码库惊人的增长速度已经证明了它是非常成功的，在2018年6月，微软以75亿美元的天价收购了Github。国内也有类似的代码托管平台，最有名的当属码云和CODING，目前码云和CODING对注册用户都提供了受限的使用私有仓库的功能，同时还提供了对Pull Request的支持（后面会讲到），而且目前提供代码托管服务的平台都集成了“缺陷管理”、“WebHook”等一系列的功能，让我们能做的事情不仅仅是版本控制。当然，如果公司需要也可以搭建自己的Git服务器，具体的方式我们就不在这里进行介绍了，有兴趣的可以自行了解。\n我们可以在码云或者CODING上注册账号，也可以使用第三方登录（github账号、微信账号、新浪微博账号、CSDN账号等）的方式。登录成功后就可以创建项目，创建项目几乎是“傻瓜式”的，我们只说几个值得注意的地方。\n 添加项目成员。创建项目后，可以在项目的“设置”或“管理”中找到“成员管理”功能，这样就可以将其他开发者设置为项目团队的成员，项目成员通常分为“所有者”、“管理者”、“普通成员”和“受限成员”几种角色。\n 设置公钥实现免密操作。在项目的“设置”或“管理”中我们还可以找到“部署公钥管理”的选项，通过添加部署公钥，可以通过SSH（安全远程连接）的形式访问服务器而不用每次输入用户名和口令。可以使用ssh-keygen命令来创建密钥对。\nssh-keygen -t rsa -C \u0026#34;your_email@example.com\u0026#34;  使用Git进行开发 克隆服务器上的代码到本地机器。\ngit clone \u0026lt;url\u0026gt; 在自己的分支上进行开发。\ngit branch \u0026lt;branch-name\u0026gt; git checkout \u0026lt;branch-name\u0026gt; 或者\ngit checkout -b \u0026lt;branch-name\u0026gt; 接下来可以先在本地实施版本控制（操作的方式与前面相同不再赘述），然后再将自己的分支Push到服务器。\ngit push origin \u0026lt;branch-name\u0026gt; 最后，当工作完成时，可以发起一个Pull Request，请求将代码合并到master分支。\n分支策略的模式 上面讲解的方式，其实是一种称为github-flow的分支策略模式，这种模式的操作步骤包括：\n master的内容都是可以进行发布的内容。 开发时应该以master为基础建立新分支。 分支先在本地实施版本控制，然后以同名分支定期向服务器进行Push。 开发结束后向master发送Pull Request。 Pull Request通过代码审查之后合并到master，并从master向正式环境发布。  在使用github-flow时的注意事项有以下三点：\n master是用于发布的，不能直接在master上进行修改。 开始日常开发工作时要首先建立分支。 工作完成后向master发送Pull Request。  除了上述的github-flow工作方式外，还有一种名为git-flow的分支策略模式，它借鉴了中央集权型版本控制系统的长处，为团队内部统一管理建立分支的方法、合并操作和关闭分支的方法。在这种模式下，项目有两个长线分支，分别是master和develop，其他的都是临时的、短暂的辅助分支，包括feature（开发特定功能的分支，开发结束后合并到develop）、release（从develop分离出来的为发布做准备的分支，发布结束后合并到master和develop）和hotfix（产品发布后出现问题时紧急建立的分支，直接从master分离，问题修复后合并到master并打上标签，同时还要合并到develop来避免将来的版本遗漏了这个修复工作，如果此时有正在发布中的release分支，还要合并到release分支）。这套方式分支策略简单清晰且容易理解，但是在运用上会稍微有些复杂，需要一些脚本来辅助版本控制的实施。\n缺陷管理 没有好的团队管理工具必然导致项目进展不顺利，任务管理困难，而引入缺陷管理系统正好可以解决这些问题，通常一个缺陷管理系统都包含了以下的功能：\n 任务管理（包括必须做什么、谁来做、什么时候完成、现在处于什么状态等）。 直观而且可以检索过去发生的各种问题。 能够对信息进行统一的管理和共享。 能够生成各类报表。 能够关联到其他系统，具有可扩展性。  Redmine是基于Ruby on Rails框架的开源缺陷管理系统，提供了问题管理、代码管理、Wiki等必要的功能，而且支持插件系统，扩展起来也非常容易。\n如果希望了解和使用Redmine，可以关注Redmine中文网，上面提供了视频教程、经验分享以及其他的安装和使用上的指导。\n持续集成 为了快速的产生高品质的软件，在团队开发中，持续集成（CI）也是一个非常重要的基础。按照经典的软件过程模型（瀑布模型），集成的工作一般要等到所有的开发工作都结束后才能开始，但这个时候如果发现了问题，修复问题的代价是非常具体的。基本上，集成实施得越晚，代码量越大，解决问题就越困难。持续集成将版本控制、自动化构建、代码测试融入到一起，让这些工作变得自动化和可协作。由于其频繁重复整个开发流程（在指定时间内多次pull源代码并运行测试代码），所以能帮助开发者提早发现问题。\n在所有的CI工具中，Jenkins和TravisCI是最具有代表性的。\nJenkins 是基 Java的开源CI工具，其安装和操作都很简单。另外，Jenkins不仅能在面板上轻松看出任务成功或失败，还可以借助通知功能将结果以邮件或RSS订阅的形式发给用户。与此同时，Jenkins也允许通过插件进行功能扩展，所需功能可以随用随添加，而且还支持主从式集群，能够轻松的进行水平扩展。\n"},{"idx":83,"href":"/python100days/docs/Day91-100/92-%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1/","title":"92 使用 Docker部署服务","content":" 使用Docker部署服务 Docker简介 软件开发中最为麻烦的事情可能就是配置环境了。由于用户使用的操作系统具有多样性，即便使用跨平台的开发语言（如Java和Python）都不能保证代码能够在各种平台下都可以正常的运转，而且在不同的环境下我们安装的软件需要依赖的软件包也是不一样的。\n那么问题来了，我们安装软件的时候可不可以把软件运行的环境一并安装？我们是不是可以把原始环境一模一样地复制过来呢？\n虚拟机（virtual machine）就是带环境安装的一种解决方案，它可以在一种操作系统里面运行另一种操作系统，比如在Windows系统里面运行Linux系统，在macOS上运行Windows，而应用程序对此毫无感知。使用过虚拟机的人都知道，虚拟机用起来跟真实系统一模一样，而对于虚拟机的宿主系统来说，虚拟机就是一个普通文件，不需要了就删掉，对宿主系统或者其他的程序并没有影响。但是虚拟机通常会占用较多的系统资源，启动和关闭也非常的缓慢，总之用户体验并没有想象中的那么好。\nDocker属于对Linux容器技术的一种封装（利用了Linux的namespace和cgroup技术），它提供了简单易用的容器使用接口，是目前最流行的 Linux 容器解决方案。Docker将应用程序与该程序的依赖打包在一个文件里面，运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。下图是虚拟机和容器的对比，左边是传统的虚拟机，右边是Docker。\n目前，Docker主要用于几下几个方面：\n 提供一次性的环境。 提供弹性的云服务（利用Docker很容易实现扩容和收缩）。 实践微服务架构（隔离真实环境在容器中运行多个服务）。  安装Docker 下面以CentOS为例讲解如何安装Docker，使用Ubuntu、macOS或Windows的用户可以通过点击对应的链接了解这些平台下如何进行安装。\n 确定操作系统内核版本（CentOS 7要求64位，内核版本3.10+；CentOS 6要求64位，内核版本2.6+），可以通过下面的命令确定Linux系统内核版本。\nuname -r 在CentOS下使用yum安装Docker并启动。\nyum -y install docker systemctl start docker 查看Docker的信息和版本。\ndocker version docker info  接下来可以通过下载镜像和创建容器来看看Docker是否可以运转起来。可以使用下面的命令从Docker的镜像仓库下载名为hello-world的镜像文件。\ndocker pull hello-world 查看所有镜像文件。\ndocker images REPOSITORY TAG IMAGE ID CREATED SIZE docker.io/hello-world latest fce289e99eb9 7 months ago 1.84 kB  通过镜像文件创建并运行容器。\ndocker container run --name mycontainer hello-world  说明：其中mycontainer是我们给容器起的名字，跟在--name参数之后；hello-world就是我们刚才下载的镜像文件。\n Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \u0026quot;hello-world\u0026quot; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/  如果要删除这个容器，可以使用下面的命令。\ndocker container rm mycontainer 在删除容器之后，我们还可以删除刚才下载的镜像文件。\ndocker rmi hello-world  说明：如果要在Ubuntu（内核版本3.10+）下面安装和启动Docker，可以按照如下的步骤进行。\n\u0026gt; apt update \u0026gt; apt install docker-ce \u0026gt; service docker start \u0026gt; ``` \u0026gt; \u0026gt; 国内用户可以通过更换Ubuntu软件下载源来提升下载速度，具体请参照清华大学开源软件镜像站上的[《Ubuntu镜像使用帮助》](\u0026lt;https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/\u0026gt;)。 安装Docker后，由于直接访问[dockerhub](https://hub.docker.com/)下载镜像会非常缓慢，建议将服务器更换为国内镜像，可以通过修改 `/etc/docker/daemon.js` 文件来做到。 JavaScript { \u0026ldquo;registry-mirrors\u0026rdquo;: [ \u0026ldquo;http://hub-mirror.c.163.com\u0026quot;, \u0026ldquo;https://registry.docker-cn.com\u0026quot; ] }\n ## 使用Docker ### 安装Nginx 下面我们就基于Docker来创建一台HTTP服务器，我们选择用Nginx来搭建该服务，因为Nginx是高性能的Web服务器，同时也是做反向代理服务器的上佳选择。要做到这件事情，只需要使用下面的命令在Docker中创建一个容器即可。  Shell docker container run -d -p 80:80 \u0026ndash;rm \u0026ndash;name mynginx nginx\n \u0026gt; 说明：上面的参数`-d`表示容器在后台运行（不产生输出到Shell）并显示容器的ID；`-p`是用来映射容器的端口到宿主机的端口，冒号前面是宿主机的端口，冒号后面是容器内部使用的端口；`--rm`表示容器停止后自动删除容器，例如执行命令`docker container stop mynginx`后，容器就不复存在了；`--name`后面的mynginx是自定义的容器名字；在创建容器的过程中，需要用到nginx的镜像文件，镜像文件的下载是自动完成的，如果没有指定版本号，默认是最新版本（latest）。 如果需要将自己的Web项目（页面）部署到Nginx上，可以使用容器拷贝命令将指定路径下所有的文件和文件夹拷贝到容器的指定目录中。  Shell docker container cp /root/web/index.html mynginx:/usr/share/nginx/html\n 如果不愿意拷贝文件也可以在创建容器时通过数据卷操作`--volume`将指定的文件夹映射到容器的某个目录中，例如将Web项目的文件夹直接映射到`/usr/share/nginx/html`目录。我们先通过下面的命令让刚才创建的容器停止运行。  Shell docker container stop mynginx\n 然后用下面的命令重新创建容器。  Shell docker container run -d -p 80:80 \u0026ndash;rm \u0026ndash;name mynginx \u0026ndash;volume $PWD/html:/usr/share/nginx/html nginx\n \u0026gt; 说明：上面创建容器和拷贝文件的命令中，`container`是可以省略的，也就是说`docker container run`和`docker run`是一样的，而`docker container cp`和`docker cp`是一样的。此外，命令中的`--volume`也可以缩写为`-v`，就如同`-d`是`--detach`的缩写，`-p`是`--publish`的缩写。`$PWD`代表宿主系统当前文件夹，这些对于使用过Unix或者Linux系统的人来说，应该是很容易理解的。 要查看运行中的容器，可以使用下面的命令。  Shell docker ps\n  CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 3c38d2476384 nginx \u0026ldquo;nginx -g \u0026lsquo;daemon \u0026hellip;\u0026rdquo; 4 seconds ago Up 4 seconds 0.0.0.0:80-\u0026gt;80/tcp mynginx\n 要启动和停止容器，可以使用下面的命令。  Shell docker start mynginx docker stop mynginx\n 由于在创建容器时使用了`--rm`选项，容器在停止时会被移除，当我们使用下面的命令查看所有容器时，应该已经看不到刚才的`mynginx`容器了。  Shell docker container ls -a\n 如果在创建容器时没有指定`--rm`选项，那么也可以使用下面的命令来删除容器。  Shell docker rm mynginx\n 要删除正在运行中的容器，需要使用`-f`选项。  Shell docker rm -f mynginx\n ### 安装MySQL 我们再来尝试用Docker安装一台MySQL服务器，首先可以先检查一下有没有MySQL的镜像文件。  Shell docker search mysql\n  INDEX NAME DESCRIPTION STARS OFFICIAL AUTOMATED docker.io docker.io/mysql MySQL is a \u0026hellip; 8486 [OK] \u0026hellip;\n \u0026gt; 说明：上面查询结果的列依次代表索引、镜像名、镜像描述、用户评价、是否官方镜像、自动构建。 下载MySQL镜像并指定镜像的版本号。  Shell docker pull mysql:5.7\n 如果需要查看已经下载的镜像文件，可以使用下面的命令。  Shell docker images\n  REPOSITORY TAG IMAGE ID CREATED SIZE docker.io/nginx latest e445ab08b2be 2 weeks ago 126 MB docker.io/mysql 5.7 f6509bac4980 3 weeks ago 373 MB\n 创建并运行MySQL容器。  Shell docker run -d -p 3306:3306 \u0026ndash;name mysql57 -v $PWD/mysql/conf:/etc/mysql/mysql.cnf.d -v $PWD/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7\n 注意，上面创建容器时我们又一次使用了数据卷操作，那是因为通常容器是随时创建随时删除的，而数据库中的数据却是需要保留下来的，所以上面的两个数据卷操作一个是映射了MySQL配置文件所在的文件夹，一个是映射了MySQL数据所在的文件夹，这里的数据卷操作非常重要。我们可以将MySQL的配置文件放在`$PWD/mysql/conf`目录下，配置文件的具体内容如下所示：  INI [mysqld] pid-file=/var/run/mysqld/mysqld.pid socket=/var/run/mysqld/mysqld.sock datadir=/var/lib/mysql log-error=/var/log/mysql/error.log server-id=1 log-bin=/var/log/mysql/mysql-bin.log expire_logs_days=30 max_binlog_size=256M symbolic-links=0\n 如果安装了MySQL 8.x版本（目前的最新版本），在使用客户端工具连接服务器时可能会遇到`error 2059: Authentication plugin 'caching_sha2_password' cannot be loaded`的问题，这是因为MySQL 8.x默认使用了名为“caching_sha2_password”的机制对用户口令进行了更好的保护，但是如果客户端工具不支持新的认证方式，连接就会失败。解决这个问题有两种方式：一是升级客户端工具来支持MySQL 8.x的认证方式；二是进入容器，修改MySQL的用户口令认证方式。下面是具体的步骤，我们先用`docker exec`命令进入容器的交互式环境，假设运行MySQL 8.x的容器名字叫`mysql8x`。  Shell docker exec -it mysql8x /bin/bash\n 进入容器的交互式Shell之后，可以首先利用MySQL的客户端工具连接MySQL服务器。  Shell mysql -u root -p Enter password: Your MySQL connection id is 16 Server version: 8.0.12 MySQL Community Server - GPL Copyright \u0026copy; 2000, 2018, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type \u0026lsquo;help;\u0026rsquo; or \u0026lsquo;\\h\u0026rsquo; for help. Type \u0026lsquo;\\c\u0026rsquo; to clear the current input statement. mysql\u0026gt;\n 接下来通过SQL来修改用户口令就可以了。  SQL alter user \u0026lsquo;root\u0026rsquo;@\u0026lsquo;%\u0026rsquo; identified with mysql_native_password by \u0026lsquo;123456\u0026rsquo; password expire never;\n 当然，如果愿意你也可以查看一下用户表检查是否修改成功。  SQL use mysql; select user, host, plugin, authentication_string from user where user=\u0026lsquo;root\u0026rsquo;; +\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | user | host | plugin | authentication_string | +\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ | root | % | mysql_native_password | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 | | root | localhost | mysql_native_password | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 | +\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+ 2 rows in set (0.00 sec)\n 在完成上面的步骤后，现在即便不更新客户端工具也可以连接MySQL 8.x了。 ### 安装Redis 接下来我们试一试运行多个容器并让多个容器之间通过网络通信。我们创建4个Redis容器来实现一主三从的主从复制结构。  Shell docker run -d -p 6379:6379 \u0026ndash;name redis-master redis redis-server docker run -d -p 6380:6379 \u0026ndash;name redis-slave-1 \u0026ndash;link redis-master:redis-master redis redis-server \u0026ndash;replicaof redis-master 6379 docker run -d -p 6381:6379 \u0026ndash;name redis-slave-2 \u0026ndash;link redis-master:redis-master redis redis-server \u0026ndash;replicaof redis-master 6379 docker run -d -p 6382:6379 \u0026ndash;name redis-slave-3 \u0026ndash;link redis-master:redis-master redis redis-server \u0026ndash;replicaof redis-master 6379\n 上面的命令中，`--link`参数用于给容器创建网络别名，因为三台从机（slave）需要通过网络连接自己的主机（master）。虽然，我们可以通过`docker inspect --format '{{ .NetworkSettings.IPAddress }}' \u0026lt;container-ID\u0026gt;`命令来查看到容器的IP地址，但是由于容器的即装即用性，容器的IP地址有可能会发生变化，如果直接使用IP地址，在容器重启后就可能会因为IP地址的变化导致从机无法连接到主机。使用`--link`参数创建网络别名就是为了在启动Redis服务器时在`redis-server`后面的`--replicaof`参数后使用这个别名而不是IP地址。 接下来我们进入名为`redis-master`的容器，看看主从复制的配置是否成功。  Shell docker exec -it redis-master /bin/bash\n 通过`redis-cli`启动命令行工具。  Shell redis-cli 127.0.0.1:6379\u0026gt; info replication\nReplication role:master connected_slaves:3 slave0:ip=172.17.0.4,port=6379,state=online,offset=1988,lag=0 slave1:ip=172.17.0.5,port=6379,state=online,offset=1988,lag=1 slave2:ip=172.17.0.6,port=6379,state=online,offset=1988,lag=1 master_replid:94703cfa03c3ddc7decc74ca5b8dd13cb8b113ea master_replid2:0000000000000000000000000000000000000000 master_repl_offset:1988 second_repl_offset:-1 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:1 repl_backlog_histlen:1988\n ## 构建镜像 Docker镜像是由文件系统叠加而成的，系统的最底层是bootfs，相当于就是Linux内核的引导文件系统；接下来第二层是rootfs，这一层可以是一种或多种操作系统（如Debian或Ubuntu文件系统），Docker中的rootfs是只读状态的；Docker利用联合挂载技术将各层文件系统叠加到一起，最终的文件系统会包含有底层的文件和目录，这样的文件系统就是一个镜像，如下图所示。 之前我们讲过了如何查找、列出镜像和拉取（下载）镜像，接下来看看构建镜像的两种方式： 1. 使用`docker commit`命令。（不推荐） 2. 使用`docker build`命令和Dockerfile文件。 ### 使用commit命令构建镜像 为了演示如何构建镜像，我们先使用Ubuntu镜像来定制一个容器，命令如下所示。  Shell docker run \u0026ndash;name myubuntu -it ubuntu /bin/bash\n 在容器中执行下面的命令来安装Apache服务器并退出容器。  Shell apt -y upgrade apt -y install apache2 exit\n 我们将这个容器作为一个定制的Web服务器保存起来，当需要这样一台Web服务器的时候，就没有必要重新创建容器并安装Apache了。 首先我们通过下面的命令查看容器的ID。  Shell docker container ls -a\n  docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 014bdb321612 ubuntu \u0026ldquo;/bin/bash\u0026rdquo; 5 minutes ago Exited (0) myubuntu\n 提交定制的容器。  Shell docker commit 014bdb321612 jackfrued/mywebserver\n 查看镜像文件。  Shell docker images\n  REPOSITORY TAG IMAGE ID CREATED SIZE jackfrued/mywebserver latest 795b294d265a 14 seconds ago 189 MB\n 生成镜像文件以后，后面就可以利用刚才创建的镜像文件来创建新的容器。 ### 使用Dockerfile构建镜像 Dockerfile使用DSL（Domain Specific Language）来构建一个Docker镜像，只要编辑好了Dockerfile文件，就可以使用`docker build`命令来构建一个新的镜像。 我们先创建一个新的文件夹并在文件夹下创建名为Dockerfile的文件。  Shell mkdir test cd test touch Dockerfile\n 编辑这个Dockerfile文件添加如下所示的内容。  Shell vim Dockerfile\n  Dockerfile\nversion: 0.0.1 FROM ubuntu:14.04 MAINTAINER jackfrued \u0026ldquo;jackfrued@126.com\u0026rdquo; RUN apt-get update \u0026amp;\u0026amp; apt-get install -y nginx RUN echo \u0026lsquo;hello, world!\u0026rsquo; \u0026gt; /usr/share/nginx/html/index.html EXPOSE 80\n 我们来解释一下上面的Dockerfile文件。Dockerfile文件通过特殊的指令来指定基础镜像（FROM指令）、创建容器后需要指定的命令（RUN指令）以及需要暴露的端口（EXPOSE）等信息。我们稍后会专门为大家介绍这些Dockfile中的指令。 接下来我们可以使用`docker build`命令来创建镜像，如下所示。  Shell docker build -t=\u0026ldquo;jackfrued/webserver\u0026rdquo; .\n 通过下面的命令可以查看创建好的镜像。  Shell docker images\n  REPOSITORY TAG IMAGE ID CREATED SIZE jackfrued/webserver latest 87d6cb096be2 23 minutes ago 222 MB\n 如果想知道镜像文件是如何创建出来的，可以使用下面的命令。  Shell docker history jackfrued/webserver\n  IMAGE CREATED CREATED BY SIZE 87d6cb096be2 25 minutes ago /bin/sh -c #(nop) EXPOSE 80/tcp 0 B\n53d3bc3a123e 25 minutes ago /bin/sh -c service nginx start 3 B 10646b63275e 25 minutes ago /bin/sh -c echo \u0026lsquo;hello, world!\u0026rsquo; \u0026gt; /usr/sha\u0026hellip; 14 B f3e3bf3e998e 25 minutes ago /bin/sh -c apt-get update \u0026amp;\u0026amp; apt-get insta\u0026hellip; 34.3 MB c98e22cf5a64 26 minutes ago /bin/sh -c #(nop) MAINTAINER jackfrued \u0026ldquo;j\u0026hellip; 0 B 2c5e00d77a67 3 months ago /bin/sh -c #(nop) CMD [\u0026ldquo;/bin/bash\u0026rdquo;] 0 B  3 months ago /bin/sh -c mkdir -p /run/systemd \u0026amp;\u0026amp; echo \u0026lsquo;\u0026hellip; 7 B  3 months ago /bin/sh -c rm -rf /var/lib/apt/lists/* 0 B  3 months ago /bin/sh -c set -xe \u0026amp;\u0026amp; echo \u0026lsquo;#!/bin/sh\u0026rsquo; \u0026gt;\u0026hellip; 195 kB  3 months ago /bin/sh -c #(nop) ADD file:1e01ab604c0cc30\u0026hellip; 188 MB\n 使用该镜像来创建容器运行Web服务器。  Shell docker run -d -p 80:80 \u0026ndash;name mywebserver jackfrued/webserver nginx -g \u0026ldquo;daemon off;\u0026rdquo;\n 如果希望将上面创建的镜像文件放到dockerhub仓库中，可以按照如下所示的步骤进行操作。 通过下面的命令登录到dockerhub。  Shell docker login\n 输入用户名和口令进行登录。  Login with your Docker ID to push and pull images from Docker Hub. If you don\u0026rsquo;t have a Docker ID, head over to https://hub.docker.com to create one. Username: jackfrued Password: Login Succeeded\n 通过下面的命令将镜像推到仓库中。  Shell docker push jackfrued/webserver\n ![](Day91-100/res/dockerhub-repo.png) ### Dockerfile指令 想了解Dockerfile的指令可以查看官方提供的[参考手册](\u0026lt;https://docs.docker.com/engine/reference/builder/\u0026gt;)，下面我们为大家介绍一些常用的指令。 1. **FROM**：设置基础镜像，必须是Dockerfile中的第一条指令。  Dockerfile FROM \u0026lt;镜像名\u0026gt; [AS \u0026lt;别名\u0026gt;]\n 或  Dockerfile FROM \u0026lt;镜像名\u0026gt;[:\u0026lt;标签\u0026gt;] [AS \u0026lt;别名\u0026gt;]\n 2. **RUN**：指定构建镜像时要执行的命令。  Dockerfile RUN \u0026lt;命令\u0026gt; [参数1], [参数2], \u0026hellip;\n 或  Dockerfile RUN [\u0026ldquo;可执行文件\u0026rdquo;, \u0026ldquo;参数1\u0026rdquo;, \u0026ldquo;参数2\u0026rdquo;, \u0026hellip;]\n 3. **CMD**：指定构建镜像后要执行的命令。  Dockerfile CMD \u0026lt;命令\u0026gt; [参数1], [参数2], \u0026hellip;\n 或  Dockerfile CMD [\u0026ldquo;可执行文件\u0026rdquo;, \u0026ldquo;参数1\u0026rdquo;, \u0026ldquo;参数2\u0026rdquo;, \u0026hellip;]\n \u0026gt; 说明：Docker不同于虚拟机，容器本身就是一个进程，容器中的应用应该位于前台运行。CMD命令相当于就是用来指定容器主进程（创建容器后要在前台执行的程序）的，如果主进程结束了，容器也就停止运行了。所以在容器中启动Nginx不能使用`service nginx start`或是`systemctl start nginx`而是要通过`CMD [\u0026quot;nginx\u0026quot;, \u0026quot;-g\u0026quot;, \u0026quot;daemon off;\u0026quot;]`让它在前台运行。 4. **ENTRYPOINT**：和CMD类似，也可以执行命令，但`docker run`命令行中指定的任何参数都会被当做参数再次传给ENTRYPOINT指令中的命令，这就使得我们可以构建一个镜像，它既可以运行一个默认的命令，也支持通过`docker run`命令行为该命令指定可覆盖的参数选项。  Dockerfile ENTRYPOINT \u0026lt;命令\u0026gt; [参数1], [参数2], \u0026hellip;\n 或  Dockerfile ENTRYPOINT [\u0026ldquo;可执行文件\u0026rdquo;, \u0026ldquo;参数1\u0026rdquo;, \u0026ldquo;参数2\u0026rdquo;, \u0026hellip;]\n 5. **WORKDIR**：在通过镜像创建新容器时，在容器内部创建一个工作目录，ENTRYPOINT和CMD指定的程序会在这个目录下执行。在使用`docker run`命令时可以通过`-w`参数来覆盖由WORKDIR指定的工作目录。例如：  Dockerfile WORKDIR /opt/webapp\n  Shell docker run -w /usr/share/webapp \u0026hellip;\n 6. **ENV**：在创建镜像时设置环境变量。在使用`docker run`命令时，可以通过`-e`参数来修改环境变量的设置。例如：  Dockerfile ENV DEFAULT_PORT=8080\n  Shell docker run -e \u0026ldquo;DEFAULT_PORT=8000\u0026rdquo; \u0026hellip;\n 7. **USER**：指定镜像会以什么用户身份去运行。例如：  Dockerfile USER nginx\n 8. **VOLUME**：在创建容器时添加一个数据卷的挂载点。通过数据卷操作可以实现容器间数据的共享和重用，对卷所作的修改可以马上生效而不需要重新启动容器，我们之前创建容器时使用`—volume`参数就是为了实现数据卷的映射操作。  Dockerfile VOLUME [\u0026ldquo;/路径1\u0026rdquo;, \u0026ldquo;/路径2/子路径2.1/\u0026rdquo;, \u0026hellip;]\n 9. **ADD**：将构建目录下的文件和文件夹复制到镜像中，如果是压缩文件和归档文件，ADD命令会对这些文件进行解压缩解归档的操作。  Dockerfile ADD [\u0026ndash;chown=\u0026lt;用户\u0026gt;:\u0026lt;用户组\u0026gt;] \u0026lt;源文件\u0026gt; \u0026lt;目标文件\u0026gt;\n 10. **COPY**：非常类似于ADD，但不会主动对文件进行提取操作。 11. **LABEL**：为Docker镜像添加一些元数据，在使用`docker inspect`命令时会看到这些元数据。 ```Dockerfile LABEL version=\u0026quot;1.0.0\u0026quot; location=\u0026quot;Chengdu\u0026quot; ``` 12. **ONBUILD**：为镜像添加触发器，当一个镜像被用作其他镜像的基础镜像，触发器将会被执行。例如： ```Dockerfile ONBUILD ADD . /app/src ONBUILD RUN cd /app/src \u0026amp;\u0026amp; make ``` ## 容器编排 我们的项目可能会使用了多个容器，容器多了之后管理容器的工作就会变得麻烦。如果要对多个容器进行自动配置使得容器可以相互协作甚至实现复杂的调度，这就需要进行容器编排。Docker原生对容器编排的支持非常弱，但是可以通过社区提供的工具来实现容器编排。 ### Docker Compose 可以通过安装Docker Compose工具来实现基于YAML文件的容器编排，YAML文件会定义一系列的容器以及容器运行时的属性，Docker Compose会根据这些配置来管理容器。 1. 安装Docker Compose。  Shell curl -L https://github.com/docker/compose/releases/download/1.25.0-rc2/docker-compose-`uname -s-uname -m` -o /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose\n \u0026gt; 说明：如果没有curl工具，在CentOS下可以先通过包管理工具yum安装curl再执行上面的命令。 当然我们也可以使用Python的包管理工具pip来安装Docker Compose，命令如下所示。  Shell pip3 install -U docker-compose\n 2. 使用Docker Compose。 我们先创建一个名为`composeapp`的文件夹并在该文件夹下创建两个子文件夹`product-service`和`web-site`，如下所示。  Shell mkdir composeapp cd composeapp mkdir product-service mkdir web-site\n 我们先在`product-service`文件夹下编写提供数据的API接口程序。  Shell vim product-service/api.py\n 我们用Flask来实现一个非常简单的数据接口服务程序。  Python from pickle import dumps, loads\n from flask import Flask from flask_restful import Resource, Api from redis import Redis from flask_cors import CORS\napp = Flask(name) CORS(app, resources={r\u0026rsquo;/api/\u0026lsquo;: {\u0026lsquo;origins\u0026rsquo;: \u0026lsquo;\u0026rsquo;}}) api = Api(app) redis = Redis(host=\u0026lsquo;redis-master\u0026rsquo;, port=6379)\nclass Product(Resource):\n def get(self): data = redis.get('products') if not data: products = ['Ice Cream', 'Chocolate', 'Coca Cola', 'Hamburger'] redis.set('products', dumps(products)) else: products = loads(data) return {'products': products}  api.add_resource(Product, \u0026lsquo;/api/products\u0026rsquo;)\nif name == \u0026lsquo;main\u0026lsquo;: app.run(host=\u0026lsquo;0.0.0.0\u0026rsquo;, port=8000, debug=True)\n 由于上面的项目需要依赖`flask`、 `flask-restful`等三方库，所以我们再添加一个指明依赖库的文件并将其命名为`requirements.txt`，其内容如下所示。  Shell vim product-service/requirements.txt\n  flask flask-restful flask-cors redis\n 稍后我们会将上面的接口服务放在一个容器中运行，为此我们先编写一个Dockerfile文件以便创建对应的镜像，其内容如下所示。  Shell vim product-service/Dockerfile\n  Dockerfile FROM python:3 ADD . /root/product-service WORKDIR /root/product-service RUN pip install -r requirements.txt CMD [\u0026ldquo;python\u0026rdquo;, \u0026ldquo;api.py\u0026rdquo;]\n 我们再去到`web-site`目录下创建一个页面，稍后我们会通一个容器来提供Nginx服务并运行该页面，而这个页面会访问我们刚才部署的数据接口服务获取数据并通过Vue.js将数据渲染到页面上。  Shell vim web-site/index.html\n  HTML \u0026lt;!DOCTYPE html\u0026gt;  首页   产品列表  {{ product }}     new Vue({ el: \u0026lsquo;#app\u0026rsquo;, data: { products: [] }, created() { fetch(\u0026lsquo;http://1.2.3.4:8000/api/products') .then(resp =\u0026gt; resp.json()) .then(json =\u0026gt; {this.products = json.products}) } })   \n 接下来，我们要通过一个YAML文件来创建三个容器并指明容器之间的依赖关系。  Shell vim docker-compose.yml\n  YAML version: \u0026lsquo;3\u0026rsquo; services:\n product-service: build: ./product-service ports: - '8000:8000' links: - redis-master web-site: image: nginx ports: - '80:80' volumes: - ./web-site:/usr/share/nginx/html redis-master: image: redis expose: - '6379'   有了这个YAML文件，我们就可以使用`docker-compose`命令来创建和管理这三个容器，其命令如下所示。  Shell docker-compose up\n  Creating network \u0026ldquo;composeapp_default\u0026rdquo; with the default driver Building product-service Step 1\u0026frasl;5 : FROM python:3 \u0026mdash;\u0026gt; e497dabd8450 Step 2\u0026frasl;5 : ADD . /root/product-service \u0026mdash;\u0026gt; fbe62813d595 Removing intermediate container 6579e845565a Step 3\u0026frasl;5 : WORKDIR /root/product-service \u0026mdash;\u0026gt; 3a722675e3b1 Removing intermediate container 57fc490436ce Step 4\u0026frasl;5 : RUN pip install -r requirements.txt \u0026mdash;\u0026gt; Running in cadc2d0c1b9b \u0026hellip; \u0026hellip; \u0026mdash;\u0026gt; fc747fc11f4a Removing intermediate container cadc2d0c1b9b Step 5\u0026frasl;5 : CMD python api.py \u0026mdash;\u0026gt; Running in ecbbd2a69906 \u0026mdash;\u0026gt; 637e760f2e5b Removing intermediate container ecbbd2a69906 Successfully built 637e760f2e5b WARNING: Image for service product-service was built because it did not already exist. To rebuild this image you must use docker-compose build or docker-compose up --build. Creating composeapp_redis-master_1 \u0026hellip; done Creating composeapp_web-site_1 \u0026hellip; done Creating composeapp_product-service_1 \u0026hellip; done Attaching to composeapp_redis-master_1, composeapp_web-site_1, composeapp_product-service_1 \u0026hellip; \u0026hellip; ```\n"},{"idx":84,"href":"/python100days/docs/Day91-100/93-MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","title":"93 My S Q L性能优化","content":" MySQL性能优化 使用索引 在前面《关系型数据库MySQL》一文中，我们已经讲到过索引的相关知识，这里我们做一个简单的回顾。\n B-Tree索引 HASH索引 R-Tree索引（空间索引） Full-text索引（全文索引）  使用过程 过程，通常也称之为存储过程。\ncreate procedure ... (params) begin ... end; call ...cursor.callproc(\u0026#39;...\u0026#39;) 数据分区 SQL优化  通过show status了解各种SQL的执行频率。\nshow status like \u0026#39;com_%\u0026#39;; show status like \u0026#39;innodb_%\u0026#39;; show status like \u0026#39;connections\u0026#39;; show status like \u0026#39;slow_queries\u0026#39;; 定位低效率的SQL语句 - 慢查询日志。\nshow processlist 通过explain了解SQL的执行计划。\n select_type：查询类型（simple、primary、union、subquery） table：输出结果集的表 type：访问类型（ALL、index、range、ref、eq_ref、const、NULL） possible_keys：查询时可能用到的索引 key：实际使用的索引 key_len：索引字段的长度 rows：扫描的行数 extra：额外信息  通过show profiles和show profile for query分析SQL。\n 优化CRUD操作。\n 优化insert语句 优化order by语句 优化group by语句 优化嵌套查询 优化or条件 优化分页查询 使用SQL提示  USE INDEX IGNORE INDEX FORCE INDEX    配置优化  调整max_connections 调整back_log 调整table_open_cache 调整thread_cache_size 调整innodb_lock_wait_timeout  架构优化  通过拆分提高表的访问效率  垂直拆分 水平拆分  逆范式理论  数据表设计的规范程度称之为范式（Normal Form）  1NF：列不能再拆分 2NF：所有的属性都依赖于主键 3NF：所有的属性都直接依赖于主键（消除传递依赖） BCNF：消除非平凡多值依赖   使用中间表提高统计查询速度 主从复制和读写分离 配置MySQL集群  "},{"idx":85,"href":"/python100days/docs/Day91-100/94-%E7%BD%91%E7%BB%9CAPI%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/","title":"94 网络 a P I接口设计","content":" 网络API接口设计 手机App以及使用了Ajax技术或做了前后端分离的页面都需要通过网络API（Application Programming Interface）和后台进行交互，所谓API，指的应用程序的编程接口；而网络API通畅指的是基于HTTP或HTTPS协议的一个URL（统一资源定位符），通过这个URL我们可以让服务器对某个资源进行操作并返回操作的结果。基于HTTP(S)协议最大的好处就在于访问起来非常的简单方便，而且没有编程语言和应用环境上的差别。\n设计原则 关键问题 为移动端或者PC端设计网络API接口一个非常重要的原则是：根据业务实体而不是用户界面或操作来设计。如果API接口的设计是根据用户的操作或者界面上的功能设置来设计，随着需求的变更，用户界面也会进行调整，需要的数据也在发生变化，那么后端开发者就要不停的调整API，或者给一个API设计出多个版本，这些都会使项目的开发和维护成本增加。\n下面是某个网站开放API的接口，可以看出API的设计是围绕业务实体来进行的，而且都做到了“见名知意”。\n   评论      comments/show 获取某条微博的评论列表   comments/by_me 自己的评论列表   comments/to_me 收到的评论列表   comments/mentions @了自己的评论列表   comments/create 创建一条评论   comments/destroy 删除一条评论   comments/reply 回复一条评论    注意：上面的API接口并不是REST风格的，关于REST的知识，可以阅读阮一峰老师的《理解RESTful架构》以及《RESTful API设计指南》。\nAPI接口返回的数据通常都是JSON或XML格式，我们这里不讨论后者。对于JSON格式的数据，我们需要做到不要返回null这的值，因为这样的值一旦处置失当，会给移动端的开发带来麻烦（移动端可能使用强类型语言）。要解决这个问题可以从源头入手，在设计数据库的时候，尽量给每个字段都加上“not null”约束或者设置合理的默认值约束。\n其他问题  更新提示问题：设计一个每次使用系统首先要访问的API，该API会向移动端返回系统更新的相关信息，这样就可以提升用户更新App了。 版本升级问题：API版本升级时应该考虑对低版本的兼容，同时要让新版本和旧版本都能够被访问，可以在URL中包含版本信息或者在将版本号放在HTTP(S)协议头部，关于这个问题有很多的争论，有兴趣的可以看看stack overflow上面对这个问题的讨论。 图片尺寸问题：移动端对于一张图片可能需要不同的尺寸，可以在获取图片时传入尺寸参数并获取对应的资源；更好的做法是直接使用云存储或CDN（直接提供了图片缩放的功能），这样可以加速对资源的访问。  文档撰写 下面以设计评论接口为例，简单说明接口文档应该如何撰写。\n评论接口 全局返回状态码\n   返回码 返回信息 说明     10000 获取评论成功    10001 创建评论成功    10002 无法创建评论 创建评论时因违反审核机制而无法创建   10003 评论已被删除 查看评论时评论因不和谐因素已被删除   10004 …… ……     GET /articles/{article-id}/comments/  开发者：王大锤\n最后更新时间：2018年8月10日\n标签：v 1.0\n接口说明：获取指定文章的所有评论\n使用帮助：默认返回20条数据，需要在请求头中设置身份标识（key）\n请求参数：\n| 参数名 | 类型 | 是否必填 | 参数位置 | 说明 | | \u0026mdash;\u0026mdash; | \u0026mdash;\u0026mdash; | \u0026mdash;\u0026mdash;\u0026ndash; | \u0026mdash;\u0026mdash;\u0026ndash; | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; | | page | 整数 | 否 | 查询参数 | 页码，默认值1 | | size | 整数 | 否 | 查询参数 | 每次获取评论数量（10~100），默认值20 | | key | 字符串 | 是 | 请求头 | 用户的身份标识 |\n响应信息：\n{ \u0026#34;code\u0026#34;: 10000, \u0026#34;message\u0026#34;: \u0026#34;获取评论成功\u0026#34;, \u0026#34;page\u0026#34;: 1, \u0026#34;size\u0026#34;: 10, \u0026#34;totalPage\u0026#34;: 35, \u0026#34;contents\u0026#34;: [ { \u0026#34;userId\u0026#34;: 1700095, \u0026#34;nickname\u0026#34;: \u0026#34;王大锤\u0026#34;, \u0026#34;pubDate\u0026#34;: \u0026#34;2018年7月31日\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;小编是不是有病呀\u0026#34;, /* ... */ }, { \u0026#34;userId\u0026#34;, 1995322, \u0026#34;nickname\u0026#34;: \u0026#34;白元芳\u0026#34;, \u0026#34;pubDate\u0026#34;: \u0026#34;2018年8月2日\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;楼上说得好\u0026#34;, /* ... */ } ] /* ... */ }  POST /articles/{article-id}/comments  开发者：王大锤\n最后更新时间：2018年8月10日\n标签：v 1.0\n接口说明：为指定的文章创建评论\n使用帮助：暂无\n请求参数：\n| 参数名 | 类型 | 是否必填 | 参数位置 | 说明 | | \u0026mdash;\u0026mdash;- | \u0026mdash;\u0026mdash; | \u0026mdash;\u0026mdash;\u0026ndash; | \u0026mdash;\u0026mdash;\u0026ndash; | \u0026mdash;\u0026mdash;\u0026mdash;- | | userId | 字符串 | 是 | 消息体 | 用户ID | | key | 字符串 | 是 | 请求头 | 用户的令牌 | | content | 字符串 | 是 | 消息体 | 评论的内容 |\n响应信息：\n{ \u0026#34;code\u0026#34;: 10001, \u0026#34;message\u0026#34;: \u0026#34;创建评论成功\u0026#34;, \u0026#34;comment\u0026#34;: { \u0026#34;pubDate\u0026#34;: \u0026#34;2018年7月31日\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;小编是不是有病呀\u0026#34; /* ... */ } /* ... */ }"},{"idx":86,"href":"/python100days/docs/Day91-100/95-%E4%BD%BF%E7%94%A8Django%E5%BC%80%E5%8F%91%E5%95%86%E4%B8%9A%E9%A1%B9%E7%9B%AE/","title":"95 使用 Django开发商业项目","content":" 使用Django开发商业项目  说明：本文的部分插图来自于《Python项目开发实战》和《精通Django》，这两本书中都包含了对Django框架精彩的讲解，有兴趣的读者可以自行购买阅读。\n Web应用 问题1：描述一个Web应用的工作流程。\n问题2：描述项目的物理架构。（上图中补充负载均衡（反向代理）服务器、数据库服务器、文件服务器、邮件服务器、缓存服务器、防火墙等，而且每个节点都有可能是多节点构成的集群，如下图所示，架构并不是一开始就是这样，而是逐步演进的）\n问题3：描述Django项目的工作流程。（如下图所示）\nMVC架构模式 问题1：为什么要使用MVC架构模式？（模型和视图解耦合）\n问题2：MVC架构中每个部分的作用？（如下图所示）\nHTTP请求和响应 HTTP请求 = 请求行+请求头+空行+[消息体] HTTP响应 = 响应行+响应头+空行+消息体  HTTPRequest对象的属性和方法：\n method - 获取请求方法 path / get_full_path() - 获取请求路径/带查询字符串的路径 scheme / is_secure() / get_host() / get_port() - 获取请求的协议/主机/端口 META / COOKIES - 获取请求头/Cookie信息 GET / POST / FILES - 获取GET或POST请求参数/上传的文件 get_signed_cookie() - 获取带签名的Cookie is_ajax() - 是不是Ajax异步请求 body / content_type / encoding - 获取请求的消息体（bytes流）/MIME类型/编码  中间件添加的属性：\n session / user / site  HttpResponse对象的属性和方法：\n set_cookie() / set_signed_cookie() / delete_cookie() - 添加/删除Cookie __setitem__ / __getitem__ / __delitem__ - 添加/获取/删除响应头 charset / content / status_code - 响应的字符集/消息体（bytes流）/状态码  1xx：请求已经收到，继续处理 2xx（成功）：请求已经成功收到、理解和接收。 3xx（重定向）：为完成请求要继续执行后续的操作。 4xx（客户端错误）：请求不正确或不能够被受理。 5xx（服务器错误）：服务器处理请求失败。   JsonResponse（HttpResponse的子类型）对象\n\u0026gt;\u0026gt;\u0026gt; from django.http import HttpResponse, JsonResponse \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; response = JsonResponse({\u0026#39;foo\u0026#39;: \u0026#39;bar\u0026#39;}) \u0026gt;\u0026gt;\u0026gt; response.content \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; response = JsonResponse([1, 2, 3], safe=False) \u0026gt;\u0026gt;\u0026gt; response.content \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; response = HttpResponse(b\u0026#39;...\u0026#39;) \u0026gt;\u0026gt;\u0026gt; response[\u0026#39;cotent-type\u0026#39;] = \u0026#39;application/pdf\u0026#39;; \u0026gt;\u0026gt;\u0026gt; response[\u0026#39;content-disposition\u0026#39;] = \u0026#39;inline; filename=\u0026#34;xyz.pdf\u0026#34;\u0026#39; \u0026gt;\u0026gt;\u0026gt; response[\u0026#39;content-disposition\u0026#39;] = \u0026#39;attachment; filename=\u0026#34;xyz.pdf\u0026#34;\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; response.set_signed_cookie(\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;, salt=\u0026#39;\u0026#39;) \u0026gt;\u0026gt;\u0026gt; response.status_code = 200  数据模型(Model) 问题1：关系型数据库表的设计应该注意哪些问题（范式理论和逆范式）？如何通过表来创建模型类（反向工程）？如何通过模型类来创建表（正向工程）？\npython manage.py makemigrations \u0026lt;appname\u0026gt; python manage.py migrate python manage.py inspectdb \u0026gt; \u0026lt;appname\u0026gt;/models.py 问题2：关系型数据库中数据完整性指的是什么？什么时候需要牺牲数据完整性？（实体完整性/参照完整性/域完整性）\n问题3：ORM是什么以及解决了什么问题？（对象模型-关系模型双向转换）\n Field及其子类的属性：\n 通用选项：  db_column / db_tablespace null / blank / default primary_key db_index / unqiue choices / help_text / error_message / editable / hidden  其他选项：  CharField: max_length DateField: auto_now / auto_now_add DecimalField: max_digits / decimal_places FileField: storage / upload_to ImageField: height_field / width_field   ForeignKey的属性：\n 重要属性：\n db_constraint（提升性能或者数据分片的情况可能需要设置为False）\n on_delete\n CASCADE：级联删除。\n PROTECT：抛出ProtectedError异常，阻止删除引用的对象。\n SET_NULL：把外键设置为null，当null属性被设置为True时才能这么做。\n SET_DEFAULT：把外键设置为默认值，提供了默认值才能这么做。\n related_name\nclass Dept(models.Model): pass class Emp(models.Model): dept = models.ForeignKey(related_name=\u0026#39;+\u0026#39;, ...) Dept.objects.get(no=10).emp_set.all() Emp.objects.filter(dept__no=10)    说明：related_name设置为'+'，可以防止一对多外键关联从“一”的一方查询“多”的一方。\n  其他属性：\n to_field / limit_choices_to / swappable   Model的属性和方法\n objects / pk\n save() / delete()\n clean() / validate_unique() / full_clean()\n  QuerySet的方法\n get() / all() / values()   说明：values()返回的QuerySet中不是模型对象而是字典\n  count() / order_by() / exists() / reverse()\n filter() / exclude()\n exact / iexact：精确匹配/忽略大小写的精确匹配查询\n contains / icontains / startswith / istartswith / endswith / iendswith：基于like的模糊查询\n in：集合运算\n gt / gte / lt / lte：大于/大于等于/小于/小于等于关系运算\n range：指定范围查询（SQL中的between…and…）\n year / month / day / week_day / hour / minute / second：查询时间日期\n isnull：查询空值（True）或非空值（False）\n search：基于全文索引的全文检索\n regex / iregex：基于正则表达式的模糊匹配查询\n aggregate() / annotate()\n Avg / Count / Sum / Max / Min\n\u0026gt;\u0026gt;\u0026gt; from django.db.models import Avg \u0026gt;\u0026gt;\u0026gt; Emp.objects.aggregate(avg_sal=Avg(\u0026#39;sal\u0026#39;)) (0.001) SELECT AVG(`TbEmp`.`sal`) AS `avg_sal` FROM `TbEmp`; args=() {\u0026#39;avg_sal\u0026#39;: 3521.4286}\u0026gt;\u0026gt;\u0026gt; Emp.objects.values(\u0026#39;dept\u0026#39;).annotate(total=Count(\u0026#39;dept\u0026#39;)) (0.001) SELECT `TbEmp`.`dno`, COUNT(`TbEmp`.`dno`) AS `total` FROM `TbEmp` GROUP BY `TbEmp`.`dno` ORDER BY NULL LIMIT 21; args=() \u0026lt;QuerySet [{\u0026#39;dept\u0026#39;: 10, \u0026#39;total\u0026#39;: 4}, {\u0026#39;dept\u0026#39;: 20, \u0026#39;total\u0026#39;: 7}, {\u0026#39;dept\u0026#39;: 30, \u0026#39;total\u0026#39;: 3}]  first() / last()\n   说明：调用first()方法相当于用[0]对QuerySet进行切片。\n  only() / defer()\n\u0026gt;\u0026gt;\u0026gt; Emp.objects.filter(pk=7800).only(\u0026#39;name\u0026#39;, \u0026#39;sal\u0026#39;) (0.001) SELECT `TbEmp`.`empno`, `TbEmp`.`ename`, `TbEmp`.`sal` FROM `TbEmp` WHERE `TbEmp`.`empno` = 7800 LIMIT 21; args=(7800,) \u0026lt;QuerySet [\u0026lt;Emp: Emp object (7800)\u0026gt;]\u0026gt; \u0026gt;\u0026gt;\u0026gt; Emp.objects.filter(pk=7800).defer(\u0026#39;name\u0026#39;, \u0026#39;sal\u0026#39;) (0.001) SELECT `TbEmp`.`empno`, `TbEmp`.`job`, `TbEmp`.`mgr`, `TbEmp`.`comm`, `TbEmp`.`dno` FROM `TbEmp` WHERE `TbEmp`.`empno` = 7800 LIMIT 21; args=(7800,) \u0026lt;QuerySet [\u0026lt;Emp: Emp object (7800)\u0026gt;]\u0026gt; create() / update() / raw()\n\u0026gt;\u0026gt;\u0026gt; Emp.objects.filter(dept__no=20).update(sal=F(\u0026#39;sal\u0026#39;) + 100) (0.011) UPDATE `TbEmp` SET `sal` = (`TbEmp`.`sal` + 100) WHERE `TbEmp`.`dno` = 20; args=(100, 20) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; Emp.objects.raw(\u0026#39;select empno, ename, job from TbEmp where dno=10\u0026#39;) \u0026lt;RawQuerySet: select empno, ename, job from TbEmp where dno=10\u0026gt;  Q对象和F对象\n   说明：Q对象主要用来解决多条件组合的复杂查询；F对象主要用于更新数据。\n \u0026gt;\u0026gt;\u0026gt; from django.db.models import Q \u0026gt;\u0026gt;\u0026gt; Emp.objects.filter( ... Q(name__startswith=\u0026#39;张\u0026#39;), ... Q(sal__lte=5000) | Q(comm__gte=1000) ... ) # 查询名字以“张”开头且工资小于等于5000或补贴大于等于1000的员工 \u0026lt;QuerySet [\u0026lt;Emp: 张三丰\u0026gt;]\u0026gt;\u0026gt;\u0026gt;\u0026gt; from backend.models import Emp, Dept \u0026gt;\u0026gt;\u0026gt; emps = Emp.objects.filter(dept__no=20) \u0026gt;\u0026gt;\u0026gt; from django.db.models import F \u0026gt;\u0026gt;\u0026gt; emps.update(sal=F(\u0026#39;sal\u0026#39;) + 100)  原生SQL查询\nfrom django.db import connections with connections[\u0026#39;...\u0026#39;].cursor() as cursor: cursor.execute(\u0026#34;UPDATE TbEmp SET sal=sal+10 WHERE dno=30\u0026#34;) cursor.execute(\u0026#34;SELECT ename, job FROM TbEmp WHERE dno=10\u0026#34;) row = cursor.fetchall() 模型管理器\nclass BookManager(models.Manager): def title_count(self, keyword): return self.filter(title__icontains=keyword).count() class Book(models.Model): objects = BookManager()  视图函数(Controller) 如何设计视图函数  用户的每个操作（用户故事）对应一个视图函数。\n 每个视图函数可以构成一个事务边界。\n 事务的ACID特性。\n 原子性（Atomicity）：事务中各项的操作要么全做要么全不做； 一致性（Consistentcy）：事务前后系统的状态是一致的； 隔离性（Isolation）：并发执行的事务无法看到彼此的中间状态； 持久性（Duration）：事务完成后所做的改动都会被持久化。  事务隔离级别 - 设置事务隔离级别是为了数据库底层依据事务隔离级别为数据加上适当的锁。如果需要保证数据的强一致性，那么关系型数据库仍然是唯一的也是最好的选择，因为关系型数据库可以通过锁机制来保护数据。事务隔离级别从低到高依次是：Read Uncommitted（读未提交）、Read Committed（读提交）、Repeatable Read（可重复读）、Serializable（串行化）。事务隔离级别越高，数据并发访问的问题越少，但是性能越差；事务隔离级别越低，数据并发访问的问题越多，但是性能越好。\n 数据并发访问会产生5种问题（请参考我的《Java面试题全集（上）》第80题对该问题的讲解）：\n 第1类丢失更新（A事务撤销覆盖B事务更新的数据）和第2类丢失更新（A事务提交覆盖B事务更新的数据）。 脏读（读脏数据）：一个事务读取到其他尚未提交的事务的数据。 不可重复读： 一个事务在读取它的查询结果时，被另一个事务更新了它的查询记录导致无法读到数据。 幻读：一个事务在读取它的查询结果时，发现读到了被另一个事务提交的新数据。\n-- 设置全局默认的事务隔离级别 set global transaction isolation level repeatable read; -- 设置当前会话的事务隔离级别 set session transaction isolation level read committed; -- 查询当前会话的事务隔离级别 select @@tx_isolation;  Django中的事务控制。\n 给每个请求绑定事务环境（反模式）。\nATOMIC_REQUESTS = True 使用事务装饰器（简单易用） - 粗粒度（控制不够精细）。\n@transaction.non_atomic_requests @transaction.atomic 使用上下文语法（细粒度 - 事务控制的范围更加精准）。\nwith transaction.atomic(): pass 关闭自动提交使用手动提交。\nAUTOCOMMIT = Falsetransaction.commit() transaction.rollback()    URL配置  可以让部分URL只在调试模式下生效。\nfrom django.conf import settings urlpatterns = [ ... ] if settings.DEBUG: urlpatterns += [ ... ] 可以使用命名捕获组捕获路径参数。\nurl(r\u0026#39;api/code/(?P\u0026lt;mobile\u0026gt;1[3-9]\\d{9})\u0026#39;), path(\u0026#39;api/code/\u0026lt;str:mobile\u0026gt;\u0026#39;), URL配置不关心请求使用的方法（一个视图函数可以处理不同的请求方式）。\n 如果使用url函数捕获的路径参数都是字符串，path函数可以指定路径参数类型。\n 可以使用include函数引入其他URL配置，捕获的参数会向下传递。\n 在url和path函数甚至是include函数中都可以用字典向视图传入额外的参数，如果参数与捕获的参数同名，则使用字典中的参数。\n 可以用reverse函数实现URL的逆向解析（从名字解析出URL），在模板中也可以用{% url %}实现同样的操作。\npath(\u0026#39;\u0026#39;, views.index, name=\u0026#39;index\u0026#39;) return redirect(reverse(\u0026#39;index\u0026#39;)) return redirect(\u0026#39;index\u0026#39;)  模板(View) 后端渲染  模板的配置和渲染函数。\nTEMPLATES = [ { \u0026#39;BACKEND\u0026#39;: \u0026#39;django.template.backends.django.DjangoTemplates\u0026#39;, \u0026#39;DIRS\u0026#39;: [os.path.join(BASE_DIR, \u0026#39;templates\u0026#39;), ], \u0026#39;APP_DIRS\u0026#39;: True, \u0026#39;OPTIONS\u0026#39;: { \u0026#39;context_processors\u0026#39;: [ \u0026#39;django.template.context_processors.debug\u0026#39;, \u0026#39;django.template.context_processors.request\u0026#39;, \u0026#39;django.contrib.auth.context_processors.auth\u0026#39;, \u0026#39;django.contrib.messages.context_processors.messages\u0026#39;, ], }, }, ]resp = render(request, \u0026#39;index.html\u0026#39;, {\u0026#39;foo\u0026#39;: ...}) 模板遇到变量名的查找顺序。\n 字典查找（如：foo['bar']） 属性查找（如：foo.bar） 方法调用（如：foo.bar()）  方法不能有必须传值的参数 在模板中不能够给方法传参 如果方法的alters_data被设置为True则不能调用该方法（避免误操作的风险），模型对象动态生成的delete()和save()方法都设定了alters_data = True。  列表索引查找（如：foo[0]）  模板标签的使用。\n {% if %} / {% else %} / {% endif %} {% for %} / {% endfor %} {% ifequal %} / {% endifequal %} / {% ifnotequal %} / {% endifnotequal %} {# comment #} / {% comment %} / {% endcomment %}  过滤器的使用。\n lower / upper / first / last / truncatewords / date/ time / length / pluralize / center / ljust / rjust / cut / urlencode / default_if_none / filesizeformat / join / slice / slugify  模板的包含和继承。\n {% include %} / {% block %} {% extends %}  模板加载器（后面优化部分会讲到）。\n 文件系统加载器\nTEMPLATES = [{ \u0026#39;BACKEND\u0026#39;: \u0026#39;django.template.backends.django.DjangoTemplates\u0026#39;, \u0026#39;DIRS\u0026#39;: [os.path.join(BASE_DIR, \u0026#39;templates\u0026#39;)], }] 应用目录加载器\nTEMPLATES = [{ \u0026#39;BACKEND\u0026#39;: \u0026#39;django.template.backends.django.DjangoTemplates\u0026#39;, \u0026#39;APP_DIRS\u0026#39;: True, }]   前端渲染  前端模板引擎：Handlebars / Mustache。 前端MV*框架。  MVC - AngularJS MVVM(Model-View-ViewModel) - Vue.js   其他视图  MIME（多用途Internet邮件扩展）类型 - 告知浏览器传输的数据类型。  | Content-Type | 说明 | | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; | | application/json | JSON（JavaScript Object Notation） | | application/pdf | PDF（Portable Document Format） | | audio/mpeg | MP3或其他MPEG音频文件 | | audio/vnd.wave | WAV音频文件 | | image/gif | GIF图像文件 | | image/jpeg | JPEG图像文件 | | image/png | PNG图像文件 | | text/html | HTML文件 | | text/xml | XML | | video/mp4 | MP4视频文件 | | video/quicktime | QuickTime视频文件 |\n 如何处置生成的内容（inline / attachment）。\n\u0026gt;\u0026gt;\u0026gt; from urllib.parse import quote \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; response[\u0026#39;content-type\u0026#39;] = \u0026#39;application/pdf\u0026#39; \u0026gt;\u0026gt;\u0026gt; filename = quote(\u0026#39;Python语言规范.pdf\u0026#39;) \u0026gt;\u0026gt;\u0026gt; filename \u0026#39;Python%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83.pdf\u0026#39; \u0026gt;\u0026gt;\u0026gt; response[\u0026#39;content-disposition\u0026#39;] = f\u0026#39;attachment; filename=\u0026#34;{filename}\u0026#34;\u0026#39;   提醒：URL以及请求和响应头中的中文都应该处理成百分号编码。\n  生成CSV / Excel / PDF / 统计报表。\n 向浏览器传输二进制数据。\nbuffer = ByteIO() resp = HttpResponse(content_type=\u0026#39;...\u0026#39;) resp[\u0026#39;Content-Disposition\u0026#39;] = \u0026#39;attachment; filename=\u0026#34;...\u0026#34;\u0026#39; resp.write(buffer.getvalue())def get_style(name, color=0, bold=False, italic=False): style = xlwt.XFStyle() font = xlwt.Font() font.name = name font.colour_index = color font.bold = bold font.italic = italic style.font = font return style def export_emp_excel(request): # 创建Excel工作簿(使用三方库xlwt) workbook = xlwt.Workbook() # 向工作簿中添加工作表 sheet = workbook.add_sheet(\u0026#39;员工详细信息\u0026#39;) # 设置表头 titles = [\u0026#39;编号\u0026#39;, \u0026#39;姓名\u0026#39;, \u0026#39;主管\u0026#39;, \u0026#39;职位\u0026#39;, \u0026#39;工资\u0026#39;, \u0026#39;部门名称\u0026#39;] for col, title in enumerate(titles): sheet.write(0, col, title, get_style(\u0026#39;HanziPenSC-W3\u0026#39;, 2, True)) # 使用Django的ORM框架查询员工数据 emps = Emp.objects.all().select_related(\u0026#39;dept\u0026#39;).select_related(\u0026#39;mgr\u0026#39;) cols = [\u0026#39;no\u0026#39;, \u0026#39;name\u0026#39;, \u0026#39;mgr\u0026#39;, \u0026#39;job\u0026#39;, \u0026#39;sal\u0026#39;, \u0026#39;dept\u0026#39;] # 通过嵌套的循环将员工表的数据写入Excel工作表的单元格 for row, emp in enumerate(emps): for col, prop in enumerate(cols): val = getattr(emp, prop, \u0026#39;\u0026#39;) if isinstance(val, (Dept, Emp)): val = val.name sheet.write(row + 1, col, val) # 将Excel文件的二进制数据写入内存 buffer = BytesIO() workbook.save(buffer) # 通过HttpResponse对象向浏览器输出Excel文件 resp = HttpResponse(buffer.getvalue()) resp[\u0026#39;content-type\u0026#39;] = \u0026#39;application/msexcel\u0026#39; # 如果文件名有中文需要处理成百分号编码 resp[\u0026#39;content-disposition\u0026#39;] = \u0026#39;attachment; filename=\u0026#34;detail.xls\u0026#34;\u0026#39; return resp 大文件的流式处理：StreamingHttpResponse。\ndef download_file(request): file_stream = open(\u0026#39;...\u0026#39;, \u0026#39;rb\u0026#39;) # 如果文件的二进制数据较大则最好用迭代器进行处理避免过多的占用服务器内存 file_iter = iter(lambda: file_stream.read(4096), b\u0026#39;\u0026#39;) resp = StreamingHttpResponse(file_iter) # 中文文件名要处理成百分号编码 filename = quote(\u0026#39;...\u0026#39;, \u0026#39;utf-8\u0026#39;) resp[\u0026#39;Content-Type\u0026#39;] = \u0026#39;...\u0026#39; resp[\u0026#39;Content-Disposition\u0026#39;] = f\u0026#39;attachment; filename=\u0026#34;{filename}\u0026#34;\u0026#39; return resp   说明：如果需要生成PDF文件，可以需要安装reportlab。另外，使用StreamingHttpResponse只能减少内存的开销，但是如果下载一个大文件会导致一个请求长时间占用服务器资源，比较好的做法还是把报表提前生成好（可以考虑使用定时任务），放在静态资源服务器或者是云存储服务器上以访问静态资源的方式访问。\n  ECharts或Chart.js。\n 思路：后端只提供JSON格式的数据，前端JavaScript渲染生成图表。\ndef get_charts_data(request): \u0026#34;\u0026#34;\u0026#34;获取统计图表JSON数据\u0026#34;\u0026#34;\u0026#34; names = [] totals = [] # 通过connections获取指定数据库连接并创建游标对象 with connections[\u0026#39;backend\u0026#39;].cursor() as cursor: # 在使用ORM框架时可以使用对象管理器的aggregate()和annotate()方法实现分组和聚合函数查询 # 执行原生SQL查询(如果ORM框架不能满足业务或性能需求) cursor.execute(\u0026#39;select dname, total from vw_dept_emp\u0026#39;) for row in cursor.fetchall(): names.append(row[0]) totals.append(row[1]) return JsonResponse({\u0026#39;names\u0026#39;: names, \u0026#39;totals\u0026#39;: totals})\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;统计图表\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; #main { width: 600px; height: 400px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;main\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.bootcss.com/echarts/4.2.0-rc.2/echarts.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; var myChart = echarts.init($(\u0026#39;#main\u0026#39;)[0]); $.ajax({ \u0026#39;url\u0026#39;: \u0026#39;charts_data\u0026#39;, \u0026#39;type\u0026#39;: \u0026#39;get\u0026#39;, \u0026#39;data\u0026#39;: {}, \u0026#39;dataType\u0026#39;: \u0026#39;json\u0026#39;, \u0026#39;success\u0026#39;: function(json) { var option = { title: { text: \u0026#39;员工分布统计图\u0026#39; }, tooltip: {}, legend: { data:[\u0026#39;人数\u0026#39;] }, xAxis: { data: json.names }, yAxis: {}, series: [{ name: \u0026#39;人数\u0026#39;, type: \u0026#39;bar\u0026#39;, data: json.totals }] }; myChart.setOption(option); }, \u0026#39;error\u0026#39;: function() {} }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;    中间件 问题1：中间件背后的设计理念是什么？（分离横切关注功能/拦截过滤器模式）\n问题2：中间件有哪些不同的实现方式？（参考下面的代码）\n问题3：描述Django内置的中间件及其执行顺序。（推荐阅读：Django官方文档 - 中间件 - 中间件顺序）\n激活中间件 MIDDLEWARE = [ \u0026#39;django.middleware.security.SecurityMiddleware\u0026#39;, \u0026#39;django.contrib.sessions.middleware.SessionMiddleware\u0026#39;, \u0026#39;django.middleware.common.CommonMiddleware\u0026#39;, \u0026#39;django.middleware.csrf.CsrfViewMiddleware\u0026#39;, \u0026#39;django.contrib.auth.middleware.AuthenticationMiddleware\u0026#39;, \u0026#39;django.contrib.messages.middleware.MessageMiddleware\u0026#39;, \u0026#39;django.middleware.clickjacking.XFrameOptionsMiddleware\u0026#39;, \u0026#39;common.middlewares.block_sms_middleware\u0026#39;, ] 自定义中间件 def simple_middleware(get_response): def middleware(request, *args, **kwargs): response = get_response(request, *args, **kwargs) return response return middlewareclass MyMiddleware(object): def __init__(self, get_response): self.get_response = get_response def __call__(self, request): response = self.get_response(request) return responseclass MyMiddleware(object): def __init__(self): pass def process_request(request): pass def process_view(request, view_func, view_args, view_kwargs): pass def process_template_response(request, response): pass def process_response(request, response): pass def process_exception(request, exception): pass 内置中间件  CommonMiddleware - 基础设置中间件\n DISALLOWED_USER_AGENTS - 不被允许的用户代理（浏览器） APPEND_SLASH - 是否追加/ USE_ETAG - 浏览器缓存相关  SecurityMiddleware - 安全相关中间件\n SECURE_HSTS_SECONDS - 强制使用HTTPS的时间 SECURE_HSTS_INCLUDE_SUBDOMAINS - HTTPS是否覆盖子域名 SECURE_CONTENT_TYPE_NOSNIFF - 是否允许浏览器推断内容类型 SECURE_BROWSER_XSS_FILTER - 是否启用跨站脚本攻击过滤器 SECURE_SSL_REDIRECT - 是否重定向到HTTPS连接 SECURE_REDIRECT_EXEMPT - 免除重定向到HTTPS  SessionMiddleware - 会话中间件\n CsrfViewMiddleware - 防范跨站身份伪造中间件\n XFrameOptionsMiddleware - 防范点击劫持攻击中间件\n  表单  用法：通常不要用来生成页面上的表单控件（耦合度太高不容易定制），主要用来验证数据。 Form的属性和方法：  is_valid() / is_multipart() errors / fields / is_bound / changed_data / cleaned_data add_error() / has_errors() / non_field_errors() clean()  Form.errors的方法：  as_data() / as_json() / get_json_data()   问题1：Django中的Form和ModelForm有什么作用？（通常不用来生成表单主要用来验证数据）\n问题2：表单上传文件时应该注意哪些问题？（表单的设置、多文件上传、图片预览（FileReader）、Ajax上传文件、上传后的文件如何存储、调用云存储（如阿里云OSS、七牛云、LeanCloud等））\n\u0026lt;form action=\u0026#34;\u0026#34; method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;...\u0026#34; multiple\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;foo\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;foo\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;foo\u0026#34;\u0026gt; \u0026lt;/form\u0026gt;  说明：上传图片文件的预览效果可以通过HTML5的FileReader来实现。\n说明：使用云存储通常是比自己配置分布式文件系统这种方式更靠谱的做法，而且云存储通常成本并不太高，不仅如此大多数云存储还提供了如图片剪裁、生成水印、视频转码、CDN等服务。如果要自己做上传的视频文件转码，需要安装三方库ffmpeg，在程序中调用该三方库可以实现转码。\n Cookie和Session 问题1：使用Cookie能解决什么问题？（用户跟踪，解决HTTP协议无状态问题）\n URL重写\nhttp://www.abc.com/path/resource?foo=bar  隐藏域（隐式表单域）- 埋点\n\u0026lt;form action=\u0026#34;\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;foo\u0026#34; value=\u0026#34;bar\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; Cookie - 浏览器中的临时文件（文本文件）- BASE64\n  问题2：Cookie和Session之间关系是什么？（Session的标识通过Cookie保存和传输）\nSession的配置  Session对应的中间件：django.contrib.sessions.middleware.SessionMiddleware。\n Session引擎。\n 基于数据库（默认方式）\nINSTALLED_APPS = [ \u0026#39;django.contrib.sessions\u0026#39;, ] 基于缓存（推荐使用）\nSESSION_ENGINE = \u0026#39;django.contrib.sessions.backends.cache\u0026#39; SESSION_CACHE_ALIAS = \u0026#39;session\u0026#39; 基于文件（基本不考虑）\n 基于Cookie（不靠谱）\nSESSION_ENGINE = \u0026#39;django.contrib.sessions.backends.signed_cookies\u0026#39;  Cookie相关的配置。\nSESSION_COOKIE_NAME = \u0026#39;djang_session_id\u0026#39; SESSION_COOKIE_AGE = 1209600 # 如果设置为True，Cookie就是基于浏览器窗口的Cookie，不会持久化 SESSION_EXPIRE_AT_BROWSER_CLOSE = False SESSION_SAVE_EVERY_REQUEST = False SESSION_COOKIE_HTTPONLY = True session的属性和方法。\n session_key / session_data / expire_date __getitem__ / __setitem__ / __delitem__ / __contains__ set_expiry() / get_expiry_age() / get_expiry_date() - 设置/获取会话超期时间 flush() - 销毁会话 set_test_cookie() / test_cookie_worked() / delete_test_cookie() - 测试浏览器是否支持Cookie（提示用户如果浏览器禁用Cookie可能会影响网站的使用）  session的序列化。\nSESSION_SERIALIZER = \u0026#39;django.contrib.sessions.serializers.JSONSerializer\u0026#39;  JSONSerializer（1.6及以后默认）- 如果想将自定义的对象放到session中，会遇到“Object of type \u0026lsquo;XXX\u0026rsquo; is not JSON serializable”的问题（如果配置使用Redis保存Session，django-redis使用了Pickle序列化，这个问题就不存在了）。 PickleSerializer（1.6以前的默认）- 因为安全问题不推荐使用，但是只要不去反序列化用户构造的恶意的Payload其实也没有什么风险。关于这种方式的安全漏洞，可以参考《Python Pickle的任意代码执行漏洞实践和Payload构造》一文或《软件架构-Python语言实现》上关于这个问题的讲解。   说明：如果使用了django_redis整合Redis作为session的存储引擎，那么由于django_redis又封装了一个PickleSerializer来提供序列化，所以不会存在上述的问题，且Redis中保存的value是pickle序列化之后的结果。\n  缓存 配置缓存 CACHES = { # 默认缓存 \u0026#39;default\u0026#39;: { \u0026#39;BACKEND\u0026#39;: \u0026#39;django_redis.cache.RedisCache\u0026#39;, \u0026#39;LOCATION\u0026#39;: [ \u0026#39;redis://1.2.3.4:6379/0\u0026#39;, ], \u0026#39;KEY_PREFIX\u0026#39;: \u0026#39;teamproject\u0026#39;, \u0026#39;OPTIONS\u0026#39;: { \u0026#39;CLIENT_CLASS\u0026#39;: \u0026#39;django_redis.client.DefaultClient\u0026#39;, \u0026#39;CONNECTION_POOL_KWARGS\u0026#39;: { \u0026#39;max_connections\u0026#39;: 1000, }, \u0026#39;PASSWORD\u0026#39;: \u0026#39;1qaz2wsx\u0026#39;, } }, # 页面缓存 \u0026#39;page\u0026#39;: { \u0026#39;BACKEND\u0026#39;: \u0026#39;django_redis.cache.RedisCache\u0026#39;, \u0026#39;LOCATION\u0026#39;: [ \u0026#39;redis://1.2.3.4:6379/1\u0026#39;, ], \u0026#39;KEY_PREFIX\u0026#39;: \u0026#39;teamproject:page\u0026#39;, \u0026#39;OPTIONS\u0026#39;: { \u0026#39;CLIENT_CLASS\u0026#39;: \u0026#39;django_redis.client.DefaultClient\u0026#39;, \u0026#39;CONNECTION_POOL_KWARGS\u0026#39;: { \u0026#39;max_connections\u0026#39;: 500, }, \u0026#39;PASSWORD\u0026#39;: \u0026#39;1qaz2wsx\u0026#39;, } }, # 会话缓存 \u0026#39;session\u0026#39;: { \u0026#39;BACKEND\u0026#39;: \u0026#39;django_redis.cache.RedisCache\u0026#39;, \u0026#39;LOCATION\u0026#39;: [ \u0026#39;redis://1.2.3.4:6379/2\u0026#39;, ], \u0026#39;KEY_PREFIX\u0026#39;: \u0026#39;teamproject:session\u0026#39;, \u0026#39;TIMEOUT\u0026#39;: 1209600, \u0026#39;OPTIONS\u0026#39;: { \u0026#39;CLIENT_CLASS\u0026#39;: \u0026#39;django_redis.client.DefaultClient\u0026#39;, \u0026#39;CONNECTION_POOL_KWARGS\u0026#39;: { \u0026#39;max_connections\u0026#39;: 2000, }, \u0026#39;PASSWORD\u0026#39;: \u0026#39;1qaz2wsx\u0026#39;, } }, # 接口数据缓存 \u0026#39;api\u0026#39;: { \u0026#39;BACKEND\u0026#39;: \u0026#39;django_redis.cache.RedisCache\u0026#39;, \u0026#39;LOCATION\u0026#39;: [ \u0026#39;redis://1.2.3.4:6379/3\u0026#39;, ], \u0026#39;KEY_PREFIX\u0026#39;: \u0026#39;teamproject:api\u0026#39;, \u0026#39;OPTIONS\u0026#39;: { \u0026#39;CLIENT_CLASS\u0026#39;: \u0026#39;django_redis.client.DefaultClient\u0026#39;, \u0026#39;CONNECTION_POOL_KWARGS\u0026#39;: { \u0026#39;max_connections\u0026#39;: 500, }, \u0026#39;PASSWORD\u0026#39;: \u0026#39;1qaz2wsx\u0026#39;, } }, }  说明：通过Redis底层提供的多个数据库来隔离缓存数据有助于缓存数据的管理。如果配置了Redis的主从复制（读写分离），LOCATION列表中可以配置多个Redis连接，第一个被视为master用来进行写操作，后面的被视为slave用来进行读操作。\n 全站缓存 MIDDLEWARE_CLASSES = [ \u0026#39;django.middleware.cache.UpdateCacheMiddleware\u0026#39;, ... \u0026#39;django.middleware.common.CommonMiddleware\u0026#39;, ... \u0026#39;django.middleware.cache.FetchFromCacheMiddleware\u0026#39;, ] CACHE_MIDDLEWARE_ALIAS = \u0026#39;default\u0026#39; CACHE_MIDDLEWARE_SECONDS = 300 CACHE_MIDDLEWARE_KEY_PREFIX = \u0026#39;djang:cache\u0026#39; 视图层缓存 from django.views.decorators.cache import cache_page from django.views.decorators.vary import vary_on_cookie @cache_page(timeout=60 * 15, cache=\u0026#39;page\u0026#39;) @vary_on_cookie def my_view(request): passfrom django.views.decorators.cache import cache_page urlpatterns = [ url(r\u0026#39;^foo/([0-9]{1,2})/$\u0026#39;, cache_page(60 * 15)(my_view)), ] 其他内容  模板片段缓存。\n {% load cache %} {% cache %} / {% endcache %}  使用底层API访问缓存。\n\u0026gt;\u0026gt;\u0026gt; from django.core.cache import cache \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; cache.set(\u0026#39;my_key\u0026#39;, \u0026#39;hello, world!\u0026#39;, 30) \u0026gt;\u0026gt;\u0026gt; cache.get(\u0026#39;my_key\u0026#39;) \u0026gt;\u0026gt;\u0026gt; cache.clear()\u0026gt;\u0026gt;\u0026gt; from django.core.cache import caches \u0026gt;\u0026gt;\u0026gt; cache1 = caches[\u0026#39;page\u0026#39;] \u0026gt;\u0026gt;\u0026gt; cache2 = caches[\u0026#39;page\u0026#39;] \u0026gt;\u0026gt;\u0026gt; cache1 is cache2 True \u0026gt;\u0026gt;\u0026gt; cache3 = caches[\u0026#39;session\u0026#39;] \u0026gt;\u0026gt;\u0026gt; cache2 is cache3 False\u0026gt;\u0026gt;\u0026gt; from django_redis import get_redis_connection \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; redis_client = get_redis_connection() \u0026gt;\u0026gt;\u0026gt; redis_client.hgetall()  日志 日志级别 NOTSET \u0026lt; DEBUG \u0026lt; INFO \u0026lt; WARNING \u0026lt; ERROR \u0026lt; FATAL\n日志配置 LOGGING = { \u0026#39;version\u0026#39;: 1, \u0026#39;disable_existing_loggers\u0026#39;: False, # 配置日志格式化器 \u0026#39;formatters\u0026#39;: { \u0026#39;simple\u0026#39;: { \u0026#39;format\u0026#39;: \u0026#39;%(asctime)s%(module)s.%(funcName)s: %(message)s\u0026#39;, \u0026#39;datefmt\u0026#39;: \u0026#39;%Y-%m-%d%H:%M:%S\u0026#39;, }, \u0026#39;verbose\u0026#39;: { \u0026#39;format\u0026#39;: \u0026#39;%(asctime)s%(levelname)s[%(process)d-%(threadName)s] \u0026#39; \u0026#39;%(module)s.%(funcName)sline %(lineno)d: %(message)s\u0026#39;, \u0026#39;datefmt\u0026#39;: \u0026#39;%Y-%m-%d%H:%M:%S\u0026#39;, } }, # 配置日志过滤器 \u0026#39;filters\u0026#39;: { \u0026#39;require_debug_true\u0026#39;: { \u0026#39;()\u0026#39;: \u0026#39;django.utils.log.RequireDebugTrue\u0026#39;, }, }, # 配置日志处理器 \u0026#39;handlers\u0026#39;: { \u0026#39;console\u0026#39;: { \u0026#39;class\u0026#39;: \u0026#39;logging.StreamHandler\u0026#39;, \u0026#39;level\u0026#39;: \u0026#39;DEBUG\u0026#39;, \u0026#39;filters\u0026#39;: [\u0026#39;require_debug_true\u0026#39;], \u0026#39;formatter\u0026#39;: \u0026#39;simple\u0026#39;, }, \u0026#39;file1\u0026#39;: { \u0026#39;class\u0026#39;: \u0026#39;logging.handlers.TimedRotatingFileHandler\u0026#39;, \u0026#39;filename\u0026#39;: \u0026#39;access.log\u0026#39;, \u0026#39;when\u0026#39;: \u0026#39;W0\u0026#39;, \u0026#39;backupCount\u0026#39;: 12, \u0026#39;formatter\u0026#39;: \u0026#39;simple\u0026#39;, \u0026#39;level\u0026#39;: \u0026#39;INFO\u0026#39;, }, \u0026#39;file2\u0026#39;: { \u0026#39;class\u0026#39;: \u0026#39;logging.handlers.TimedRotatingFileHandler\u0026#39;, \u0026#39;filename\u0026#39;: \u0026#39;error.log\u0026#39;, \u0026#39;when\u0026#39;: \u0026#39;D\u0026#39;, \u0026#39;backupCount\u0026#39;: 31, \u0026#39;formatter\u0026#39;: \u0026#39;verbose\u0026#39;, \u0026#39;level\u0026#39;: \u0026#39;WARNING\u0026#39;, }, }, # 配置日志器 \u0026#39;loggers\u0026#39;: { \u0026#39;django\u0026#39;: { \u0026#39;handlers\u0026#39;: [\u0026#39;console\u0026#39;, \u0026#39;file1\u0026#39;, \u0026#39;file2\u0026#39;], \u0026#39;propagate\u0026#39;: True, \u0026#39;level\u0026#39;: \u0026#39;DEBUG\u0026#39;, }, } } 日志配置官方示例。\n日志分析  Linux相关命令：head、tail、grep、awk、uniq、sort\ntail -10000 access.log | awk \u0026#39;{print $1}\u0026#39; | uniq -c | sort -r 实时日志文件分析：Python + 正则表达式 + Crontab\n 《Python日志分析工具》。\n 《集中式日志系统ELK》。\n ElasticSearch：搜索引擎，实现全文检索。 Logstash：负责从指定节点收集日志。 Kibana：日志可视化工具。  大数据日志处理：Flume+Kafka日志采集、Storm / Spark实时数据处理、Impala实时查询。\n  RESTful 问题1：RESTful架构到底解决了什么问题？（URL具有自描述性、资源表述与视图的解耦和、互操作性利用构建微服务以及集成第三方系统、无状态性提高水平扩展能力）\n问题2：项目在使用RESTful架构时有没有遇到一些问题或隐患？（对资源访问的限制、资源从属关系检查、避免泄露业务信息、防范可能的攻击）\n 补充：下面的几个和安全性相关的响应头在前面讲中间件的时候提到过的。\n X-Frame-Options: DENY X-Content-Type-Options: nosniff X-XSS-Protection: 1; mode=block; Strict­-Transport-­Security: max-age=31536000;   问题3：如何保护API中的敏感信息以及防范重放攻击？（摘要和令牌）\n推荐阅读：《如何有效防止API的重放攻击》。\n使用djangorestframework 安装djangorestfrmework（为了描述方便，以下统一简称为drf）。\npip install djangorestframework 配置drf。\nINSTALLED_APPS = [ \u0026#39;rest_framework\u0026#39;, ] REST_FRAMEWORK = { # 配置默认页面大小 \u0026#39;PAGE_SIZE\u0026#39;: 10, # 配置默认的分页类 \u0026#39;DEFAULT_PAGINATION_CLASS\u0026#39;: \u0026#39;rest_framework.pagination.PageNumberPagination\u0026#39;, # 配置异常处理器 # \u0026#39;EXCEPTION_HANDLER\u0026#39;: \u0026#39;api.exceptions.exception_handler\u0026#39;, # 配置默认解析器 # \u0026#39;DEFAULT_PARSER_CLASSES\u0026#39;: ( # \u0026#39;rest_framework.parsers.JSONParser\u0026#39;, # \u0026#39;rest_framework.parsers.FormParser\u0026#39;, # \u0026#39;rest_framework.parsers.MultiPartParser\u0026#39;, # ), # 配置默认限流类 # \u0026#39;DEFAULT_THROTTLE_CLASSES\u0026#39;: (), # 配置默认授权类 # \u0026#39;DEFAULT_PERMISSION_CLASSES\u0026#39;: ( # \u0026#39;rest_framework.permissions.IsAuthenticated\u0026#39;, # ), # 配置默认认证类 # \u0026#39;DEFAULT_AUTHENTICATION_CLASSES\u0026#39;: ( # \u0026#39;rest_framework_jwt.authentication.JSONWebTokenAuthentication\u0026#39;, # ), } 编写序列化器 from rest_framework import serializers from rest_framework.serializers import ModelSerializer from common.models import District, HouseType, Estate, Agent class DistrictSerializer(ModelSerializer): class Meta: model = District fields = (\u0026#39;distid\u0026#39;, \u0026#39;name\u0026#39;) class HouseTypeSerializer(ModelSerializer): class Meta: model = HouseType fields = \u0026#39;__all__\u0026#39; class AgentSerializer(ModelSerializer): class Meta: model = Agent fields = (\u0026#39;agentid\u0026#39;, \u0026#39;name\u0026#39;, \u0026#39;tel\u0026#39;, \u0026#39;servstar\u0026#39;, \u0026#39;certificated\u0026#39;) class EstateSerializer(ModelSerializer): district = serializers.SerializerMethodField() agents = serializers.SerializerMethodField() @staticmethod def get_agents(estate): return AgentSerializer(estate.agents, many=True).data @staticmethod def get_district(estate): return DistrictSerializer(estate.district).data class Meta: model = Estate fields = \u0026#39;__all__\u0026#39; 方法1：使用装饰器 @api_view([\u0026#39;GET\u0026#39;]) @cache_page(timeout=None, cache=\u0026#39;api\u0026#39;) def provinces(request): queryset = District.objects.filter(parent__isnull=True) serializer = DistrictSerializer(queryset, many=True) return Response(serializer.data) @api_view([\u0026#39;GET\u0026#39;]) @cache_page(timeout=300, cache=\u0026#39;api\u0026#39;) def cities(request, provid): queryset = District.objects.filter(parent__distid=provid) serializer = DistrictSerializer(queryset, many=True) return Response(serializer.data)urlpatterns = [ path(\u0026#39;districts/\u0026#39;, views.provinces, name=\u0026#39;districts\u0026#39;), path(\u0026#39;districts/\u0026lt;int:provid\u0026gt;/\u0026#39;, views.cities, name=\u0026#39;cities\u0026#39;), ]  说明：上面使用了Django自带的视图装饰器（@cache_page）来实现对API接口返回数据的缓存。\n 方法2：使用APIView及其子类 更好的复用代码，不要重“复发明轮子”。\nclass HouseTypeApiView(CacheResponseMixin, ListAPIView): queryset = HouseType.objects.all() serializer_class = HouseTypeSerializerurlpatterns = [ path(\u0026#39;housetypes/\u0026#39;, views.HouseTypeApiView.as_view(), name=\u0026#39;housetypes\u0026#39;), ]  说明：上面使用了drf_extensions提供的CacheResponseMixin混入类实现了对接口数据的缓存。如果重写了获取数据的方法，可以使用drf_extensions提供的@cache_response来实现对接口数据的缓存，也可以用自定义的函数来生成缓存中的key。当然还有一个选择就是通过Django提供的@method_decorator装饰器，将@cache_page装饰器处理为装饰方法的装饰器，这样也能提供使用缓存服务。\n drf-extensions配置如下所示。\n# 配置DRF扩展来支持缓存API接口调用结果 REST_FRAMEWORK_EXTENSIONS = { \u0026#39;DEFAULT_CACHE_RESPONSE_TIMEOUT\u0026#39;: 300, \u0026#39;DEFAULT_USE_CACHE\u0026#39;: \u0026#39;default\u0026#39;, # 配置默认缓存单个对象的key函数 \u0026#39;DEFAULT_OBJECT_CACHE_KEY_FUNC\u0026#39;: \u0026#39;rest_framework_extensions.utils.default_object_cache_key_func\u0026#39;, # 配置默认缓存对象列表的key函数 \u0026#39;DEFAULT_LIST_CACHE_KEY_FUNC\u0026#39;: \u0026#39;rest_framework_extensions.utils.default_list_cache_key_func\u0026#39;, } 方法3：使用ViewSet及其子类 class HouseTypeViewSet(CacheResponseMixin, viewsets.ModelViewSet): queryset = HouseType.objects.all() serializer_class = HouseTypeSerializer pagination_class = Nonerouter = DefaultRouter() router.register(\u0026#39;housetypes\u0026#39;, views.HouseTypeViewSet) urlpatterns += router.urls djangorestframework提供了基于Bootstrap定制的页面来显示接口返回的JSON数据，当然也可以使用POSTMAN这样的工具对API接口进行测试。\n补充说明 在这里顺便提一下跟前端相关的几个问题。\n问题1：如何让浏览器能够发起DELETE/PUT/PATCH？\n\u0026lt;form method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;_method\u0026#34; value=\u0026#34;delete\u0026#34;\u0026gt; \u0026lt;/form\u0026gt;if request.method == \u0026#39;POST\u0026#39; and \u0026#39;_method\u0026#39; in request.POST: request.method = request.POST[\u0026#39;_method\u0026#39;].upper()\u0026lt;script\u0026gt; $.ajax({ \u0026#39;url\u0026#39;: \u0026#39;/api/provinces\u0026#39;, \u0026#39;type\u0026#39;: \u0026#39;put\u0026#39;, \u0026#39;data\u0026#39;: {}, \u0026#39;dataType\u0026#39;: \u0026#39;json\u0026#39;, \u0026#39;success\u0026#39;: function(json) { // Web = 标签(内容) + CSS(显示) + JS(行为)  // JavaScript = ES + BOM + DOM  // DOM操作实现页面的局部刷新  }, \u0026#39;error\u0026#39;: function() {} }); $.getJSON(\u0026#39;/api/provinces\u0026#39;, function(json) { // DOM操作实现页面的局部刷新  }); \u0026lt;/script\u0026gt; 问题2：如何解决多个JavaScript库之间某个定义（如$函数）冲突的问题？\n\u0026lt;script src=\u0026#34;js/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;js/abc.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // $已经被后加载的JavaScript库占用了  // 但是可以直接用绑定在window对象上的jQuery去代替$  jQuery(function() { jQuery(\u0026#39;#okBtn\u0026#39;).on(\u0026#39;click\u0026#39;, function() {}); }); \u0026lt;/script\u0026gt;\u0026lt;script src=\u0026#34;js/abc.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;js/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // 将$让出给其他的JavaScript库使用 \tjQuery.noConflict(); jQuery(function() { jQuery(\u0026#39;#okBtn\u0026#39;).on(\u0026#39;click\u0026#39;, function() {}); }); \u0026lt;/script\u0026gt; 问题3：jQuery对象与原生DOM对象之间如何转换？\n\u0026lt;button id=\u0026#34;okBtn\u0026#34;\u0026gt;点我\u0026lt;/button\u0026gt; \u0026lt;script src=\u0026#34;js/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; var btn = document.getElementById(\u0026#39;okBtn\u0026#39;);\t// 原生JavaScript对象(使用相对麻烦)  var $btn = $(\u0026#39;#okBtn\u0026#39;);\t// jQuery对象(拥有更多的属性和方法而且没有浏览器兼容性问题)  $btn.on(\u0026#39;click\u0026#39;, function() {}); // $(btn)可以将原生JavaScript对象转成jQuery对象  // $btn.get(0)或$btn[0]可以获得原生的JavaScript对象 \u0026lt;/script\u0026gt; 过滤数据 如果需要过滤数据（对数据接口设置筛选条件、排序条件等），可以使用django-filter三方库来实现。\npip install django-filterINSTALLED_APPS = [ \u0026#39;django_filters\u0026#39;, ] REST_FRAMEWORK = { \u0026#39;DEFAULT_FILTER_BACKENDS\u0026#39;: ( \u0026#39;django_filters.rest_framework.DjangoFilterBackend\u0026#39;, \u0026#39;rest_framework.filters.OrderingFilter\u0026#39;, ), }from django.utils.decorators import method_decorator from django.views.decorators.cache import cache_page from django_filters.rest_framework import DjangoFilterBackend from rest_framework.filters import OrderingFilter from rest_framework.generics import RetrieveAPIView, ListCreateAPIView from api.serializers import EstateSerializer from common.models import Estate @method_decorator(decorator=cache_page(timeout=120, cache=\u0026#39;api\u0026#39;, key_prefix=\u0026#39;estates\u0026#39;), name=\u0026#39;get\u0026#39;) class EstateView(RetrieveAPIView, ListCreateAPIView): queryset = Estate.objects.all().select_related(\u0026#39;district\u0026#39;).prefetch_related(\u0026#39;agents\u0026#39;) serializer_class = EstateSerializer filter_backends = (DjangoFilterBackend, OrderingFilter) filter_fields = (\u0026#39;name\u0026#39;, \u0026#39;district\u0026#39;) ordering = (\u0026#39;-hot\u0026#39;, ) ordering_fields = (\u0026#39;hot\u0026#39;, \u0026#39;estateid\u0026#39;)from django_filters import rest_framework as drf from common.models import HouseInfo class HouseInfoFilter(drf.FilterSet): \u0026#34;\u0026#34;\u0026#34;自定义房源数据过滤器\u0026#34;\u0026#34;\u0026#34; title = drf.CharFilter(lookup_expr=\u0026#39;starts\u0026#39;) dist = drf.NumberFilter(field_name=\u0026#39;district\u0026#39;) min_price = drf.NumberFilter(field_name=\u0026#39;price\u0026#39;, lookup_expr=\u0026#39;gte\u0026#39;) max_price = drf.NumberFilter(field_name=\u0026#39;price\u0026#39;, lookup_expr=\u0026#39;lte\u0026#39;) type = drf.NumberFilter() class Meta: model = HouseInfo fields = (\u0026#39;title\u0026#39;, \u0026#39;district\u0026#39;, \u0026#39;min_price\u0026#39;, \u0026#39;max_price\u0026#39;, \u0026#39;type\u0026#39;)class HouseInfoViewSet(CacheResponseMixin, ReadOnlyModelViewSet): queryset = HouseInfo.objects.all() \\ .select_related(\u0026#39;type\u0026#39;, \u0026#39;district\u0026#39;, \u0026#39;estate\u0026#39;, \u0026#39;agent\u0026#39;) \\ .prefetch_related(\u0026#39;tags\u0026#39;).order_by(\u0026#39;-pubdate\u0026#39;) serializer_class = HouseInfoSerializer filter_backends = (DjangoFilterBackend, OrderingFilter) filterset_class = HouseInfoFilter ordering = (\u0026#39;price\u0026#39;,) ordering_fields = (\u0026#39;price\u0026#39;, \u0026#39;area\u0026#39;) 身份认证 查看drf中APIView类的代码可以看出，drf默认的认证方案是 DEFAULT_AUTHENTICATION_CLASSES，如果修改authentication_classes就可以自行定制身份认证的方案。\nclass APIView(View): # The following policies may be set at either globally, or per-view. renderer_classes = api_settings.DEFAULT_RENDERER_CLASSES parser_classes = api_settings.DEFAULT_PARSER_CLASSES authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES throttle_classes = api_settings.DEFAULT_THROTTLE_CLASSES permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES content_negotiation_class = api_settings.DEFAULT_CONTENT_NEGOTIATION_CLASS metadata_class = api_settings.DEFAULT_METADATA_CLASS versioning_class = api_settings.DEFAULT_VERSIONING_CLASS # 此处省略下面的代码DEFAULTS = { # Base API policies \u0026#39;DEFAULT_RENDERER_CLASSES\u0026#39;: ( \u0026#39;rest_framework.renderers.JSONRenderer\u0026#39;, \u0026#39;rest_framework.renderers.BrowsableAPIRenderer\u0026#39;, ), \u0026#39;DEFAULT_PARSER_CLASSES\u0026#39;: ( \u0026#39;rest_framework.parsers.JSONParser\u0026#39;, \u0026#39;rest_framework.parsers.FormParser\u0026#39;, \u0026#39;rest_framework.parsers.MultiPartParser\u0026#39; ), \u0026#39;DEFAULT_AUTHENTICATION_CLASSES\u0026#39;: ( \u0026#39;rest_framework.authentication.SessionAuthentication\u0026#39;, \u0026#39;rest_framework.authentication.BasicAuthentication\u0026#39; ), \u0026#39;DEFAULT_PERMISSION_CLASSES\u0026#39;: ( \u0026#39;rest_framework.permissions.AllowAny\u0026#39;, ), \u0026#39;DEFAULT_THROTTLE_CLASSES\u0026#39;: (), \u0026#39;DEFAULT_CONTENT_NEGOTIATION_CLASS\u0026#39;: \u0026#39;rest_framework.negotiation.DefaultContentNegotiation\u0026#39;, \u0026#39;DEFAULT_METADATA_CLASS\u0026#39;: \u0026#39;rest_framework.metadata.SimpleMetadata\u0026#39;, \u0026#39;DEFAULT_VERSIONING_CLASS\u0026#39;: None, # 此处省略下面的代码 } 自定义认证类，继承BaseAuthentication并重写authenticate(self, request)方法，通过请求中的userid和token来确定用户身份。如果认证成功，该方法应返回一个二元组（用户和令牌的信息），否则产生异常。也可以重写 authenticate_header(self, request)方法来返回一个字符串，该字符串将用于HTTP 401 Unauthorized响应中的WWW-Authenticate响应头的值。如果未重写该方法，那么当未经身份验证的请求被拒绝访问时，身份验证方案将返回HTTP 403 Forbidden响应。\nclass MyAuthentication(BaseAuthentication): \u0026#34;\u0026#34;\u0026#34;自定义用户身份认证类\u0026#34;\u0026#34;\u0026#34; def authenticate(self, request): try: token = request.GET[\u0026#39;token\u0026#39;] or request.POST[\u0026#39;token\u0026#39;] user_token = UserToken.objects.filter(token=token).first() if user_token: return user_token.user, user_token else: raise AuthenticationFailed(\u0026#39;请提供有效的用户身份标识\u0026#39;) except KeyError: raise AuthenticationFailed(\u0026#39;请提供有效的用户身份标识\u0026#39;) def authenticate_header(self, request): pass 使用自定义的认证类。\nclass EstateViewSet(CacheResponseMixin, ModelViewSet): # 通过queryset指定如何获取数据（资源） queryset = Estate.objects.all().select_related(\u0026#39;district\u0026#39;).prefetch_related(\u0026#39;agents\u0026#39;) # 通过serializer_class指定如何序列化数据 serializer_class = EstateSerializer # 指定根据哪些字段进行数据筛选 filter_fields = (\u0026#39;district\u0026#39;, \u0026#39;name\u0026#39;) # 指定根据哪些字段对数据进行排序 ordering_fields = (\u0026#39;hot\u0026#39;, ) # 指定用于进行用户身份验证的类 authentication_classes = (MyAuthentication, )  说明：也可以在Django配置文件中将自定义的认证类设置为默认认证方式。\n 授予权限 权限检查总是在视图的最开始处运行，在任何其他代码被允许进行之前。最简单的权限是允许通过身份验证的用户访问，并拒绝未经身份验证的用户访问，这对应于dfr中的IsAuthenticated类，可以用它来取代默认的AllowAny类。权限策略可以在Django的drf配置中用DEFAULT_PERMISSION_CLASSES全局设置。\nREST_FRAMEWORK = { \u0026#39;DEFAULT_PERMISSION_CLASSES\u0026#39;: ( \u0026#39;rest_framework.permissions.IsAuthenticated\u0026#39;, ) } 也可以在基于APIView类的视图上设置身份验证策略。\nfrom rest_framework.permissions import IsAuthenticated from rest_framework.views import APIView class ExampleView(APIView): permission_classes = (IsAuthenticated, ) # 此处省略其他代码 或者在基于@api_view装饰器的视图函数上设置。\nfrom rest_framework.decorators import api_view, permission_classes from rest_framework.permissions import IsAuthenticated @api_view([\u0026#39;GET\u0026#39;]) @permission_classes((IsAuthenticated, )) def example_view(request, format=None): # 此处省略其他代码 自定义权限需要继承BasePermission并实现以下方法中的一个或两个，下面是BasePermission的代码。\n@six.add_metaclass(BasePermissionMetaclass) class BasePermission(object): \u0026#34;\u0026#34;\u0026#34; A base class from which all permission classes should inherit. \u0026#34;\u0026#34;\u0026#34; def has_permission(self, request, view): \u0026#34;\u0026#34;\u0026#34; Return `True` if permission is granted, `False` otherwise. \u0026#34;\u0026#34;\u0026#34; return True def has_object_permission(self, request, view, obj): \u0026#34;\u0026#34;\u0026#34; Return `True` if permission is granted, `False` otherwise. \u0026#34;\u0026#34;\u0026#34; return True 如果请求被授予访问权限，则方法应该返回True，否则返False。下面的例子演示了阻止黑名单中的IP地址访问接口数据（这个在反爬虫的时候很有用哟）。\nfrom rest_framework import permissions class BlacklistPermission(permissions.BasePermission): \u0026#34;\u0026#34;\u0026#34; Global permission check for blacklisted IPs. \u0026#34;\u0026#34;\u0026#34; def has_permission(self, request, view): ip_addr = request.META[\u0026#39;REMOTE_ADDR\u0026#39;] blacklisted = Blacklist.objects.filter(ip_addr=ip_addr).exists() return not blacklisted 如果要实现更为完整的权限验证，可以考虑RBAC或ACL。\n RBAC - 基于角色的访问控制，如下图所示。   ACL - 访问控制列表（每个用户绑定自己的访问白名单）。  访问限流 可以修改dfr配置的DEFAULT_THROTTLE_CLASSES 和 DEFAULT_THROTTLE_RATES两个值来设置全局默认限流策略。例如：\nREST_FRAMEWORK = { \u0026#39;DEFAULT_THROTTLE_CLASSES\u0026#39;: ( \u0026#39;rest_framework.throttling.AnonRateThrottle\u0026#39;, \u0026#39;rest_framework.throttling.UserRateThrottle\u0026#39; ), \u0026#39;DEFAULT_THROTTLE_RATES\u0026#39;: { \u0026#39;anon\u0026#39;: \u0026#39;3/min\u0026#39;, \u0026#39;user\u0026#39;: \u0026#39;10000/day\u0026#39; } } DEFAULT_THROTTLE_RATES中使用的频率描述可能包括second、minute、hour或day。\n如果要为接口单独设置限流，可以在每个视图或视图集上设置限流策略，如下所示：\nfrom rest_framework.throttling import UserRateThrottle from rest_framework.views import APIView class ExampleView(APIView): throttle_classes = (UserRateThrottle, ) # 此处省略下面的代码 或\n@api_view([\u0026#39;GET\u0026#39;]) @throttle_classes([UserRateThrottle, ]) def example_view(request, format=None): # 此处省略下面的代码 当然也可以通过继承BaseThrottle来自定义限流策略，通常需要重写allow_request和wait方法。\n异步任务和计划任务 Celery的应用 Celery 是一个简单、灵活且可靠的，处理大量消息的分布式系统，并且提供维护这样一个系统的必需工具。它是一个专注于实时处理的任务队列，同时也支持任务调度。\n推荐阅读：《Celery官方文档中文版》，上面有极为详细的配置和使用指南。\nCelery是一个本身不提供队列服务，官方推荐使用RabbitMQ或Redis来实现消息队列服务，前者是更好的选择，它对AMQP（高级消息队列协议）做出了非常好的实现。\n 安装RabbitMQ。\ndocker pull rabbitmq docker run -d -p 5672:5672 --name myrabbit rabbitmq docker container exec -it myrabbit /bin/bash 创建用户、资源以及分配操作权限。\nrabbitmqctl add_user luohao 123456 rabbitmqctl set_user_tags luohao administrator rabbitmqctl add_vhost vhost1 rabbitmqctl set_permissions -p vhost1 luohao \u0026#34;.*\u0026#34; \u0026#34;.*\u0026#34; \u0026#34;.*\u0026#34; 创建Celery实例。\n# 注册环境变量 os.environ.setdefault(\u0026#39;DJANGO_SETTINGS_MODULE\u0026#39;, \u0026#39;fangtx.settings\u0026#39;) # 创建Celery实例 app = celery.Celery( \u0026#39;fangtx\u0026#39;, broker=\u0026#39;amqp://luohao:123456@120.77.222.217:5672/vhost1\u0026#39; ) # 从项目的配置文件读取Celery配置信息 app.config_from_object(\u0026#39;django.conf:settings\u0026#39;) # 从指定的文件(例如celery_config.py)中读取Celery配置信息 # app.config_from_object(\u0026#39;celery_config\u0026#39;) # 让Celery自动从参数指定的应用中发现异步任务/定时任务 app.autodiscover_tasks([\u0026#39;common\u0026#39;, ]) # 让Celery自动从所有注册的应用中发现异步任务/定时任务 # app.autodiscover_tasks(lambda: settings.INSTALLED_APPS) 启动Celery创建woker（消息的消费者）。\ncelery -A \u0026lt;name\u0026gt; worker -l debug \u0026amp; 执行异步任务。\n@app.task def send_email(from, to, cc, subject, content): pass send_email.delay(\u0026#39;\u0026#39;, [], [], \u0026#39;\u0026#39;, \u0026#39;\u0026#39;) 创建定时任务。\n# 配置定时任务（计划任务） app.conf.update( timezone=settings.TIME_ZONE, enable_utc=True, # 定时任务（计划任务）相当于是消息的生产者 # 如果只有生产者没有消费者那么消息就会在消息队列中积压 # 将来实际部署项目的时候生产者、消费者、消息队列可能都是不同节点 beat_schedule={ \u0026#39;task1\u0026#39;: { \u0026#39;task\u0026#39;: \u0026#39;common.tasks.show_msg\u0026#39;, \u0026#39;schedule\u0026#39;: crontab(), \u0026#39;args\u0026#39;: (\u0026#39;刘强东，奶茶妹妹喊你回家喝奶啦\u0026#39;, ) }, }, )@app.task def show_msg(content): print(content) 启动Celery创建执行定时任务的beat（消息的生产者）。\ncelery -A \u0026lt;name\u0026gt; beat -l info 检查消息队列状况。\nrabbitmqctl list_queues -p vhost1 监控Celery - 可以通过flower来对Celery进行监控。\npip install flower celery flower --broker=amqp://luohao:123456@120.77.222.217:5672/vhost1  其他问题 问题1：如何解决JavaScript跨域获取数据的问题？（django-cors-headers）\nINSTALLED_APPS = [ \u0026#39;corsheaders\u0026#39;, ] MIDDLEWARE = [ \u0026#39;corsheaders.middleware.CorsMiddleware\u0026#39;, ] CORS_ORIGIN_ALLOW_ALL = True # 配置跨域白名单 # CORS_ORIGIN_WHITELIST = (\u0026#39;www.abc.com\u0026#39;, \u0026#39;www.baidu.com\u0026#39;) # CORS_ORIGIN_REGEX_WHITELIST = (\u0026#39;...\u0026#39;, ) # CORS_ALLOW_CREDENTIALS = True # CORS_ALLOW_METHODS = (\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;, \u0026#39;PUT\u0026#39;, \u0026#39;DELETE\u0026#39;) 问题2：网站图片（水印、剪裁）和视频（截图、水印、转码）是如何处理的？（云存储、FFmpeg）\n问题3：网站如何架设（静态资源）文件系统？（FastDFS、云存储、CDN）\n安全保护 问题1：什么是跨站脚本攻击，如何防范？（对提交的内容进行消毒）\n问题2：什么是跨站身份伪造，如何防范？（使用随机令牌）\n问题3：什么是SQL注射攻击，如何防范？（不拼接SQL语句，避免使用单引号）\n问题4：什么是点击劫持攻击，如何防范？（不允许\u0026lt;iframe\u0026gt;加载非同源站点内容）\nDjango提供的安全措施 签名数据的API\n\u0026gt;\u0026gt;\u0026gt; from django.core.signing import Signer \u0026gt;\u0026gt;\u0026gt; signer = Signer() \u0026gt;\u0026gt;\u0026gt; value = signer.sign(\u0026#39;hello, world!\u0026#39;) \u0026gt;\u0026gt;\u0026gt; value \u0026#39;hello, world!:BYMlgvWMTSPLxC-DqxByleiMVXU\u0026#39; \u0026gt;\u0026gt;\u0026gt; signer.unsign(value) \u0026#39;hello, world!\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; signer = Signer(salt=\u0026#39;1qaz2wsx\u0026#39;) \u0026gt;\u0026gt;\u0026gt; signer.sign(\u0026#39;hello, world!\u0026#39;) \u0026#39;hello, world!:9vEvG6EA05hjMDB5MtUr33nRA_M\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; from django.core.signing import TimestampSigner \u0026gt;\u0026gt;\u0026gt; signer = TimestampSigner() \u0026gt;\u0026gt;\u0026gt; value = signer.sign(\u0026#39;hello, world!\u0026#39;) \u0026gt;\u0026gt;\u0026gt; value \u0026#39;hello, world!:1fpmcQ:STwj464IFE6eUB-_-hyUVF3d2So\u0026#39; \u0026gt;\u0026gt;\u0026gt; signer.unsign(value, max_age=5) Traceback (most recent call last): File \u0026#34;\u0026lt;console\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; File \u0026#34;/Users/Hao/Desktop/fang.com/venv/lib/python3.6/site-packages/django/core/signing.py\u0026#34;, line 198, in unsign \u0026#39;Signature age %s\u0026gt; %sseconds\u0026#39; % (age, max_age)) django.core.signing.SignatureExpired: Signature age 21.020604848861694 \u0026gt; 5 seconds \u0026gt;\u0026gt;\u0026gt; signer.unsign(value, max_age=120) \u0026#39;hello, world!\u0026#39; CSRF令牌和小工具\n{% csrf_token %}  @csrf_exempt：免除令牌 @csrf_protect：提供令牌保护 @require_csrf_token：提供令牌保护 @ensure_csrf_cookie：强制视图发送带令牌的cookie   说明：可以在Chrome浏览器中安装EditThisCookie插件来方便的查看Cookie。\n 用户敏感信息的保护  哈希摘要（签名）\n\u0026gt;\u0026gt;\u0026gt; import hashlib \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; md5_hasher = hashlib.md5() \u0026gt;\u0026gt;\u0026gt; md5_hasher.update(\u0026#39;hello, world!\u0026#39;.encode()) \u0026gt;\u0026gt;\u0026gt; md5_hasher.hexdigest() \u0026#39;3adbbad1791fbae3ec908894c4963870\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; sha1_hasher = hashlib.sha1() \u0026gt;\u0026gt;\u0026gt; sha1_hasher.update(\u0026#39;hello, world!\u0026#39;.encode()) \u0026gt;\u0026gt;\u0026gt; sha1_hasher.update(\u0026#39;goodbye, world!\u0026#39;.encode()) \u0026gt;\u0026gt;\u0026gt; sha1_hasher.hexdigest() \u0026#39;1f09d30c707d53f3d16c530dd73d70a6ce7596a9\u0026#39; 加密和解密（对称加密和非对称加密）\npip install rsa\u0026gt;\u0026gt;\u0026gt; pub_key, pri_key = rsa.newkeys(1024) \u0026gt;\u0026gt;\u0026gt; message = \u0026#39;hello, world!\u0026#39; \u0026gt;\u0026gt;\u0026gt; crypto = rsa.encrypt(message.encode(), pub_key) \u0026gt;\u0026gt;\u0026gt; crypto b\u0026#39;Ou{gH\\xa9\\xa8}O\\xe3\\x1d\\x052|M\\x9d9?\\xdc\\xd8\\xecF\\xd3v\\x9b\\xde\\x8e\\x12\\xe6M\\xebvx\\x08\\x08\\x8b\\xe8\\x86~\\xe4^)w\\xf2\\xef\\x9e\\x9fOg\\x15Q\\xb7\\x7f\\x1d\\xcfV\\xf1\\r\\xbe^+\\x8a\\xbf}\\x10\\x01\\xa4U9b\\x97\\xf5\\xe0\\x90T\\\u0026#39;\\xd4(\\x9b\\x00\\xa5\\x92\\x17\\xad4\\xb0\\xb0\u0026#34;\\xd4\\x16\\x94*s\\xe1r\\xb7L\\xe2\\x98\\xb7\\x7f\\x03\\xd9\\xf2\\t\\xee*\\xe6\\x93\\xe6\\xe1o\\xfd\\x18\\x83L\\x0cfL\\xff\\xe4\\xdd%\\xf2\\xc0/\\xfb\u0026#39; \u0026gt;\u0026gt;\u0026gt; origin = rsa.decrypt(crypto, pri_key).decode() \u0026gt;\u0026gt;\u0026gt; origin \u0026#39;hello, world!\u0026#39;pip install pycrypto  AES对称加密：\n\u0026gt;\u0026gt;\u0026gt; from hashlib import md5 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; from Crypto.Cipher import AES \u0026gt;\u0026gt;\u0026gt; from Crypto import Random \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; key = md5(b\u0026#39;mysecret\u0026#39;).hexdigest() \u0026gt;\u0026gt;\u0026gt; iv = Random.new().read(AES.block_size) \u0026gt;\u0026gt;\u0026gt; str1 = \u0026#39;我爱你们！\u0026#39; \u0026gt;\u0026gt;\u0026gt; str2 = AES.new(key, AES.MODE_CFB, iv).encrypt(str1) b\u0026#39;p\\x96o\\x85\\x0bq\\xc4-Y\\xc4\\xbcp\\n)\u0026amp;\u0026#39; \u0026gt;\u0026gt;\u0026gt; str3 = AES.new(key, AES.MODE_CFB, iv).decrypt(str2).decode() \u0026#39;我爱你们！\u0026#39; RSA非对称加密：\n\u0026gt;\u0026gt;\u0026gt; from Crypto.PublicKey import RSA \u0026gt;\u0026gt;\u0026gt; # 生成密钥对 \u0026gt;\u0026gt;\u0026gt; key_pair = RSA.generate(2048) \u0026gt;\u0026gt;\u0026gt; # 导入公钥 \u0026gt;\u0026gt;\u0026gt; pub_key = RSA.importKey(key_pair.publickey().exportKey()) \u0026gt;\u0026gt;\u0026gt; # 导入私钥 \u0026gt;\u0026gt;\u0026gt; pri_key = RSA.importKey(key_pair.exportKey()) \u0026gt;\u0026gt;\u0026gt; # 明文 \u0026gt;\u0026gt;\u0026gt; message1 = \u0026#39;hello, world!\u0026#39;.encode() \u0026gt;\u0026gt;\u0026gt; # 加密数据 \u0026gt;\u0026gt;\u0026gt; message2 = pub_key.encrypt(message1, None) (b\u0026#39;\\x03\\x86t\\xa0\\x00\\xc4\\xea\\xd2\\x80\\xed\\xa7YN7\\x07\\xff\\x88\\xaa\\x1eW\\x0cmH0\\x06\\xa7\\\u0026#39;\\xbc\u0026lt;w@q\\x8b\\xaf\\xf7:g\\x92{=\\xe2E\\xa5@\\x1as2\\xdd\\xcb\\x8e[\\x98\\x85\\xdf,X\\xecj.U\\xd6\\xa7W\u0026amp;u\\\u0026#39;Uz\u0026#34;\\x0f\\x0e\\\\\u0026lt;\\xa4\\xfavC\\x93\\xa7\\xbcO\u0026#34;\\xb9a\\x06]\u0026lt;.\\xc1\\r1}*\\xdf\\xccdqXML\\x93\\x1b\\xe9\\xda\\xdf\\xab|\\xf8\\x18\\xe4\\x99\\xbb\\x7f\\x18}\\xd9\\x9a\\x1e*J\\\\\\xca\\x1a\\xd1\\x85\\xf7t\\x81\\xd95{\\x19\\xc9\\x81\\xb6^}\\x9c5\\xca\\xfe\\xcf\\xc8\\xd8M\\x9a\\x8c-\\xf1t\\xee\\xf9\\x12\\x90\\x01\\xca\\x92~\\x00c5qg5g\\x95\u0026amp;\\x10\\xb1\\x0b\\x1fo\\x95\\xf2\\xbc\\x8d\\xf3f\u0026#34;@\\xc5\\x188\\x0bX\\x9cfo\\xea\\x97\\x05@\\xe5\\xb2\\xda\\xb8\\x97a\\xa5w\\xa8\\x01\\x9a\\xa5N\\xc4\\x81\\x8d\\x0f\u0026lt;\\x96iU\\xd3\\x95\\xacJZs\\xab_ #\\xee\\xf9\\x0f\\xf2\\x12\\xdb\\xfc\\xf8g\\x18v\\x02k+\\xda\\x16Si\\xbf\\xbb\\xec\\xf7w\\x90\\xde\\xae\\x97\\t\\xed{}5\\xd0\u0026#39;,) \u0026gt;\u0026gt;\u0026gt; # 解密数据 \u0026gt;\u0026gt;\u0026gt; message3 = pri_key.decrypt(message2) \u0026#39;hello, world!\u0026#39; 安全相关建议  虽然 Django 自带了稳固的安全保护措施，但是依然要采用正确的方式部署应用程序，利用 Web 服务器、操作系统和其他组件提供的安全保护措施。 记得把 Python 代码放在 Web 服务器的文档根目录之外，避免代码意外泄露。 谨慎处理用户上传的文件。 Django本身没有对请求次数加以限制（包括验证用户身份的请求），为了防止暴力攻击和破解，可以考虑使用具有一次消费性的验证码或对这类请求的次数进行限制。\n 将缓存系统、数据库服务器以及重要的资源服务器都放在第二级防火墙之后（不要放在DMZ）。  测试相关 测试是发现和标记缺陷的过程。所谓的缺陷是指实际结果和期望结果之间的任何差别。有的地方，测试也被认为是执行以找出错误为目的的程序的过程。 测试是为了让产品达到以下目标：\n 满足需求用户满意 改善产品的市场占有率 树立对产品的信任 减少开发和维护的成本  功能测试 如果一个软件单元的行为方式与它的开发规范完全一样，那么该软件单元就通过了它的功能测试。 - 白盒测试：开发人员自己实现，最基本的形式是单元测试，还有集成测试和系统测试。 - 黑盒测试：由开发团队之外的人执行，对测试代码没有可见性，将被测系统视为黑盒子。通常由测试人员或QA工程师来执行，Web应用可以通过Selenium这样的测试框架自动化实施。\n性能测试 软件在高工作负载下对其响应性和健壮性展开的测试。\n 负载测试：在特定负载下执行的测试。\n 压力测试：突发条件或极限条件下的性能测试。   安全性测试 系统的敏感数据都是经过认证和授权之后才能访问。\n其他测试 易用性测试 / 安装测试 / 可访问性测试\n单元测试 测试函数和对象的方法（程序中最小最基本的单元）。通过对实际输出和预期输出的比对以及各种的断言条件来判定被测单元是否满足设计需求。\n 测试用例 测试固件 - 每次测试时都要使用的东西。 测试套件（测试集）- 组合了多个测试用例而构成的集合。\nclass UtilTest(TestCase): def setUp(self): self.pattern = re.compile(r\u0026#39;\\d{6}\u0026#39;) def test_gen_mobile_code(self): for _ in range(100): self.assertIsNotNone(self.pattern.match(gen_mobile_code())) def test_to_md5_hex(self): md5_dict = { \u0026#39;123456\u0026#39;: \u0026#39;e10adc3949ba59abbe56e057f20f883e\u0026#39;, \u0026#39;123123123\u0026#39;: \u0026#39;f5bb0c8de146c67b44babbf4e6584cc0\u0026#39;, \u0026#39;1qaz2wsx\u0026#39;: \u0026#39;1c63129ae9db9c60c3e8aa94d3e00495\u0026#39;, } for key, value in md5_dict.items(): self.assertEqual(value, to_md5_hex(key))  TestCase的断言方法：\n assertEqual / assertNotEqual assertTrue / assertFalse / assertIsNot assertRaise / assertRaiseRegexp assertAlmostEqual / assertNotAlmostEqual assertGreater / assertGreaterEqual / assertLess / assertLessEqual assertRegexpMatches / assertNotRegexpMatches assertListEqual / assertSetEqual / assertTupleEqual / assertDictEqual  可以使用nose2或pytest来辅助执行单元测试，同时通过cov-core或pytest-cov可以对测试覆度进行评估。覆盖率由百分比表示。比如测试代码执行过了程序的每一行，那么覆盖率就是100%。这种时候，几乎不会出现新程序上线后突然无法运行的尴尬情况。覆盖率不关心代码内容究竟是什么，覆盖率是用来检查“测试代码不足、测试存在疏漏”的一个指标，“测试内容是否妥当”并不归它管。\npip install nose2 pytest cov-core pytest-cov 可以使用Selenium来实现Web应用的自动化测试，它还可以用于屏幕抓取与浏览器行为模拟，通过爬虫抓取页面上的动态数据也可以使用它。Selenium其实包括三个部分：\n Selenium IDE：嵌入到浏览器的插件，可以录制和回放脚本。   Selenium WebDriver：支持多种语言可以操控浏览器的API。\n Selenium Standalone Server：Selenium Grid、远程控制、分布式部署。\npip install seleniumfrom selenium import webdriver import pytest import contextlib @pytest.fixture(scope=\u0026#39;session\u0026#39;) def chrome(): # 设置使用无头浏览器(不会打开浏览器窗口) options = webdriver.ChromeOptions() options.add_argument(\u0026#39;--headless\u0026#39;) driver = webdriver.Chrome(options=options) yield driver driver.quit() def test_baidu_index(chrome): chrome.get(\u0026#39;https://www.baidu.com\u0026#39;) assert chrome.title == \u0026#39;百度一下，你就知道\u0026#39;  除了Selenium之外，还有一个Web自动化测试工具名叫Robot Framework。\nnose2 -v -C pytest --covRan 7 tests in 0.002s OK Name Stmts Miss Cover ---------------------------------------------- example01.py 15 0 100% example02.py 49 49 0% example03.py 22 22 0% example04.py 61 61 0% example05.py 29 29 0% example06.py 39 39 0% example07.py 19 19 0% example08.py 27 27 0% example09.py 18 18 0% example10.py 19 19 0% example11.py 22 22 0% example12.py 28 28 0% example13.py 28 28 0% test_ddt_example.py 18 0 100% test_pytest_example.py 11 6 45% test_unittest_example.py 22 0 100% ---------------------------------------------- TOTAL 427 367 14% 在测试过程中需要孤立各种外部依赖（数据库、外部接口调用、时间依赖），具体又包括两个方面：\n 数据源：数据本地化 / 置于内存中 / 测试之后回滚\n 资源虚拟化：存根/桩（stub）、仿制/模拟（mock）、伪造（fake）\n stub：测试期间为提供响应的函数生成的替代品 mock：代替实际对象（以及该对象的API）的对象 fake：没有达到生产级别的轻量级对象   集成测试 集成多个函数或方法的输入输出的测试，测试时需要将多个测试对象组合在一起。\n 测试组件互操作性 / 需求变更测试 / 外部依赖和API / 调试硬件问题 / 在代码路径中发现异常  系统测试 对需求的测试，测试成品是否最终满足了所有需求，在客户验收项目时进行。\n数据驱动测试 使用外部数据源实现对输入值与期望值的参数化，避免在测试中使用硬编码的数据。\n被测函数：\ndef add(x, y): return x + y data.csv文件：\n3,1,2 0,1,-1 100,50,50 100,1,99 15,7,8  测试代码：\nimport csv from unittest import TestCase from ddt import ddt, data, unpack @ddt class TestAdd(TestCase): def load_data_from_csv(filename): data_items = [] with open(filename, \u0026#39;r\u0026#39;, newline=\u0026#39;\u0026#39;) as fs: reader = csv.reader(fs) for row in reader: data_items.append(list(map(int, row))) return data_items @data(*load_data_from_csv(\u0026#39;data.csv\u0026#39;)) @unpack def test_add(self, result, param1, param2): self.assertEqual(result, add(param1, param2)) Django中的测试  测试Django视图 - Django中提供的TestCase扩展了unittest中的TestCase，绑定了一个名为client的属性，可以用来模拟浏览器发出的GET、POST、DELETE、PUT等请求。\nclass SomeViewTest(TestCase): def test_example_view(self): resp = self.client.get(reverse(\u0026#39;index\u0026#39;)) self.assertEqual(200, resp.status_code) self.assertEqual(5, resp.context[\u0026#39;num\u0026#39;]) 运行测试 - 配置测试数据库。\nDATABASES = { \u0026#39;default\u0026#39;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;django.db.backends.mysql\u0026#39;, \u0026#39;HOST\u0026#39;: \u0026#39;localhost\u0026#39;, \u0026#39;PORT\u0026#39;: 3306, \u0026#39;NAME\u0026#39;: \u0026#39;DbName\u0026#39;, \u0026#39;USER\u0026#39;: os.environ[\u0026#39;DB_USER\u0026#39;], \u0026#39;PASSWORD\u0026#39;: os.environ[\u0026#39;DB_PASS\u0026#39;], \u0026#39;TEST\u0026#39;: { \u0026#39;NAME\u0026#39;: \u0026#39;DbName_for_testing\u0026#39;, \u0026#39;CHARSET\u0026#39;: \u0026#39;utf8\u0026#39;, }, } }python manage.py test python manage.py test common python manage.py test common.tests.UtilsTest python manage.py test common.tests.UtilsTest.test_to_md5_hex 评估测试覆盖度\npip install coverage coverage run --source=\u0026lt;path1\u0026gt; --omit=\u0026lt;path2\u0026gt; manage.py test common coverage report Name Stmts Miss Cover --------------------------------------------------- common/__init__.py 0 0 100% common/admin.py 1 0 100% common/apps.py 3 3 0% common/forms.py 16 16 0% common/helper.py 32 32 0% common/middlewares.py 19 19 0% common/migrations/__init__.py 0 0 100% common/models.py 71 2 97% common/serializers.py 14 14 0% common/tests.py 14 8 43% common/urls_api.py 3 3 0% common/urls_user.py 3 3 0% common/utils.py 22 7 68% common/views.py 69 69 0% --------------------------------------------------- TOTAL 267 176 34%  性能测试 问题1：性能测试的指标有哪些？\n ab（ Apache Benchmark） / webbench / httpperf\nyum -y install httpd ab -c 10 -n 1000 http://www.baidu.com/ ... Benchmarking www.baidu.com (be patient).....done Server Software: BWS/1.1 Server Hostname: www.baidu.com Server Port: 80 Document Path: / Document Length: 118005 bytes Concurrency Level: 10 Time taken for tests: 0.397 seconds Complete requests: 100 Failed requests: 98 (Connect: 0, Receive: 0, Length: 98, Exceptions: 0) Write errors: 0 Total transferred: 11918306 bytes HTML transferred: 11823480 bytes Requests per second: 252.05 [#/sec] (mean) Time per request: 39.675 [ms] (mean) Time per request: 3.967 [ms] (mean, across all concurrent requests) Transfer rate: 29335.93 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 6 7 0.6 7 9 Processing: 20 27 22.7 24 250 Waiting: 8 11 21.7 9 226 Total: 26 34 22.8 32 258 Percentage of the requests served within a certain time (ms) 50% 32 66% 34 75% 34 80% 34 90% 36 95% 39 98% 51 99% 258 100% 258 (longest request) mysqlslap\nmysqlslap -a -c 100 -h 1.2.3.4 -u root -p mysqlslap -a -c 100 --number-of-queries=1000 --auto-generate-sql-load-type=read -h \u0026lt;负载均衡服务器IP地址\u0026gt; -u root -p mysqlslap -a --concurrency=50,100 --number-of-queries=1000 --debug-info --auto-generate-sql-load-type=mixed -h 1.2.3.4 -u root -p sysbench\nsysbench --test=threads --num-threads=64 --thread-yields=100 --thread-locks=2 run sysbench --test=memory --num-threads=512 --memory-block-size=256M --memory-total-size=32G run jmeter\n  请查看《使用JMeter进行性能测试》。\n LoadRunner / QTP  项目调试 可以使用django-debug-toolbar来辅助项目调试。\n 安装\npip install django-debug-toolbar 配置 - 修改settings.py。\nINSTALLED_APPS = [ \u0026#39;debug_toolbar\u0026#39;, ] MIDDLEWARE = [ \u0026#39;debug_toolbar.middleware.DebugToolbarMiddleware\u0026#39;, ] DEBUG_TOOLBAR_CONFIG = { # 引入jQuery库 \u0026#39;JQUERY_URL\u0026#39;: \u0026#39;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js\u0026#39;, # 工具栏是否折叠 \u0026#39;SHOW_COLLAPSED\u0026#39;: True, # 是否显示工具栏 \u0026#39;SHOW_TOOLBAR_CALLBACK\u0026#39;: lambda x: True, } 配置 - 修改urls.py。\nif settings.DEBUG: import debug_toolbar urlpatterns.insert(0, path(\u0026#39;__debug__/\u0026#39;, include(debug_toolbar.urls))) 使用 - 在页面右侧可以看到一个调试工具栏，上面包括了执行时间、项目设置、请求头、SQL、静态资源、模板、缓存、信号等调试信息，查看起来非常的方便。\n  部署相关 请参考《Django项目上线指南》。\n性能相关 网站优化两大定律：  尽可能的使用缓存 - 牺牲空间换取时间（普适策略）。\n 能推迟的都推迟 - 使用消息队列将并行任务串行来缓解服务器压力。\n 服务器CPU利用率出现瞬时峰值 - 削峰（CPU利用率平缓的增长） 上下游节点解耦合（下订单和受理订单的系统通常是分离的）   Django框架  配置缓存来缓解数据库的压力，并有合理的机制应对缓存穿透和缓存雪崩。\n 开启模板缓存来加速模板的渲染。\nTEMPLATES = [ { \u0026#39;BACKEND\u0026#39;: \u0026#39;django.template.backends.django.DjangoTemplates\u0026#39;, \u0026#39;DIRS\u0026#39;: [os.path.join(BASE_DIR, \u0026#39;templates\u0026#39;), ], # \u0026#39;APP_DIRS\u0026#39;: True, \u0026#39;OPTIONS\u0026#39;: { \u0026#39;context_processors\u0026#39;: [ \u0026#39;django.template.context_processors.debug\u0026#39;, \u0026#39;django.template.context_processors.request\u0026#39;, \u0026#39;django.contrib.auth.context_processors.auth\u0026#39;, \u0026#39;django.contrib.messages.context_processors.messages\u0026#39;, ], \u0026#39;loaders\u0026#39;: [( \u0026#39;django.template.loaders.cached.Loader\u0026#39;, [ \u0026#39;django.template.loaders.filesystem.Loader\u0026#39;, \u0026#39;django.template.loaders.app_directories.Loader\u0026#39;, ], ), ], }, }, ] 用惰性求值、迭代器、defer()、only()等缓解内存压力。\n 用select_related()和prefetch_related()执行预加载避免“1+N查询问题”。\n  数据库  用ID生成器代替自增主键（性能更好、适用于分布式环境）。\n 自定义ID生成器\n UUID\n\u0026gt;\u0026gt;\u0026gt; my_uuid = uuid.uuid1() \u0026gt;\u0026gt;\u0026gt; my_uuid UUID(\u0026#39;63f859d0-a03a-11e8-b0ad-60f81da8d840\u0026#39;) \u0026gt;\u0026gt;\u0026gt; my_uuid.hex \u0026#39;63f859d0a03a11e8b0ad60f81da8d840\u0026#39;  避免不必要的外键列上的约束（除非必须保证参照完整性），更不要使用触发器之类的机制。\n 使用索引来优化查询性能（索引放在要用于查询的字段上）。InnoDB用的是BTREE索引，使用\u0026gt;、\u0026lt;、\u0026gt;=、\u0026lt;=、BETWEEN或者LIKE \u0026lsquo;pattern\u0026rsquo;（pattern不以通配符开头）时都可以用到索引。因为建立索引需要额外的磁盘空间，而主键上是有默认的索引，所以主键要尽可能选择较短的数据类型来减少磁盘占用，提高索引的缓存效果。\ncreate index idx_goods_name on tb_goods (gname(10));-- 无法使用索引 select * from tb_goods where gname like \u0026#39;%iPhone%\u0026#39;; -- 可以使用索引 select * from tb_goods where gname like \u0026#39;iPhone%\u0026#39;;# 无法使用索引 Goods.objects.filter(name_icontains=\u0026#39;iPhone\u0026#39;) # 可以使用索引 Goods.objects.filter(name__istartswith=\u0026#39;iPhone\u0026#39;); 使用存储过程（存储在服务器端编译过的一组SQL语句）。\ndrop procedure if exists sp_avg_sal_by_dept; create procedure sp_avg_sal_by_dept(deptno integer, out avg_sal float) begin select avg(sal) into avg_sal from TbEmp where dno=deptno; end; call sp_avg_sal_by_dept(10, @a); select @a;\u0026gt;\u0026gt;\u0026gt; from django.db import connection \u0026gt;\u0026gt;\u0026gt; cursor = connection.cursor() \u0026gt;\u0026gt;\u0026gt; cursor.callproc(\u0026#39;sp_avg_sal_by_dept\u0026#39;, (10, 0)) \u0026gt;\u0026gt;\u0026gt; cursor.execute(\u0026#39;select @_sp_avg_sal_by_dept_1\u0026#39;) \u0026gt;\u0026gt;\u0026gt; cursor.fetchone() (2675.0,) 使用数据分区。通过分区可以存储更多的数据、优化查询更大的吞吐量、可以快速删除过期的数据。关于这个知识点可以看看MySQL的官方文档。\n RANGE分区：基于连续区间范围，把数据分配到不同的分区。 LIST分区：基于枚举值的范围，把数据分配到不同的分区。 HASH分区 / KEY分区：基于分区个数，把数据分配到不同的分区。\nCREATE TABLE tb_emp ( eno INT NOT NULL, ename VARCHAR(20) NOT NULL, job VARCHAR(10) NOT NULL, hiredate DATE NOT NULL, dno INT NOT NULL ) PARTITION BY HASH(dno) PARTITIONS 4;CREATE TABLE tb_emp ( eno INT NOT NULL, ename VARCHAR(20) NOT NULL, job VARCHAR(10) NOT NULL, hiredate DATE NOT NULL, dno INT NOT NULL ) PARTITION BY RANGE( YEAR(hiredate) ) ( PARTITION p0 VALUES LESS THAN (1960), PARTITION p1 VALUES LESS THAN (1970), PARTITION p2 VALUES LESS THAN (1980), PARTITION p3 VALUES LESS THAN (1990), PARTITION p4 VALUES LESS THAN MAXVALUE );  使用explain来分析查询性能 - 执行计划。\nexplain select * from ...;  explain结果解析：\n select_type：表示select操作的类型，常见的值有SIMPLE（简单查询，没有使用子查询或者表连接查询）、PRIMARY（主查询，外层的查询）、UNION（并集操作中的第二个或者后面的查询）、SUBQUERY（子查询中的第一个SELECT）等。 table：输出结果的表。 type：MySQL在表中找到所需行的方式，也称为访问类型，常见的值有：  ALL：全表扫描（遍历全表找到匹配的行） index：索引全扫描（遍历整个索引） range：索引范围扫描 ref：非唯一索引扫描或唯一索引的前缀扫描 eq_ref：唯一索引扫描 const / system：表中最多有一行匹配 NULL：不用访问表或者索引  possible_keys：查询时可能用到的索引。 key：实际使用的索引。 key_len：使用到索引字段的长度。 rows：扫描行的数量。 Extra：额外的信息（执行情况的说明或描述）。   说明：关于MySQL更多的知识尤其是性能调优和运维方面的内容，推荐大家阅读网易出品的《深入浅出MySQL（第2版）》，网易出品必属精品。\n  使用慢查询日志来发现性能低下的查询。\nmysql\u0026gt; show variables like \u0026#39;slow_query%\u0026#39;; +---------------------------+----------------------------------+ | Variable_name | Value | +---------------------------+----------------------------------+ | slow_query_log | OFF | | slow_query_log_file | /mysql/data/localhost-slow.log | +---------------------------+----------------------------------+  mysql\u0026gt; show variables like \u0026#39;long_query_time\u0026#39;; +-----------------+-----------+ | Variable_name | Value | +-----------------+-----------+ | long_query_time | 10.000000 | +-----------------+-----------+mysql\u0026gt; set global slow_query_log=\u0026#39;ON\u0026#39;; mysql\u0026gt; set global long_query_time=1;[mysqld] slow_query_log=ON slow_query_log_file=/usr/local/mysql/data/slow.log long_query_time=1  其他 请参考《Python性能调优》。\n"},{"idx":87,"href":"/python100days/docs/Day91-100/96-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%92%8C%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/","title":"96 软件测试和自动化测试","content":" 软件测试和自动化测试 软件测试概述 软件测试是一种用来促进鉴定软件的正确性、完整性、安全性和品质的过程，也就是在规定的条件下对程序进行操作以发现程序中的错误，衡量软件的品质并对其是否能满足设计要求进行评估的过程。\n测试的方法 黑盒测试：测试应用程序的功能，而不是其内部结构或运作。测试者不需具备应用程序的代码、内部结构和编程语言的专门知识。测试者只需知道什么是系统应该做的事，即当键入一个特定的输入，可得到一定的输出。测试案例是依应用系统应该做的功能，照规范、规格或要求等设计。测试者选择有效输入和无效输入来验证是否正确的输出。此测试方法可适合大部分的软件测试，例如集成测试和系统测试。\n白盒测试：测试应用程序的内部结构或运作，而不是测试应用程序的功能（即黑箱测试）。在白箱测试时，以编程语言的角度来设计测试案例。测试者输入数据验证数据流在程序中的流动路径，并确定适当的输出，类似测试电路中的节点。\n测试的种类（阶段） 单元测试：对软件组成单元进行测试，其目的是检验软件基本组成单位的正确性，测试的对象是软件设计的最小单位 - 函数。\n集成测试：将程序模块采用适当的集成策略组装起来，对系统的接口及集成后的功能进行正确性检测的测试工作。其主要目的是检查软件单位之间的接口是否正确，集成测试的对象是已经经过单元测试的模块。\n系统测试：系统测试主要包括功能测试、界面测试、可靠性测试、易用性测试、性能测试。 回归测试：为了检测代码修改而引入的错误所进行的测试活动。回归测试是软件维护阶段的重要工作，有研究表明，回归测试带来的耗费占软件生命周期的1/3总费用以上。\n测试驱动开发 测试驱动开发包括以下三个步骤：\n 为未实现的新功能或者改进编写自动化测试。 提供通过所有定义的测试的最小代码量。 重构代码以满足所需的质量标准。  测试驱动开发的好处在于可以有效的防止软件回归以及提供更有质量的代码。\nPython的标准库里有为编写单元测试而准备的unittest模块，执行测试时建议使用pytest或nose2。pytest是一款能够自动搜索并执行测试的测试执行工具，并且会输出详细的错误报告。关于单元测试可以看看《Python必会的单元测试框架 - unittest》。\n可以安装testfixtures库来辅助单元测试，它整合了多种典型配置器，提供了生成目录、更改系统日期、生成mock对象的功能模块，这些模块能够帮助我们将单元测试与单元测试所依赖的环境分离开。mock 是将测试对象所依赖的对象替换为虚拟对象的库，在测试的时候，我们可以为虚拟对象指定其在被调用时的返回值以及是否发生异常等。\nWebTest是用于Web应用功能测试的库。它会对WSGI应用执行模拟请求并获取结果。基本上所有WSGI应用的测试都可以用它。\ntox能便捷地为我们准备好执行测试所需的环境。tox会在多个virtualenv环境中搭建测试 环境，然后在这些环境中执行测试并显示结果。它能够把测试工具的选项及环境变量等内容统 一起来，所以我们只需执行tox命令即能轻松完成所需的测试。\nSelenium/Robot Framework Selenium是实现Web应用程序的功能测试以及集成测试自动化的浏览器驱动测试工具群。和使用浏览器的用户相同，Selenium可以在浏览器进行的鼠标操作、在表单中输入文字、验证表单的值等，利用这一点就可以将手动操作变成自动化操作。\nSelenium优点  自动化测试用例制作简单。Selenium提供了Selenium IDE工具，该工具可以捕获鼠标、键盘的操作，然后通过重放功能来重复这些操作，这样就可以简单的制作测试用例。 支持多种浏览器和操作系统。  Selenium的组件  Selenium IDE。 Selenium Remote Control。 Selenium WebDriver。  与持续集成工具协作 持续集成指的是频繁的将代码集成到主干。它的好处主要有两个： 1. 快速发现错误。每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易。\n 防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。  持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。它的核心措施是代码集成到主干之前，必须通过自动化测试，只要有一个测试用例失败，就不能集成。编程大师Martin Fowler曾经说过：“持续集成并不能消除Bug，而是让它们非常容易发现和改正。”\n可以在Jenkins中安装“Seleniumhq Plugin”插件，这样就可以将Selenium IDE制作的测试用例保存为HTML格式并提供给Jenkins来使用，基本步骤是：\n 在执行测试的机器上，从版本控制系统中下载测试套件和测试用例。 在执行测试的机器上下载Selenium Server。 从Jenkins的“系统管理”中选择“插件管理”来安装“Seleniumhq Plugin”。 在Jenkins的“系统管理”中选择“系统设置”并配置“Selenium Remote Control”下的“HTMLSuite Runner”。 新建测试用的Jenkins任务并进行配置，配置的内容包括：浏览器、起始URL、测试套件和测试结果输出文件。  配置完成后，就可以执行Jenkins的“立即构建”了。\n"},{"idx":88,"href":"/python100days/docs/Day91-100/97-%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E8%A6%81%E7%82%B9%E5%89%96%E6%9E%90/","title":"97 电商网站技术要点剖析","content":" 电商网站技术要点剖析 商业模式  B2B - 商家对商家，交易双方都是企业（商家），最典型的案例就是阿里巴巴。 C2C - 个人对个人，例如：淘宝、人人车。 B2C - 商家对个人，例如：唯品会，聚美优品。 C2B - 个人对商家，先有消费者提出需求，后有商家按需求组织生产，例如： 尚品宅配。 O2O - 线上到线下，将线下的商务机会与互联网结合，让互联网成为线下交易的平台，例如：美团外卖、饿了么。 B2B2C - 商家对商家对个人，例如：天猫、京东。  需求要点  用户端\n 首页（商品分类、广告轮播、滚动快讯、瀑布加载、推荐、折扣、热销、……）\n 用户（登录（第三方登录）、注册、注销、自服务（个人信息、浏览历史、收货地址、……））\n 商品（分类、列表、详情、搜索、热门搜索、搜索历史、添加到购物车、收藏、关注、……）\n 购物车（查看、编辑（修改数量、删除商品、清空））\n 订单（提交订单（支付）、历史订单、订单详情、订单评价、……）\n  管理端\n 核心业务实体的CRUD 定时任务（周期性和非周期性） 报表功能（Excel、PDF、ECharts） 权限控制（RBAC） 业务流转（Activity、Airflow、Spiff、自定义） 三方服务（地图、短信、物流、支付、实名认证、天气、监控、……）    提示：可以通过思维导图来进行需求的整理，思维导图上的每个叶子节点都是不可再拆分的功能，而且都是动词。\n 物理模型设计 两个概念：SPU（Standard Product Unit）和SKU（Stock Keeping Unit）。\n SPU：iPhone 6s SKU：iPhone 6s 64G 土豪金  第三方登录 第三方登录是指利用第三方网站（通常是知名社交网站）的账号进行登录验证，比如国内的 QQ、微博，国外的Google、Facebook等，第三方登录大部分都是使用[OAuth]()，它是一个关于授权的开放网络标准，得到了广泛的应用，目前通常使用的是2.0版本。关于OAuth的基础知识，可以阅读阮一峰老师的《理解OAuth 2.0》。\nOAuth 2.0授权流程  用户打开客户端以后，客户端要求用户（资源所有者）给予授权。 用户（资源所有者）同意给予客户端授权。 客户端使用上一步获得的授权，向认证服务器申请访问令牌。 认证服务器对客户端进行认证以后，发放访问令牌。 客户端使用访问令牌向资源服务器申请获取资源。 资源服务器确认访问令牌无误，同意向客户端开放资源。  如果使用微博登录进行接入，其具体步骤可以参考微博开放平台上的“微博登录接入”文档。使用QQ登录进行接入，需要首先注册成为QQ互联开发者并通过审核，具体的步骤可以参考QQ互联上的“接入指南”，具体的步骤可以参考“网站开发流程”。\n 提示：在Gitbook上面有一本名为《Django博客入门》的书以Github为例介绍了第三方账号登录，有兴趣的可以自行阅读。\n 通常电商网站在使用第三方登录时，会要求与网站账号进行绑定或者根据获取到的第三方账号信息（如：手机号）自动完成账号绑定。\n缓存预热和查询缓存 缓存预热 所谓缓存预热，是指在启动服务器时将数据提前加载到缓存中，为此可以在Django应用的apps.py模块中编写AppConfig的子类并重写ready()方法，代码如下所示。\nimport pymysql from django.apps import AppConfig from django.core.cache import cache SELECT_PROVINCE_SQL = \u0026#39;select distid, name from tb_district where pid is null\u0026#39; class CommonConfig(AppConfig): name = \u0026#39;common\u0026#39; def ready(self): conn = pymysql.connect(host=\u0026#39;1.2.3.4\u0026#39;, port=3306, user=\u0026#39;root\u0026#39;, password=\u0026#39;pass\u0026#39;, database=\u0026#39;db\u0026#39;, charset=\u0026#39;utf8\u0026#39;, cursorclass=pymysql.cursors.DictCursor) try: with conn.cursor() as cursor: cursor.execute(SELECT_PROVINCE_SQL) provinces = cursor.fetchall() cache.set(\u0026#39;provinces\u0026#39;, provinces) finally: conn.close() 接下来，还需要在应用的__init__.py中编写下面的代码。\ndefault_app_config = \u0026#39;common.apps.CommonConfig\u0026#39; 或者在项目的settings.py文件中注册应用。\nINSTALLED_APPS = [ ... \u0026#39;common.apps.CommonConfig\u0026#39;, ... ] 查询缓存 自定义装饰器实现查询结果的缓存。\nfrom pickle import dumps from pickle import loads from django.core.cache import caches MODEL_CACHE_KEY = \u0026#39;project:modelcache:%s\u0026#39; def my_model_cache(key, section=\u0026#39;default\u0026#39;, timeout=None): \u0026#34;\u0026#34;\u0026#34;实现模型缓存的装饰器\u0026#34;\u0026#34;\u0026#34; def wrapper1(func): def wrapper2(*args, **kwargs): real_key = \u0026#39;%s:%s\u0026#39; % (MODEL_CACHE_KEY % key, \u0026#39;:\u0026#39;.join(map(str, args))) serialized_data = caches[section].get(real_key) if serialized_data: data = loads(serialized_data) else: data = func(*args, **kwargs) cache.set(real_key, dumps(data), timeout=timeout) return data return wrapper2 return wrapper1@my_model_cache(key=\u0026#39;provinces\u0026#39;) def get_all_provinces(): return list(Province.objects.all()) 购物车实现 问题一：已登录用户的购物车放在哪里？未登录用户的购物车放在哪里？\nclass CartItem(object): \u0026#34;\u0026#34;\u0026#34;购物车中的商品项\u0026#34;\u0026#34;\u0026#34; def __init__(self, sku, amount=1, selected=False): self.sku = sku self.amount = amount self.selected = selected @property def total(self): return self.sku.price * self.amount class ShoppingCart(object): \u0026#34;\u0026#34;\u0026#34;购物车\u0026#34;\u0026#34;\u0026#34; def __init__(self): self.items = {} self.index = 0 def add_item(self, item): if item.sku.id in self.items: self.items[item.sku.id].amount += item.amount else: self.items[item.sku.id] = item def remove_item(self, sku_id): if sku_id in self.items: self.items.remove(sku_id) def clear_all_items(self): self.items.clear() @property def cart_items(self): return self.items.values() @property def cart_total(self): total = 0 for item in self.items.values(): total += item.total return total 已登录用户的购物车可以放在数据库中（可以先在Redis中缓存）；未登录用户的购物车可以保存在Cookie、localStorage或sessionStorage中（减少服务器端内存开销）。\n{ \u0026#39;1001\u0026#39;: {sku: {...}, \u0026#39;amount\u0026#39;: 1, \u0026#39;selected\u0026#39;: True}, \u0026#39;1002\u0026#39;: {sku: {...}, \u0026#39;amount\u0026#39;: 2, \u0026#39;selected\u0026#39;: False}, \u0026#39;1003\u0026#39;: {sku: {...}, \u0026#39;amount\u0026#39;: 3, \u0026#39;selected\u0026#39;: True}, }request.get_signed_cookie(\u0026#39;cart\u0026#39;) cart_base64 = base64.base64encode(pickle.dumps(cart)) response.set_signed_cookie(\u0026#39;cart\u0026#39;, cart_base64) 问题二：用户登录之后，如何合并购物车？（目前电商应用的购物车几乎都做了持久化处理，主要是方便在多个终端之间共享数据）\n集成支付功能 问题一：支付信息如何持久化？（必须保证每笔交易都有记录）\n问题二：如何接入支付宝？（接入其他平台基本类似）\n 蚂蚁金服开放平台。 入驻平台。 开发者中心。 文档中心。 SDK集成 - PYPI链接。 API列表。  配置文件：\nALIPAY_APPID = \u0026#39;......\u0026#39; ALIPAY_URL = \u0026#39;https://openapi.alipaydev.com/gateway.do\u0026#39; ALIPAY_DEBUG = False 获得支付链接（发起支付）：\n# 创建调用支付宝的对象 alipay = AliPay( # 在线创建应用时分配的ID appid=settings.ALIPAY_APPID, app_notify_url=None, # 自己应用的私钥 app_private_key_path=os.path.join( os.path.dirname(os.path.abspath(__file__)), \u0026#39;keys/app_private_key.pem\u0026#39;), # 支付宝的公钥 alipay_public_key_path=os.path.join( os.path.dirname(os.path.abspath(__file__)), \u0026#39;keys/alipay_public_key.pem\u0026#39;), sign_type=\u0026#39;RSA2\u0026#39;, debug=settings.ALIPAY_DEBUG ) # 调用获取支付页面操作 order_info = alipay.api_alipay_trade_page_pay( out_trade_no=\u0026#39;...\u0026#39;, total_amount=\u0026#39;...\u0026#39;, subject=\u0026#39;...\u0026#39;, return_url=\u0026#39;http://...\u0026#39; ) # 生成完整的支付页面URL alipay_url = settings.ALIPAY_URL + \u0026#39;?\u0026#39; + order_info return JsonResponse({\u0026#39;alipay_url\u0026#39;: alipay_url}) 通过上面返回的链接可以进入支付页面，支付完成后会自动跳转回上面代码中设定好的项目页面，在该页面中可以获得订单号（out_trade_no）、支付流水号（trade_no）、交易金额（total_amount）和对应的签名（sign）并请求后端验证和保存交易结果，代码如下所示：\n# 创建调用支付宝的对象 alipay = AliPay( # 在线创建应用时分配的ID appid=settings.ALIPAY_APPID, app_notify_url=None, # 自己应用的私钥 app_private_key_path=os.path.join( os.path.dirname(os.path.abspath(__file__)), \u0026#39;keys/app_private_key.pem\u0026#39;), # 支付宝的公钥 alipay_public_key_path=os.path.join( os.path.dirname(os.path.abspath(__file__)), \u0026#39;keys/alipay_public_key.pem\u0026#39;), sign_type=\u0026#39;RSA2\u0026#39;, debug=settings.ALIPAY_DEBUG ) # 请求参数（假设是POST请求）中包括订单号、支付流水号、交易金额和签名 params = request.POST.dict() # 调用验证操作 if alipay.verify(params, params.pop(\u0026#39;sign\u0026#39;)): # 对交易进行持久化操作 支付宝的支付API还提供了交易查询、交易结算、退款、退款查询等一系列的接口，可以根据业务需要进行调用，此处不再进行赘述。\n秒杀和超卖  秒杀：秒杀是通常意味着要在很短的时间处理极高的并发，系统在短时间需要承受平时百倍以上的流量，因此秒杀架构是一个比较复杂的问题，其核心思路是流量控制和性能优化，需要从前端（通过JavaScript实现倒计时、避免重复提交和限制频繁刷新）到后台各个环节的配合。流量控制主要是限制只有少部分流量进入服务后端（毕竟最终只有少部分用户能够秒杀成功），同时在物理架构上使用缓存（一方面是因为读操作多写操作少；另外可以将库存放在Redis中，利用DECR原语实现减库存；同时也可以利用Redis来进行限流，道理跟限制频繁发送手机验证码是一样的）和消息队列（消息队列最为重要的作用就是“削峰”和“上下游节点解耦合”）来进行优化；此外还要采用无状态服务设计，这样才便于进行水平扩展（通过增加设备来为系统扩容）。 超卖现象：比如某商品的库存为1，此时用户1和用户2并发购买该商品，用户1提交订单后该商品的库存被修改为0，而此时用户2并不知道的情况下提交订单，该商品的库存再次被修改为-1这就是超卖现象。解决超卖现象有三种常见的思路：  悲观锁控制：查询商品数量的时候就用select ... for update对数据加锁，这样的话用户1查询库存时，用户2因无法读取库存数量被阻塞，直到用户1提交或者回滚了更新库存的操作后才能继续，从而解决了超卖问题。但是这种做法对并发访问量很高的商品来说性能太过糟糕，实际开发中可以在库存小于某个值时才考虑加锁，但是总的来说这种做法不太可取。 乐观锁控制：查询商品数量不用加锁，更新库存的时候设定商品数量必须与之前查询数量相同才能更新，否则说明其他事务已经更新了库存，必须重新发出请求。这种做法要求事务隔离级别为可重复读，否则仍然会产生问题。 尝试减库存：将上面的查询（select）和更新（update）操作合并为一条SQL操作，更新库存的时候，在where筛选条件中加上库存\u0026gt;=购买数量或库存-购买数量\u0026gt;=0的条件。    提示：有兴趣的可以自己在知乎上看看关于这类问题的讨论。\n 静态资源管理 静态资源的管理可以自己架设文件服务器或者分布式文件服务器（FastDFS），但是一般的项目中没有必要这样做而且效果未必是最好的，我们建议使用云存储服务来管理网站的静态资源，国内外的云服务提供商如亚马逊、阿里云、腾讯云、七牛、LeanCloud、Bmob等都提供了非常优质的云存储服务，而且价格也是一般公司可以接受的。可以参考《在阿里云OSS上托管静态网站》一文来完成对网站静态资源的管理，代码相关的内容可以参考阿里云的对象存储 OSS开发人员指南。\n全文检索 方案选择  使用数据库的模糊查询功能 - 效率低，每次需要全表扫描，不支持分词。 使用数据库的全文检索功能 - MySQL 5.6以前只适用于MyISAM引擎，检索操作和其他的DML操作耦合在数据库中，可能导致检索操作非常缓慢，数据量达到百万级性能显著下降，查询时间很长。 使用开源搜索引擎 - 索引数据和原始数据分离，可以使用ElasticSearch或Solr来提供外置索引服务，如果不考虑高并发的全文检索需求，纯Python的Whoosh也可以考虑。  ElasticSearch ElasticSearch既是一个分布式文档数据库又是一个高可扩展的开源全文搜索和分析引擎，它允许存储、搜索和分析大量的数据，并且这个过程是近实时的。它通常被用作底层引擎和技术，为复杂的搜索功能和要求提供动力，大家熟知的维基百科、Stack-Overflow、Github都使用了ElasticSearch。\nElasticSearch的底层是开源搜索引擎Lucene，但是直接用Lucene会非常麻烦，必须自己编写代码去调用它的接口而且只支持Java语言。ElasticSearch相当于对Lucene进行了一次全面的封装，提供了REST风格的API接口，通过基于HTTP协议的访问方式屏蔽了编程语言的差异。ElasticSearch会为数据构建倒排索引，但是ElasticSearch内置的分词器对中文分词的支持几乎为零，因此需要通过安装elasticsearch-analysis-ik插件来提供中文分词服务。\nElasticSearch的安装和配置可以参考《ElasticSearch之Docker安装》。除了ElasticSearch之外，也可以使用Solr、Whoosh等来提供搜索引擎服务，基本上Django项目中可以考虑如下两套方案：\n haystack（django-haystack / drf-haystack） + whoosh + Jieba haystack （django-haystack / drf-haystack）+ elasticsearch  ####安装和使用ElasticSearch\n 使用Docker安装ElasticSearch。\ndocker pull elasticsearch:6.5.3 docker run -d -p 9200:9200 -p 9300:9300 -e \u0026#34;discovery.type=single-node\u0026#34; -e ES_JAVA_OPTS=\u0026#34;-Xms512m -Xmx512m\u0026#34; --name es elasticsearch:6.5.3   说明：上面创建容器时通过-e参数指定了使用单机模式和Java虚拟机最小最大可用堆空间的大小，堆空间大小可以根据服务器实际能够提供给ElasticSearch的内存大小来决定，默认为2G。\n  创建数据库。  请求：PUT - http://1.2.3.4:9200/demo\n响应：\n```JSON  { \u0026ldquo;acknowledged\u0026rdquo;: true, \u0026ldquo;shards_acknowledged\u0026rdquo;: true, \u0026ldquo;index\u0026rdquo;: \u0026ldquo;demo\u0026rdquo; } ```\n 查看创建的数据库。  请求：GET - http://1.2.3.4:9200/demo\n响应：\n{ \u0026#34;demo\u0026#34;: { \u0026#34;aliases\u0026#34;: {}, \u0026#34;mappings\u0026#34;: {}, \u0026#34;settings\u0026#34;: { \u0026#34;index\u0026#34;: { \u0026#34;creation_date\u0026#34;: \u0026#34;1552213970199\u0026#34;, \u0026#34;number_of_shards\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;number_of_replicas\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;uuid\u0026#34;: \u0026#34;ny3rCn10SAmCsqW6xPP1gw\u0026#34;, \u0026#34;version\u0026#34;: { \u0026#34;created\u0026#34;: \u0026#34;6050399\u0026#34; }, \u0026#34;provided_name\u0026#34;: \u0026#34;demo\u0026#34; } } } }  插入数据。  请求：POST - http://1.2.3.4:9200/demo/goods/1/\n请求头：Content-Type: application/json\n参数：\n{ \u0026#34;no\u0026#34;: \u0026#34;5089253\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Apple iPhone X (A1865) 64GB 深空灰色 移动联通电信4G手机\u0026#34;, \u0026#34;brand\u0026#34;: \u0026#34;Apple\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Apple iPhone X\u0026#34;, \u0026#34;product\u0026#34;: \u0026#34;中国大陆\u0026#34;, \u0026#34;resolution\u0026#34;: \u0026#34;2436 x 1125\u0026#34;, \u0026#34;intro\u0026#34;: \u0026#34;一直以来，Apple都心存一个设想，期待能够打造出这样一部iPhone：它有整面屏幕，能让你在使用时，完全沉浸其中，仿佛忘了它的存在。它是如此智能，哪怕轻轻一瞥，都能得到它心有灵犀的回应。而这个设想，终于随着iPhone X的到来成为了现实。现在，就跟未来见个面吧。\u0026#34; } 响应：\n{ \u0026#34;_index\u0026#34;: \u0026#34;demo\u0026#34;, \u0026#34;_type\u0026#34;: \u0026#34;goods\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;_version\u0026#34;: 4, \u0026#34;result\u0026#34;: \u0026#34;created\u0026#34;, \u0026#34;_shards\u0026#34;: { \u0026#34;total\u0026#34;: 2, \u0026#34;successful\u0026#34;: 1, \u0026#34;failed\u0026#34;: 0 }, \u0026#34;_seq_no\u0026#34;: 3, \u0026#34;_primary_term\u0026#34;: 1 }  删除数据。  请求：DELETE - http://1.2.3.4:9200/demo/goods/1/\n响应：\n{ \u0026#34;_index\u0026#34;: \u0026#34;demo\u0026#34;, \u0026#34;_type\u0026#34;: \u0026#34;goods\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;_version\u0026#34;: 2, \u0026#34;result\u0026#34;: \u0026#34;deleted\u0026#34;, \u0026#34;_shards\u0026#34;: { \u0026#34;total\u0026#34;: 2, \u0026#34;successful\u0026#34;: 1, \u0026#34;failed\u0026#34;: 0 }, \u0026#34;_seq_no\u0026#34;: 1, \u0026#34;_primary_term\u0026#34;: 1 }  更新数据。  请求：PUT - http://1.2.3.4:9200/demo/goods/1/_update\n请求头：Content-Type: application/json\n参数：\n{ \u0026#34;doc\u0026#34;: { \u0026#34;no\u0026#34;: \u0026#34;5089253\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Apple iPhone X (A1865) 64GB 深空灰色 移动联通电信4G手机\u0026#34;, \u0026#34;brand\u0026#34;: \u0026#34;Apple(苹果)\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Apple iPhone X\u0026#34;, \u0026#34;product\u0026#34;: \u0026#34;美国\u0026#34;, \u0026#34;resolution\u0026#34;: \u0026#34;2436 x 1125\u0026#34;, \u0026#34;intro\u0026#34;: \u0026#34;一直以来，Apple都心存一个设想，期待能够打造出这样一部iPhone：它有整面屏幕，能让你在使用时，完全沉浸其中，仿佛忘了它的存在。它是如此智能，哪怕轻轻一瞥，都能得到它心有灵犀的回应。而这个设想，终于随着iPhone X的到来成为了现实。现在，就跟未来见个面吧。\u0026#34; } } 响应：\n{ \u0026#34;_index\u0026#34;: \u0026#34;demo\u0026#34;, \u0026#34;_type\u0026#34;: \u0026#34;goods\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;_version\u0026#34;: 10, \u0026#34;result\u0026#34;: \u0026#34;updated\u0026#34;, \u0026#34;_shards\u0026#34;: { \u0026#34;total\u0026#34;: 2, \u0026#34;successful\u0026#34;: 1, \u0026#34;failed\u0026#34;: 0 }, \u0026#34;_seq_no\u0026#34;: 9, \u0026#34;_primary_term\u0026#34;: 1 }  查询数据。  请求：GET - http://1.2.3.4:9200/demo/goods/1/\n响应：\n{ \u0026#34;_index\u0026#34;: \u0026#34;demo\u0026#34;, \u0026#34;_type\u0026#34;: \u0026#34;goods\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;_version\u0026#34;: 10, \u0026#34;found\u0026#34;: true, \u0026#34;_source\u0026#34;: { \u0026#34;doc\u0026#34;: { \u0026#34;no\u0026#34;: \u0026#34;5089253\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Apple iPhone X (A1865) 64GB 深空灰色 移动联通电信4G手机\u0026#34;, \u0026#34;brand\u0026#34;: \u0026#34;Apple(苹果)\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Apple iPhone X\u0026#34;, \u0026#34;product\u0026#34;: \u0026#34;美国\u0026#34;, \u0026#34;resolution\u0026#34;: \u0026#34;2436 x 1125\u0026#34;, \u0026#34;intro\u0026#34;: \u0026#34;一直以来，Apple都心存一个设想，期待能够打造出这样一部iPhone：它有整面屏幕，能让你在使用时，完全沉浸其中，仿佛忘了它的存在。它是如此智能，哪怕轻轻一瞥，都能得到它心有灵犀的回应。而这个设想，终于随着iPhone X的到来成为了现实。现在，就跟未来见个面吧。\u0026#34; } } } 配置中文分词和拼音插件  进入Docker容器的plugins目录。\ndocker exec -it es /bin/bash 下载和ElasticSearch版本对应的ik和pinyin插件。\ncd plugins/ mkdir ik cd ik wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.5.3/elasticsearch-analysis-ik-6.5.3.zip unzip elasticsearch-analysis-ik-6.5.3.zip rm -f elasticsearch-analysis-ik-6.5.3.zip cd .. mkdir pinyin cd pinyin wget https://github.com/medcl/elasticsearch-analysis-pinyin/releases/download/v6.5.3/elasticsearch-analysis-pinyin-6.5.3.zip unzip elasticsearch-analysis-pinyin-6.5.3.zip rm -f elasticsearch-analysis-pinyin-6.5.3.zip 退出容器，重启ElasticSearch。\ndocker restart es 测试中文分词效果。\n  请求：POST - http://1.2.3.4:9200/_analyze\n请求头：Content-Type: application/json\n参数：\n{ \u0026#34;analyzer\u0026#34;: \u0026#34;ik_smart\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;中国男足在2022年卡塔尔世界杯预选赛中勇夺小组最后一名\u0026#34; } 响应：\n{ \u0026#34;tokens\u0026#34;: [ { \u0026#34;token\u0026#34;: \u0026#34;中国\u0026#34;, \u0026#34;start_offset\u0026#34;: 0, \u0026#34;end_offset\u0026#34;: 2, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 0 }, { \u0026#34;token\u0026#34;: \u0026#34;男足\u0026#34;, \u0026#34;start_offset\u0026#34;: 2, \u0026#34;end_offset\u0026#34;: 4, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 1 }, { \u0026#34;token\u0026#34;: \u0026#34;在\u0026#34;, \u0026#34;start_offset\u0026#34;: 4, \u0026#34;end_offset\u0026#34;: 5, \u0026#34;type\u0026#34;: \u0026#34;CN_CHAR\u0026#34;, \u0026#34;position\u0026#34;: 2 }, { \u0026#34;token\u0026#34;: \u0026#34;2022年\u0026#34;, \u0026#34;start_offset\u0026#34;: 5, \u0026#34;end_offset\u0026#34;: 10, \u0026#34;type\u0026#34;: \u0026#34;TYPE_CQUAN\u0026#34;, \u0026#34;position\u0026#34;: 3 }, { \u0026#34;token\u0026#34;: \u0026#34;卡塔尔\u0026#34;, \u0026#34;start_offset\u0026#34;: 10, \u0026#34;end_offset\u0026#34;: 13, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 4 }, { \u0026#34;token\u0026#34;: \u0026#34;世界杯\u0026#34;, \u0026#34;start_offset\u0026#34;: 13, \u0026#34;end_offset\u0026#34;: 16, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 5 }, { \u0026#34;token\u0026#34;: \u0026#34;预选赛\u0026#34;, \u0026#34;start_offset\u0026#34;: 16, \u0026#34;end_offset\u0026#34;: 19, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 6 }, { \u0026#34;token\u0026#34;: \u0026#34;中\u0026#34;, \u0026#34;start_offset\u0026#34;: 19, \u0026#34;end_offset\u0026#34;: 20, \u0026#34;type\u0026#34;: \u0026#34;CN_CHAR\u0026#34;, \u0026#34;position\u0026#34;: 7 }, { \u0026#34;token\u0026#34;: \u0026#34;勇夺\u0026#34;, \u0026#34;start_offset\u0026#34;: 20, \u0026#34;end_offset\u0026#34;: 22, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 8 }, { \u0026#34;token\u0026#34;: \u0026#34;小组\u0026#34;, \u0026#34;start_offset\u0026#34;: 22, \u0026#34;end_offset\u0026#34;: 24, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 9 }, { \u0026#34;token\u0026#34;: \u0026#34;最后\u0026#34;, \u0026#34;start_offset\u0026#34;: 24, \u0026#34;end_offset\u0026#34;: 26, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 10 }, { \u0026#34;token\u0026#34;: \u0026#34;一名\u0026#34;, \u0026#34;start_offset\u0026#34;: 26, \u0026#34;end_offset\u0026#34;: 28, \u0026#34;type\u0026#34;: \u0026#34;CN_WORD\u0026#34;, \u0026#34;position\u0026#34;: 11 } ] }  测试拼音分词效果。  请求：POST - http://1.2.3.4:9200/_analyze\n请求头：Content-Type: application/json\n参数：\n 响应：\n{ \u0026#34;tokens\u0026#34;: [ { \u0026#34;token\u0026#34;: \u0026#34;zhang\u0026#34;, \u0026#34;start_offset\u0026#34;: 0, \u0026#34;end_offset\u0026#34;: 0, \u0026#34;type\u0026#34;: \u0026#34;word\u0026#34;, \u0026#34;position\u0026#34;: 0 }, { \u0026#34;token\u0026#34;: \u0026#34;zxy\u0026#34;, \u0026#34;start_offset\u0026#34;: 0, \u0026#34;end_offset\u0026#34;: 0, \u0026#34;type\u0026#34;: \u0026#34;word\u0026#34;, \u0026#34;position\u0026#34;: 0 }, { \u0026#34;token\u0026#34;: \u0026#34;xue\u0026#34;, \u0026#34;start_offset\u0026#34;: 0, \u0026#34;end_offset\u0026#34;: 0, \u0026#34;type\u0026#34;: \u0026#34;word\u0026#34;, \u0026#34;position\u0026#34;: 1 }, { \u0026#34;token\u0026#34;: \u0026#34;you\u0026#34;, \u0026#34;start_offset\u0026#34;: 0, \u0026#34;end_offset\u0026#34;: 0, \u0026#34;type\u0026#34;: \u0026#34;word\u0026#34;, \u0026#34;position\u0026#34;: 2 } ] } 全文检索功能 可以通过GET或者POST请求进行搜索，下面演示了搜索有“未来”关键词商品。\n GET - http://120.77.222.217:9200/demo/goods/_search?q=未来   注意：URL中的中文应该要处理成百分号编码。\n { \u0026#34;took\u0026#34;: 19, \u0026#34;timed_out\u0026#34;: false, \u0026#34;_shards\u0026#34;: { \u0026#34;total\u0026#34;: 5, \u0026#34;successful\u0026#34;: 5, \u0026#34;skipped\u0026#34;: 0, \u0026#34;failed\u0026#34;: 0 }, \u0026#34;hits\u0026#34;: { \u0026#34;total\u0026#34;: 2, \u0026#34;max_score\u0026#34;: 0.73975396, \u0026#34;hits\u0026#34;: [ { \u0026#34;_index\u0026#34;: \u0026#34;demo\u0026#34;, \u0026#34;_type\u0026#34;: \u0026#34;goods\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;_score\u0026#34;: 0.73975396, \u0026#34;_source\u0026#34;: { \u0026#34;doc\u0026#34;: { \u0026#34;no\u0026#34;: \u0026#34;5089253\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Apple iPhone X (A1865) 64GB 深空灰色 移动联通电信4G手机\u0026#34;, \u0026#34;brand\u0026#34;: \u0026#34;Apple(苹果)\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Apple iPhone X\u0026#34;, \u0026#34;product\u0026#34;: \u0026#34;美国\u0026#34;, \u0026#34;resolution\u0026#34;: \u0026#34;2436*1125\u0026#34;, \u0026#34;intro\u0026#34;: \u0026#34;一直以来，Apple都心存一个设想，期待能够打造出这样一部iPhone：它有整面屏幕，能让你在使用时，完全沉浸其中，仿佛忘了它的存在。它是如此智能，哪怕轻轻一瞥，都能得到它心有灵犀的回应。而这个设想，终于随着iPhone X的到来成为了现实。现在，就跟未来见个面吧。\u0026#34; } } }, { \u0026#34;_index\u0026#34;: \u0026#34;demo\u0026#34;, \u0026#34;_type\u0026#34;: \u0026#34;goods\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;_score\u0026#34;: 0.68324494, \u0026#34;_source\u0026#34;: { \u0026#34;no\u0026#34;: \u0026#34;42417956432\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;小米9 透明尊享版 手机 透明尊享 全网通(12GB + 256GB)\u0026#34;, \u0026#34;brand\u0026#34;: \u0026#34;小米（MI）\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;小米（MI）小米9透明\u0026#34;, \u0026#34;product\u0026#34;: \u0026#34;中国大陆\u0026#34;, \u0026#34;resolution\u0026#34;: \u0026#34;2340*1080\u0026#34;, \u0026#34;intro\u0026#34;: \u0026#34;全面透明机身，独特科幻机甲风，来自未来的设计。\u0026#34; } } ] } } URL中可用的搜索参数如下表所示：\n| 参数 | 说明 | | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- | | q | 查询字符串 | | analyzer | 分析查询字符串使用的分词器 | | analyze_wildcard | 通配符或者前缀查询是否被分析，默认为false | | default_operator | 多个条件之间的关系，默认为OR，可以修改为AND | | explain | 在返回的结果中包含评分机制的解释 | | fields | 只返回索引中指定的列，多个列中间用逗号隔开 | | sort | 排序参考的字段，可以用:asc和:desc来指定升序和降序 | | timeout | 超时时间 | | from | 匹配结果的开始值，默认为0 | | size | 匹配结果的条数，默认为10 |\n POST - http://120.77.222.217:9200/demo/goods/_search  请求头：Content-Type: application/json\n参数：\n 响应：\n Django对接ElasticSearch Python对接ElasticSearch的第三方库是HayStack，在Django项目中可以使用django-haystack，通过HayStack可以在不修改代码对接多种搜索引擎服务。\npip install django-haystack elasticsearch 配置文件：\nINSTALLED_APPS = [ ... \u0026#39;haystack\u0026#39;, ... ] HAYSTACK_CONNECTIONS = { \u0026#39;default\u0026#39;: { # 引擎配置 \u0026#39;ENGINE\u0026#39;: \u0026#39;haystack.backends.elasticsearch_backend.ElasticsearchSearchEngine\u0026#39;, # 搜索引擎服务的URL \u0026#39;URL\u0026#39;: \u0026#39;http://1.2.3.4:9200\u0026#39;, # 索引库的名称 \u0026#39;INDEX_NAME\u0026#39;: \u0026#39;goods\u0026#39;, }, } # 添加/删除/更新数据时自动生成索引 HAYSTACK_SIGNAL_PROCESSOR = \u0026#39;haystack.signals.RealtimeSignalProcessor\u0026#39; 索引类：\nfrom haystack import indexes class GoodsIndex(indexes.SearchIndex, indexes.Indexable): text = indexes.CharField(document=True, use_template=True) def get_model(self): return Goods def index_queryset(self, using=None): return self.get_model().objects.all() 编辑text字段的模板（需要放在templates/search/indexes/demo/goods_text.txt）：\n{{object.title}} {{object.intro}}  配置URL：\nurlpatterns = [ # ... url(\u0026#39;search/\u0026#39;, include(\u0026#39;haystack.urls\u0026#39;)), ] 生成初始索引：\npython manage.py rebuild_index  说明：可以参考《Django Haystack 全文检索与关键词高亮》一文来更深入的了解基于Haystack的全文检索操作。\n "},{"idx":89,"href":"/python100days/docs/Day91-100/98-%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E4%B8%8A%E7%BA%BF%E5%92%8C%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/","title":"98 项目部署上线和性能调优","content":" 项目部署上线指南 准备上线  上线前的检查工作。\npython manage.py check --deploy 将DEBUG设置为False并配置ALLOWED_HOSTS。\nDEBUG = False ALLOWED_HOSTS = [\u0026#39;*\u0026#39;] 安全相关的配置。\n# 保持HTTPS连接的时间 SECURE_HSTS_SECONDS = 3600 SECURE_HSTS_INCLUDE_SUBDOMAINS = True SECURE_HSTS_PRELOAD = True # 自动重定向到安全连接 SECURE_SSL_REDIRECT = True # 避免浏览器自作聪明推断内容类型 SECURE_CONTENT_TYPE_NOSNIFF = True # 避免跨站脚本攻击 SECURE_BROWSER_XSS_FILTER = True # COOKIE只能通过HTTPS进行传输 SESSION_COOKIE_SECURE = True CSRF_COOKIE_SECURE = True # 防止点击劫持攻击手段 - 修改HTTP协议响应头 # 当前网站是不允许使用\u0026lt;iframe\u0026gt;标签进行加载的 X_FRAME_OPTIONS = \u0026#39;DENY\u0026#39; 敏感信息放到环境变量或文件中。\nSECRET_KEY = os.environ[\u0026#39;SECRET_KEY\u0026#39;] DB_USER = os.environ[\u0026#39;DB_USER\u0026#39;] DB_PASS = os.environ[\u0026#39;DB_PASS\u0026#39;] REDIS_AUTH = os.environ[\u0026#39;REDIS_AUTH\u0026#39;]  更新服务器Python环境到3.x  说明：如果需要清除之前的安装，就删除对应的文件和文件夹即可\n  安装底层依赖库。\nyum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel libdb4-devel libpcap-devel xz-devel libffi-devel 下载Python源代码。\nwget https://www.python.org/ftp/python/3.7.1/Python-3.7.1.tar.xz 解压缩和解归档。\nxz -d Python-3.7.1.tar.xz tar -xvf Python-3.7.1.tar 执行配置生成Makefile（构建文件）。\ncd Python-3.7.1 ./configure --prefix=/usr/local/python37 --enable-optimizations 构建和安装。\nmake \u0026amp;\u0026amp; make install 配置PATH环境变量（用户或系统环境变量）并激活。\nvim ~/.bash_profile vim /etc/profile... 此处省略上面的代码... export PATH=$PATH:/usr/local/python37/bin ... 此处省略下面的代码...source ~/.bash_profile source /etc/profile 注册软链接（符号链接）- 这一步不是必须的，但通常会比较有用。\nln -s /usr/local/python37/bin/python3 /usr/bin/python3 测试Python环境是否更新成功（安装Python 3一定不能破坏原来的Python 2）。\npython3 --version python --version  项目目录结构 假设项目文件夹为project，下面的五个子目录分别是：code、conf、logs、stat和venv分别用来保存项目的代码、配置文件、日志文件、静态资源和虚拟环境。其中，conf目录下的子目录cert中保存了配置HTTPS需要使用的证书和密钥；code目录下的项目代码可以通过版本控制工具从代码仓库中检出；虚拟环境可以通过工具（如：venv、virtualenv、pyenv等）进行创建。\nproject ├── code │ └── fangtx │ ├── api │ ├── common │ ├── fangtx │ ├── forum │ ├── rent │ ├── user │ ├── manage.py │ ├── README.md │ ├── static │ └── templates ├── conf │ ├── cert │ │ ├── 214915882850706.key │ │ └── 214915882850706.pem │ ├── nginx.conf │ └── uwsgi.ini ├── logs │ ├── access.log │ ├── error.log │ └── uwsgi.log ├── stat │ └── css │ └── images │ └── js └── venv ├── bin │ ├── activate │ ├── activate.csh │ ├── activate.fish │ ├── celery │ ├── celerybeat │ ├── celeryd │ ├── celeryd-multi │ ├── coverage │ ├── coverage3 │ ├── coverage-3.7 │ ├── django-admin │ ├── django-admin.py │ ├── easy_install │ ├── easy_install-3.7 │ ├── pip │ ├── pip3 │ ├── pip3.7 │ ├── __pycache__ │ ├── pyrsa-decrypt │ ├── pyrsa-decrypt-bigfile │ ├── pyrsa-encrypt │ ├── pyrsa-encrypt-bigfile │ ├── pyrsa-keygen │ ├── pyrsa-priv2pub │ ├── pyrsa-sign │ ├── pyrsa-verify │ ├── python -\u0026gt; python3 │ ├── python3 -\u0026gt; /usr/bin/python3 │ └── uwsgi ├── include ├── lib │ └── python3.7 ├── lib64 -\u0026gt; lib ├── pip-selfcheck.json └── pyvenv.cfg  下面以阿里云为例，简单说明如何为项目注册域名、解析域名以及购买权威机构颁发的证书。\n 注册域名。   域名备案。   域名解析。   购买证书。  可以使用类似于sftp的工具将证书上传到conf/cert目录，然后使用git克隆项目代码到code目录。\ncd code git clone \u0026lt;url\u0026gt; 回到项目目录，创建并激活虚拟环境。\npython3 -m venv venv source venv/bin/activate 重建项目依赖项。\npip install -r code/teamproject/requirements.txt uWSGI的配置  安装uWSGI。\npip install uwsgi 修改uWSGI的配置文件（/root/project/conf/uwsgi.ini）。\n[uwsgi] # 配置前导路径 base=/root/project # 配置项目名称 name=teamproject # 守护进程 master=true # 进程个数 processes=4 # 虚拟环境 pythonhome=%(base)/venv # 项目地址 chdir=%(base)/code/%(name) # 指定python解释器 pythonpath=%(pythonhome)/bin/python # 指定uwsgi文件 module=%(name).wsgi # 通信的地址和端口(自己服务器的IP地址和端口) socket=172.18.61.250:8000 # 日志文件地址 logto=%(base)/logs/uwsgi.log   说明：可以先将“通信的地址和端口”项等号前面改为http来进行测试，如果没有问题再改回 成socket，然后通过Nginx来实现项目的“动静分离”（静态资源交给Nginx处理，动态内容交给 uWSGI处理）。按照下面的方式可以启动uWSGI服务器。\n  启动服务器。\nuwsgi --ini conf/uwsgi.ini  Nginx的配置  安装Nginx。\nyum -y install nginx 修改全局配置文件（/etc/nginx/nginx.conf）。\n# 配置用户 user root; # 工作进程数(建议跟CPU的核数量一致) worker_processes auto; # 错误日志 error_log /var/log/nginx/error.log; # 进程文件 pid /run/nginx.pid; # 包含其他的配置 include /usr/share/nginx/modules/*.conf; # 工作模式(多路IO复用方式)和连接上限 events { use epoll; worker_connections 1024; } # HTTP服务器相关配置 http { # 日志格式  log_format main \u0026#39;$remote_addr - $remote_user [$time_local] \u0026#34;$request\u0026#34; \u0026#39; \u0026#39;$status $body_bytes_sent \u0026#34;$http_referer\u0026#34; \u0026#39; \u0026#39;\u0026#34;$http_user_agent\u0026#34; \u0026#34;$http_x_forwarded_for\u0026#34;\u0026#39;; # 访问日志  access_log /var/log/nginx/access.log main; # 开启高效文件传输模式  sendfile on; # 用sendfile传输文件时有利于改善性能  tcp_nopush on; # 禁用Nagle来解决交互性问题  tcp_nodelay on; # 客户端保持连接时间  keepalive_timeout 30; types_hash_max_size 2048; # 包含MIME类型的配置  include /etc/nginx/mime.types; # 默认使用二进制流格式  default_type application/octet-stream; # 包含其他配置文件  include /etc/nginx/conf.d/*.conf; # 包含项目的Nginx配置文件  include /root/project/conf/*.conf; } 编辑局部配置文件（/root/project/conf/nginx.conf）。\nserver { listen 80; server_name _; access_log /root/project/logs/access.log; error_log /root/project/logs/error.log; location / { include uwsgi_params; uwsgi_pass 172.18.61.250:8000; } location /static/ { alias /root/project/stat/; expires 30d; } } server { listen 443; server_name _; ssl on; access_log /root/project/logs/access.log; error_log /root/project/logs/error.log; ssl_certificate /root/project/conf/cert/214915882850706.pem; ssl_certificate_key /root/project/conf/cert/214915882850706.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / { include uwsgi_params; uwsgi_pass 172.18.61.250:8000; } location /static/ { alias /root/project/static/; expires 30d; } } 到此为止，我们可以启动Nginx来访问我们的应用程序，HTTP和HTTPS都是没有问题的，如果Nginx已经运行，在修改配置文件后，我们可以用下面的命令重新启动Nginx。\n 重启Nginx服务器。\nnginx -s reload 或\nsystemctl restart nginx   说明：可以对Django项目使用python manage.py collectstatic命令将静态资源收集到指定目录下，要做到这点只需要在项目的配置文件settings.py中添加STATIC_ROOT配置即可。\n 负载均衡配置 下面的配置中我们使用Nginx实现负载均衡，为另外的三个Nginx服务器（通过Docker创建）提供反向代理服务。\ndocker run -d -p 801:80 --name nginx1 nginx:latest docker run -d -p 802:80 --name nginx2 nginx:latest docker run -d -p 803:80 --name nginx3 nginx:latestuser root; worker_processes auto; error_log /var/log/nginx/error.log; pid /run/nginx.pid; include /usr/share/nginx/modules/*.conf; events { worker_connections 1024; } # 为HTTP服务配置负载均衡 http { upstream fangtx { server 172.18.61.250:801 weight=4; server 172.18.61.250:802 weight=2; server 172.18.61.250:803 weight=2; } server { listen 80 default_server; listen [::]:80 default_server; listen 443 ssl; listen [::]:443 ssl; ssl on; access_log /root/project/logs/access.log; error_log /root/project/logs/error.log; ssl_certificate /root/project/conf/cert/214915882850706.pem; ssl_certificate_key /root/project/conf/cert/214915882850706.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / { proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_buffering off; proxy_pass http://fangtx; } } }  说明：Nginx在配置负载均衡时，默认使用WRR（加权轮询算法），除此之外还支持ip_hash、fair（需要安装upstream_fair模块）和url_hash算法。此外，在配置upstream模块时可以指定服务器的状态值，包括：backup（备份机器，其他服务器不可用时才将请求分配到该机器）、down、fail_timeout（请求失败达到max_fails后的暂停服务时间）、max_fails（允许请求失败的次数）和weight（轮询的权重）。\n Keepalived 当使用Nginx进行负载均衡配置时，要考虑负载均衡服务器宕机的情况。为此可以使用Keepalived来实现负载均衡主机和备机的热切换，从而保证系统的高可用性。Keepalived的配置还是比较复杂，通常由专门做运维的人进行配置，一个基本的配置可以参照《Keepalived的配置和使用》。\nMySQL主从复制 下面还是基于Docker来演示如何配置MySQL主从复制。我们事先准备好MySQL的配置文件以及保存MySQL数据和运行日志的目录，然后通过Docker的数据卷映射来指定容器的配置、数据和日志文件的位置。\nroot └── mysql ├── master │ ├── conf |\t└── data └── slave-1 |\t├── conf |\t└── data └── slave-2 |\t├── conf |\t└── data └── slave-3 ├── conf └── data  MySQL的配置文件（master和slave的配置文件需要不同的server-id）。\n[mysqld] pid-file=/var/run/mysqld/mysqld.pid socket=/var/run/mysqld/mysqld.sock datadir=/var/lib/mysql log-error=/var/log/mysql/error.log server-id=1 log-bin=/var/log/mysql/mysql-bin.log expire_logs_days=30 max_binlog_size=256M symbolic-links=0 # slow_query_log=ON # slow_query_log_file=/var/log/mysql/slow.log # long_query_time=1  创建和配置master。\ndocker run -d -p 3306:3306 --name mysql-master \\ -v /root/mysql/master/conf:/etc/mysql/mysql.conf.d \\ -v /root/mysql/master/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 docker exec -it mysql-master /bin/bashmysql -u root -p Enter password: Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 1 Server version: 5.7.23-log MySQL Community Server (GPL) Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type \u0026#39;help;\u0026#39; or \u0026#39;\\h\u0026#39; for help. Type \u0026#39;\\c\u0026#39; to clear the current input statement. mysql\u0026gt; grant replication slave on *.* to \u0026#39;slave\u0026#39;@\u0026#39;%\u0026#39; identified by \u0026#39;iamslave\u0026#39;; Query OK, 0 rows affected, 1 warning (0.00 sec) mysql\u0026gt; flush privileges; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; show master status; +------------------+----------+--------------+------------------+-------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +------------------+----------+--------------+------------------+-------------------+ | mysql-bin.000003 | 590 | | | | +------------------+----------+--------------+------------------+-------------------+ 1 row in set (0.00 sec) mysql\u0026gt; quit Bye exit  上面创建Docker容器时使用的-v参数（--volume）表示映射数据卷，冒号前是宿主机的目录，冒号后是容器中的目录，这样相当于将宿主机中的目录挂载到了容器中。\n 创建和配置slave。\ndocker run -d -p 3308:3306 --name mysql-slave-1 \\ -v /root/mysql/slave-1/conf:/etc/mysql/mysql.conf.d \\ -v /root/mysql/slave-1/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=123456 \\ --link mysql-master:mysql-master mysql:5.7 docker run -d -p 3309:3306 --name mysql-slave-2 \\ -v /root/mysql/slave-2/conf:/etc/mysql/mysql.conf.d \\ -v /root/mysql/slave-2/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=123456 \\ --link mysql-master:mysql-master mysql:5.7 docker run -d -p 3310:3306 --name mysql-slave-3 \\ -v /root/mysql/slave-3/conf:/etc/mysql/mysql.conf.d \\ -v /root/mysql/slave-3/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=123456 \\ --link mysql-master:mysql-master mysql:5.7 docker exec -it mysql-slave-1 /bin/bashmysql -u root -p Enter password: Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 2 Server version: 5.7.23-log MySQL Community Server (GPL) Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type \u0026#39;help;\u0026#39; or \u0026#39;\\h\u0026#39; for help. Type \u0026#39;\\c\u0026#39; to clear the current input statement. mysql\u0026gt; reset slave; Query OK, 0 rows affected (0.02 sec) mysql\u0026gt; change master to master_host=\u0026#39;mysql-master\u0026#39;, master_user=\u0026#39;slave\u0026#39;, master_password=\u0026#39;iamslave\u0026#39;, master_log_file=\u0026#39;mysql-bin.000003\u0026#39;, master_log_pos=590; Query OK, 0 rows affected, 2 warnings (0.03 sec) mysql\u0026gt; start slave; Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; show slave status\\G *************************** 1. row *************************** Slave_IO_State: Waiting for master to send event Master_Host: mysql57 Master_User: slave Master_Port: 3306 Connect_Retry: 60 Master_Log_File: mysql-bin.000001 Read_Master_Log_Pos: 590 Relay_Log_File: f352f05eb9d0-relay-bin.000002 Relay_Log_Pos: 320 Relay_Master_Log_File: mysql-bin.000001 Slave_IO_Running: Yes Slave_SQL_Running: Yes Replicate_Do_DB: Replicate_Ignore_DB: Replicate_Do_Table: Replicate_Ignore_Table: Replicate_Wild_Do_Table: Replicate_Wild_Ignore_Table: Last_Errno: 0 Last_Error: Skip_Counter: 0 Exec_Master_Log_Pos: 590 Relay_Log_Space: 534 Until_Condition: None Until_Log_File: Until_Log_Pos: 0 Master_SSL_Allowed: No Master_SSL_CA_File: Master_SSL_CA_Path: Master_SSL_Cert: Master_SSL_Cipher: Master_SSL_Key: Seconds_Behind_Master: 0 Master_SSL_Verify_Server_Cert: No Last_IO_Errno: 0 Last_IO_Error: Last_SQL_Errno: 0 Last_SQL_Error: Replicate_Ignore_Server_Ids: Master_Server_Id: 1 Master_UUID: 30c38043-ada1-11e8-8fa1-0242ac110002 Master_Info_File: /var/lib/mysql/master.info SQL_Delay: 0 SQL_Remaining_Delay: NULL Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates Master_Retry_Count: 86400 Master_Bind: Last_IO_Error_Timestamp: Last_SQL_Error_Timestamp: Master_SSL_Crl: Master_SSL_Crlpath: Retrieved_Gtid_Set: Executed_Gtid_Set: Auto_Position: 0 Replicate_Rewrite_DB: Channel_Name: Master_TLS_Version: 1 row in set (0.00 sec) mysql\u0026gt; quit Bye exit  接下来可以如法炮制配置出slave2和slave3，这样就可以搭建起一个“一主带三从”的主从复制环境。上面创建创建容器时使用的--link参数用来配置容器在网络上的主机名（网络地址别名）。\n配置好主从复制后，写数据的操作应该master上执行，而读数据的操作应该在slave上完成。为此，在Django项目中需要配置DATABASE_ROUTERS并通过自定义的主从复制路由类来实现读写分离操作，如下所示：\nDATABASE_ROUTERS = [ # 此处省略其他配置 \u0026#39;common.routers.MasterSlaveRouter\u0026#39;, ]class MasterSlaveRouter(object): \u0026#34;\u0026#34;\u0026#34;主从复制路由\u0026#34;\u0026#34;\u0026#34; @staticmethod def db_for_read(model, **hints): \u0026#34;\u0026#34;\u0026#34; Attempts to read auth models go to auth_db. \u0026#34;\u0026#34;\u0026#34; return random.choice((\u0026#39;slave1\u0026#39;, \u0026#39;slave2\u0026#39;, \u0026#39;slave3\u0026#39;)) @staticmethod def db_for_write(model, **hints): \u0026#34;\u0026#34;\u0026#34; Attempts to write auth models go to auth_db. \u0026#34;\u0026#34;\u0026#34; return \u0026#39;default\u0026#39; @staticmethod def allow_relation(obj1, obj2, **hints): \u0026#34;\u0026#34;\u0026#34; Allow relations if a model in the auth app is involved. \u0026#34;\u0026#34;\u0026#34; return None @staticmethod def allow_migrate(db, app_label, model_name=None, **hints): \u0026#34;\u0026#34;\u0026#34; Make sure the auth app only appears in the \u0026#39;auth_db\u0026#39; database. \u0026#34;\u0026#34;\u0026#34; return True 上面的内容参考了Django官方文档的DATABASE_ROUTERS配置，对代码进行了适当的调整。\nDocker 事实上，项目上线中最为麻烦的事情就是配置软件运行环境，环境的差异会给软件的安装和部署带来诸多的麻烦，而Docker正好可以解决这个问题。关于Docker在之前的文档中我们已经介绍过了，接下来我们对Docker的知识做一些必要的补充。\n 创建镜像文件。  将容器保存成镜像：\ndocker commit -m \u0026#34;...\u0026#34; -a \u0026#34;jackfrued\u0026#34; \u0026lt;container-name\u0026gt; jackfrued/\u0026lt;image-name\u0026gt; 使用Dockerfile构建镜像：\n# 指定基础镜像文件 FROM centos:latest # 指定维护者信息 MAINTAINER jackfrued # 执行命令 RUN yum -y install gcc RUN cd ~ RUN mkdir -p project/code RUN mkdir -p project/logs # 拷贝文件 COPY ... # 暴露端口 EXPOSE ... # 在容器启动时执行命令 CMD ~/init.shdocker build -t jackfrued/\u0026lt;image-name\u0026gt; .  镜像的导入和导出。\ndocker save -o \u0026lt;file-name\u0026gt;.tar \u0026lt;image-name\u0026gt;:\u0026lt;version\u0026gt; docker load -i \u0026lt;file-name\u0026gt;.tar 推送到DockerHub服务器。\ndocker tag \u0026lt;image-name\u0026gt;:\u0026lt;version\u0026gt; jackfrued/\u0026lt;name\u0026gt; docker login docker push jackfrued/\u0026lt;name\u0026gt; 容器之间的通信。\ndocker run --link \u0026lt;container-name\u0026gt;:\u0026lt;alias-name\u0026gt;  如果我们能够在Docker中完成项目的部署，并且将整个部署好的容器打包成镜像文件进行分发和安装，这样就可以解决项目在多个节点上进行部署时可能遇到的麻烦，而且整个部署可以在很短的时间内完成。\nSupervisor Supervisor是一个用Python写的进程管理工具，可以很方便的用来在类Unix系统下启动、重启（自动重启程序）和关闭进程，目前Supervisor暂时还没有提供对Python 3的支持，可以通过Python 2来安装和运行Supervisor，再通过Supervisor来管理Python 3的程序。\n 安装Supervisor。\npip install virtualenv virtualenv -p /usr/bin/python venv source venv/bin/activate pip install supervisor 查看Supervisor的配置文件。\nvim /etc/supervisord.conf; 此处省略上面的代码 ; The [include] section can just contain the \u0026#34;files\u0026#34; setting. This ; setting can list multiple files (separated by whitespace or ; newlines). It can also contain wildcards. The filenames are ; interpreted as relative to this file. Included files *cannot* ; include files themselves. [include] files = supervisord.d/*.ini 可以看出自定义的管理配置代码可以放在/etc/supervisord.d目录中，并且文件名以ini作为后缀即可。\n 编写自己的配置文件fangtx.ini并放在/etc/supervisord.d目录中。\n[program:project] command=uwsgi --ini /root/project/conf/uwsgi.ini stopsignal=QUIT autostart=true autorestart=true redirect_stderr=true [program:celery] ; Set full path to celery program if using virtualenv command=/root/project/venv/bin/python manage.py celery -A fangtx worker user=root numprocs=1 stdout_logfile=/var/log/supervisor/celery.log stderr_logfile=/var/log/supervisor/celery_error.log autostart=true autorestart=true startsecs=10 ; Need to wait for currently executing tasks to finish at shutdown. ; Increase this if you have very long running tasks. ;stopwaitsecs = 600 ; When resorting to send SIGKILL to the program to terminate it ; send SIGKILL to its whole process group instead, ; taking care of its children as well. killasgroup=true ; Set Celery priority higher than default (999) ; so, if rabbitmq is supervised, it will start first. priority=1000 启动Supervisor。\nsupervisorctl -c /etc/supervisord.conf  其他服务  常用开源软件。  | 功能 | 开源方案 | | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- | | 版本控制工具 | Git、Mercurial、SVN | | 缺陷管理 | Redmine、Mantis | | 负载均衡 | Nginx、LVS、HAProxy | | 邮件服务 | Postfix、Sendmail | | HTTP服务 | Nginx、Apache | | 消息队列 | RabbitMQ、ZeroMQ、Redis | | 文件系统 | FastDFS | | 基于位置服务（LBS） | MongoDB、Redis | | 监控服务 | Nagios、Zabbix | | 关系型数据库 | MySQL、PostgreSQL | | 非关系型数据库 | MongoDB、Redis、Cassandra | | 搜索引擎 | ElasticSearch、Solr | | 缓存服务 | Mamcached、Redis |\n 常用云服务。  | 功能 | 可用的云服务 | | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; | | 团队协作工具 | Teambition、钉钉 | | 代码托管平台 | Github、Gitee、CODING | | 邮件服务 | SendCloud | | 云存储（CDN） | 七牛、OSS、LeanCloud、Bmob、又拍云、AWS | | 移动端推送 | 极光、友盟、百度 | | 即时通信 | 环信、融云 | | 短信服务 | 云片、极光、Luosimao、又拍云 | | 第三方登录 | 友盟、ShareSDK | | 网站监控和统计 | 阿里云监控、监控宝、百度云观测、小鸟云 |\n"},{"idx":90,"href":"/python100days/docs/Day91-100/99-%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E5%85%AC%E5%85%B1%E9%97%AE%E9%A2%98/","title":"99 面试中的公共问题","content":" 面试中的公共问题 计算机基础  TCP/IP模型相关问题。   建议阅读阮一峰的《互联网协议入门（一）》和《互联网协议入门（二）》。\n  HTTP和HTTPS相关问题。   建议阅读阮一峰的《HTTP 协议入门》和《SSL/TLS协议运行机制的概述》。\n  Linux常用命令和服务。\n 进程和线程之间的关系。什么时候用多线程？什么时候用多进程？。\n 关系型数据库相关问题（ACID、事务隔离级别、锁、SQL优化）。\n 非关系型数据库相关问题（CAP/BASE、应用场景）。\n  Python基础  开发中用过哪些标准库和三方库。   标准库：sys / os / re / math / random / logging / json / pickle / shelve / socket / datetime / hashlib / configparser / urllib / itertools / collections / functools / threading / multiprocess / timeit / atexit / abc / asyncio / base64 / concurrent.futures / copy / csv / operator / enum / heapq / http / profile / pstats / ssl / unitest / uuid\n三方库：openpyxl / xlrd / xlwt / PyPDF2 / ReportLab / PyYAML / jieba / pillow / requests / urllib3 / responses / aiohttp / BeautifulSoup4 / lxml / pyquery / PyMySQL / psycopg2 / redis / PyMongo / Peewee / SQLAlchemy / alipay / PyJWT / itsdangerous / celery / flower / elasticsearch-dsl-py / PyCrypto / Paramiko / logbook / nose / pytest / coverage / Selenium / lineprofiler / memoryprofiler / matplotlib / pygal / OpenCV\n  装饰器的作用、原理和实现。\n 使用过哪些魔法方法。\n   建议阅读《Python魔术方法指南》。\n  生成式、生成器、迭代器的编写。\n 列表、集合、字典的底层实现。\n 垃圾回收相关问题。\n 并发编程的相关问题。\n 协程和异步I/O相关知识。\n  Django和Flask  MVC架构（MTV）解决了什么问题。\n 中间件的执行流程以及如何自定义中间件。\n REST数据接口如何设计（URL、域名、版本、过滤、状态码、安全性）。\n   建议阅读阮一峰的《RESTful API设计指南》。\n  使用ORM框架实现CRUD操作的相关问题。\n 如何实现多条件组合查询 / 如何执行原生的SQL / 如何避免N+1查询问题  如何执行异步任务和定时任务。\n 如何实现页面缓存和查询缓存？缓存如何预热？\n  爬虫相关  Scrapy框架的组件和数据处理流程。 爬取的目的（项目中哪些地方需要用到爬虫的数据）。 使用的工具（抓包、下载、清理、存储、分析、可视化）。 数据的来源（能够轻松的列举出10个网站）。 数据的构成（抓取的某个字段在项目中有什么用）。 反反爬措施（限速、请求头、Cookie池、代理池、Selenium、PhantomJS、RoboBrowser、TOR、OCR）。 数据的体量（最后抓取了多少数据，多少W条数据或多少个G的数据）。 后期数据处理（持久化、数据补全、归一化、格式化、转存、分类）。  数据分析  科学运算函数库（SciPy和NumPy常用运算）。 数据分析库（Pandas中封装的常用算法）。 常用的模型及对应的场景（分类、回归、聚类）。 提取了哪些具体的指标。 如何评价模型的优劣。 每种模型实际操作的步骤，对结果如何评价。  项目相关  项目团队构成以及自己在团队中扮演的角色（在项目中的职责）。 项目的业务架构（哪些模块及子模块）和技术架构（移动端、PC端、后端技术栈）。 软件控制管理相关工具（版本控制、问题管理、持续集成）。 核心业务实体及其属性，实体与实体之间的关系。 用到哪些依赖库，依赖库主要解决哪方面的问题。 项目如何部署上线以及项目的物理架构（Nginx、Gunicorn/uWSGI、Redis、MongoDB、MySQL、Supervisor等）。 如何对项目进行测试，有没有做过性能调优。 项目中遇到的困难有哪些，如何解决的。  "},{"idx":91,"href":"/python100days/docs/","title":"Docs","content":""},{"idx":92,"href":"/python100days/","title":"Python - 100天从新手到大师","content":" Python - 100天从新手到大师  作者：骆昊\n最近有很多想学习Python的小伙伴陆陆续续加入我们的交流群，目前我们的交流群人数已经超过一万人，光靠我自己已经无法及时处理小伙伴们的入群申请，更无法及时为大家解答问题。目前我的想法是分技术方向建立讨论群并安排专门的人来管理这些群，群管理者应该具备专业的知识并有相对充裕的时间，可以解答小伙伴们提出的问题。当然，我会向这些管理者支付报酬，如果有兴趣成为管理者的可以跟我私聊。但愿通过这种方式，我们的群能汇聚更多优秀的Python开发者，一方面打造一个优质的沟通和交流的平台，另一方面让新入行的开发者获得问道的途径并藉此迅速成长。我会继续努力做好线上公开课以及线下技术交流活动，也希望各位小伙伴一如既往的支持我们。创作不易，感谢大家的打赏支持，这些钱不会用于购买咖啡而是捐赠给支教组织。感谢北京千锋互联科技有限公司对公开课提供的支持。\n温馨提示：中间的Python100天交流群之初入江湖为付费群，会安排专门的群管理者为大家解答问题；右侧的Python后端开发讨论群和Python爬虫开发讨论群为免费群，从事Web后端开发和爬虫开发的小伙伴可以加群交流，萌新勿入。\n Python应用领域和就业形势分析 简单的说，Python是一个“优雅”、“明确”、“简单”的编程语言。\n 学习曲线低，非专业人士也能上手 开源系统，拥有强大的生态圈 解释型语言，完美的平台可移植性 支持面向对象和函数式编程 能够通过调用C/C++代码扩展功能 代码规范程度高，可读性强  目前几个比较流行的领域，Python都有用武之地。\n 云基础设施 - Python / Java / Go DevOps - Python / Shell / Ruby / Go 网络爬虫 - Python / PHP / C++ 数据分析挖掘 - Python / R / Scala / Matlab 机器学习 - Python / R / Java / Lisp  作为一名Python开发者，主要的就业领域包括：\n Python服务器后台开发 / 游戏服务器开发 / 数据接口开发工程师 Python自动化运维工程师 Python数据分析 / 数据可视化 / 大数据工程师 Python爬虫工程师 Python聊天机器人开发 / 图像识别和视觉算法 / 深度学习工程师  下图显示了主要城市Python招聘需求量及薪资待遇排行榜（截止到2018年5月）。\n给初学者的几个建议：\n Make English as your working language. Practice makes perfect. All experience comes from mistakes. Don\u0026rsquo;t be one of the leeches. Either stand out or kicked out.  Day01~15 - Python语言基础 Day01 - 初识Python  Python简介 - Python的历史 / Python的优缺点 / Python的应用领域 搭建编程环境 - Windows环境 / Linux环境 / MacOS环境 从终端运行Python程序 - Hello, world / print函数 / 运行程序 使用IDLE - 交互式环境(REPL) / 编写多行代码 / 运行程序 / 退出IDLE 注释 - 注释的作用 / 单行注释 / 多行注释  Day02 - 语言元素  程序和进制 - 指令和程序 / 冯诺依曼机 / 二进制和十进制 / 八进制和十六进制 变量和类型 - 变量的命名 / 变量的使用 / input函数 / 检查变量类型 / 类型转换 数字和字符串 - 整数 / 浮点数 / 复数 / 字符串 / 字符串基本操作 / 字符编码 运算符 - 数学运算符 / 赋值运算符 / 比较运算符 / 逻辑运算符 / 身份运算符 / 运算符的优先级 应用案例 - 华氏温度转换成摄氏温度 / 输入圆的半径计算周长和面积 / 输入年份判断是否是闰年  Day03 - 分支结构  分支结构的应用场景 - 条件 / 缩进 / 代码块 / 流程图 if语句 - 简单的if / if-else结构 / if-elif-else结构 / 嵌套的if 应用案例 - 用户身份验证 / 英制单位与公制单位互换 / 掷骰子决定做什么 / 百分制成绩转等级制 / 分段函数求值 / 输入三条边的长度如果能构成三角形就计算周长和面积  Day04 - 循环结构  循环结构的应用场景 - 条件 / 缩进 / 代码块 / 流程图 while循环 - 基本结构 / break语句 / continue语句 for循环 - 基本结构 / range类型 / 循环中的分支结构 / 嵌套的循环 / 提前结束程序 应用案例 - 1~100求和 / 判断素数 / 猜数字游戏 / 打印九九表 / 打印三角形图案 / 猴子吃桃 / 百钱百鸡  Day05 - 构造程序逻辑  基础练习 - 水仙花数 / 完美数 / 五人分鱼 / Fibonacci数列 / 回文素数 综合练习 - Craps赌博游戏  Day06 - 函数和模块的使用  函数的作用 - 代码的坏味道 / 用函数封装功能模块 定义函数 - def语句 / 函数名 / 参数列表 / return语句 / 调用自定义函数 调用函数 - Python内置函数 / 导入模块和函数 函数的参数 - 默认参数 / 可变参数 / 关键字参数 / 命名关键字参数 函数的返回值 - 没有返回值 / 返回单个值 / 返回多个值 作用域问题 - 局部作用域 / 嵌套作用域 / 全局作用域 / 内置作用域 / 和作用域相关的关键字 用模块管理函数 - 模块的概念 / 用自定义模块管理函数 / 命名冲突的时候会怎样（同一个模块和不同的模块）  Day07 - 字符串和常用数据结构  字符串的使用 - 计算长度 / 下标运算 / 切片 / 常用方法 列表基本用法 - 定义列表 / 用下表访问元素 / 下标越界 / 添加元素 / 删除元素 / 修改元素 / 切片 / 循环遍历 列表常用操作 - 连接 / 复制(复制元素和复制数组) / 长度 / 排序 / 倒转 / 查找 生成列表 - 使用range创建数字列表 / 生成表达式 / 生成器 元组的使用 - 定义元组 / 使用元组中的值 / 修改元组变量 / 元组和列表转换 集合基本用法 - 集合和列表的区别 / 创建集合 / 添加元素 / 删除元素 / 清空 集合常用操作 - 交集 / 并集 / 差集 / 对称差 / 子集 / 超集 字典的基本用法 - 字典的特点 / 创建字典 / 添加元素 / 删除元素 / 取值 / 清空 字典常用操作 - keys()方法 / values()方法 / items()方法 / setdefault()方法 基础练习 - 跑马灯效果 / 列表找最大元素 / 统计考试成绩的平均分 / Fibonacci数列 / 杨辉三角 综合案例 - 双色球选号 / 井字棋  Day08 - 面向对象编程基础  类和对象 - 什么是类 / 什么是对象 / 面向对象其他相关概念 定义类 - 基本结构 / 属性和方法 / 构造器 / 析构器 / __str__方法 使用对象 - 创建对象 / 给对象发消息 面向对象的四大支柱 - 抽象 / 封装 / 继承 / 多态 基础练习 - 定义学生类 / 定义时钟类 / 定义图形类 / 定义汽车类  Day09 - 面向对象进阶  属性 - 类属性 / 实例属性 / 属性访问器 / 属性修改器 / 属性删除器 / 使用__slots__ 类中的方法 - 实例方法 / 类方法 / 静态方法 运算符重载 - __add__ / __sub__ / __or__ /__getitem__ / __setitem__ / __len__ / __repr__ / __gt__ / __lt__ / __le__ / __ge__ / __eq__ / __ne__ / __contains__ 类(的对象)之间的关系 - 关联 / 继承 / 依赖 继承和多态 - 什么是继承 / 继承的语法 / 调用父类方法 / 方法重写 / 类型判定 / 多重继承 / 菱形继承(钻石继承)和C3算法 综合案例 - 工资结算系统 / 图书自动折扣系统 / 自定义分数类  Day10 - 图形用户界面和游戏开发  使用tkinter开发GUI 使用pygame三方库开发游戏应用 “大球吃小球”游戏  Day11 - 文件和异常  读文件 - 读取整个文件 / 逐行读取 / 文件路径 写文件 - 覆盖写入 / 追加写入 / 文本文件 / 二进制文件 异常处理 - 异常机制的重要性 / try-except代码块 / else代码块 / finally代码块 / 内置异常类型 / 异常栈 / raise语句 数据持久化 - CSV文件概述 / csv模块的应用 / JSON数据格式 / json模块的应用  Day12 - 字符串和正则表达式  字符串高级操作 - 转义字符 / 原始字符串 / 多行字符串 / in和 not in运算符 / is开头的方法 / join和split方法 / strip相关方法 / pyperclip模块 / 不变字符串和可变字符串 / StringIO的使用 正则表达式入门 - 正则表达式的作用 / 元字符 / 转义 / 量词 / 分组 / 零宽断言 /贪婪匹配与惰性匹配懒惰 / 使用re模块实现正则表达式操作（匹配、搜索、替换、捕获） 使用正则表达式 - re模块 / compile函数 / group和groups方法 / match方法 / search方法 / findall和finditer方法 / sub和subn方法 / split方法 应用案例 - 使用正则表达式验证输入的字符串  Day13 - 进程和线程  进程和线程的概念 - 什么是进程 / 什么是线程 / 多线程的应用场景 使用进程 - fork函数 / multiprocessing模块 / 进程池 / 进程间通信 使用线程 - thread模块 / threading模块 / Thread类 / Lock类 / Condition类 / 线程池  Day14 - 网络编程入门和网络应用开发  计算机网络基础 - 计算机网络发展史 / “TCP-IP”模型 / IP地址 / 端口 / 协议 / 其他相关概念 网络应用模式 - “客户端-服务器”模式 / “浏览器-服务器”模式 基于HTTP协议访问网络资源 - 网络API概述 / 访问URL / requests模块 / 解析JSON格式数据 Python网络编程 - 套接字的概念 / socket模块 / socket函数 / 创建TCP服务器 / 创建TCP客户端 / 创建UDP服务器 / 创建UDP客户端 / SocketServer模块 电子邮件 - SMTP协议 / POP3协议 / IMAP协议 / smtplib模块 / poplib模块 / imaplib模块 短信服务 - 调用短信服务网关  Day15 - 图像和文档处理  用Pillow处理图片 - 图片读写 / 图片合成 / 几何变换 / 色彩转换 / 滤镜效果 读写Word文档 - 文本内容的处理 / 段落 / 页眉和页脚 / 样式的处理 读写Excel文件 - xlrd模块 / xlwt模块 生成PDF文件 - pypdf2模块 / reportlab模块  Day16~Day20 - Python语言进阶   常用数据结构 函数的高级用法 - “一等公民” / 高阶函数 / Lambda函数 / 作用域和闭包 / 装饰器 面向对象高级知识 - “三大支柱” / 类与类之间的关系 / 垃圾回收 / 魔术属性和方法 / 混入 / 元类 / 面向对象设计原则 / GoF设计模式 迭代器和生成器 - 相关魔术方法 / 创建生成器的两种方式 / 并发和异步编程 - 多线程 / 多进程 / 异步IO / async和await  Day21~30 - Web前端入门  用HTML标签承载页面内容 用CSS渲染页面 用JavaScript处理交互式行为 jQuery入门和提高 Vue.js入门 Element的使用 Bootstrap的使用  Day31~35 - 玩转Linux操作系统  操作系统发展史和Linux概述 Linux基础命令 Linux中的实用程序 Linux的文件系统 Vim编辑器的应用 环境变量和Shell编程 软件的安装和服务的配置 网络访问和管理 其他相关内容  Day36~40 - 数据库基础和进阶  关系型数据库MySQL  关系型数据库概述 MySQL的安装和使用 SQL的使用 DDL - 数据定义语言 - create / drop / alter DML - 数据操作语言 - insert / delete / update / select DCL - 数据控制语言 - grant / revoke 相关知识 范式理论 - 设计二维表的指导思想 数据完整性 数据一致性 在Python中操作MySQL  NoSQL入门  NoSQL概述 Redis概述 Mongo概述   Day41~55 - 实战Django Day41 - 快速上手  Web应用工作原理和HTTP协议 Django框架概述 5分钟快速上手 使用视图模板  Day42 - 深入模型  关系型数据库配置 管理后台的使用 使用ORM完成对模型的CRUD操作 Django模型最佳实践 模型定义参考  Day43 - 静态资源和Ajax请求  加载静态资源 用Ajax请求获取数据  Day44 - 表单的应用  表单和表单控件 跨站请求伪造和CSRF令牌 Form和ModelForm 表单验证  Day45 - Cookie和Session  实现用户跟踪 cookie和session的关系 Django框架对session的支持 视图函数中的cookie读写操作  Day46 - 报表和日志  通过HttpResponse修改响应头 使用StreamingHttpResponse处理大文件 使用xlwt生成Excel报表 使用reportlab生成PDF报表 使用ECharts生成前端图表 配置日志和Django-Debug-Toolbar  Day47 - 中间件的应用  什么是中间件 Django框架内置的中间件 自定义中间件及其应用场景  Day48 - 前后端分离开发入门  返回JSON格式的数据 用Vue.js渲染页面  Day49 - RESTful架构和DRF入门 Day50 - RESTful架构和DRF进阶 Day51 - 使用缓存  网站优化第一定律\n 在Django项目中使用Redis提供缓存服务\n 在视图函数中读写缓存\n 使用装饰器实现页面缓存\n 为数据接口提供缓存服务\n  Day52 - 文件上传和富文本编辑  文件上传表单控件和图片文件预览 服务器端如何处理上传的文件 富文本编辑器概述 wangEditor的使用  Day53 - 短信和邮件  常用短信网关平台介绍 使用螺丝帽发送短信 Django框架对邮件服务的支持  Day54 - 异步任务和定时任务  网站优化第二定律 配置消息队列服务 在项目中使用celery实现任务异步化 在项目中使用celery实现定时任务  Day55 - 单元测试和项目上线  Python中的单元测试 Django框架对单元测试的支持 使用版本控制系统 配置和使用uWSGI 动静分离和Nginx配置 配置HTTPS  Day56~60 - 实战Flask Day56 - Flask入门 Day57 - 模板的使用 Day58 - 表单的处理 Day59 - 数据库操作 Day60 - 项目实战 Day61~65 - 实战Tornado Day61 - 预备知识  并发编程 I/O模式和事件驱动  Day62 - Tornado入门  Tornado概述 5分钟上手Tornado 路由解析 请求处理器  Day63 - 异步化  aiomysql和aioredis的使用  Day64 - WebSocket的应用  WebSocket简介 WebSocket服务器端编程 WebSocket客户端编程 项目：Web聊天室  Day65 - 项目实战  前后端分离开发和接口文档的撰写 使用Vue.js实现前端渲染 使用ECharts实现报表功能 使用WebSocket实现推送服务  Day66~75 - 爬虫开发 Day66 - 网络爬虫和相关工具  网络爬虫的概念及其应用领域 网络爬虫的合法性探讨 开发网络爬虫的相关工具 一个爬虫程序的构成  Day67 - 数据采集和解析  数据采集的标准和三方库 页面解析的三种方式：正则表达式解析 / XPath解析 / CSS选择器解析  Day68 - 存储数据  如何存储海量数据 实现数据的缓存  Day69 - 并发下载  多线程和多进程 异步I/O和协程 async和await关键字的使用 三方库aiohttp的应用  Day70 - 解析动态内容  JavaScript逆向工程 使用Selenium获取动态内容  Day71 - 表单交互和验证码处理  自动提交表单 Cookie池的应用 验证码处理  Day72 - Scrapy入门  Scrapy爬虫框架概述 安装和使用Scrapy  Day73 - Scrapy高级应用  Spider的用法 中间件的应用：下载中间件 / 蜘蛛中间件 Scrapy对接Selenium抓取动态内容 Scrapy部署到Docker  Day74 - Scrapy分布式实现  分布式爬虫的原理 Scrapy分布式实现 使用Scrapyd实现分布式部署  Day75 - 爬虫项目实战  爬取招聘网站数据 爬取房地产行业数据 爬取二手车交易平台数据  Day76~90 - 数据处理和机器学习 Day76 - 机器学习基础 Day77 - Pandas的应用 Day78 - NumPy和SciPy的应用 Day79 - Matplotlib和数据可视化 Day80 - k最近邻(KNN)分类 Day81 - 决策树 Day82 - 贝叶斯分类 Day83 - 支持向量机(SVM) Day84 - K-均值聚类 Day85 - 回归分析 Day86 - 大数据分析入门 Day87 - 大数据分析进阶 Day88 - Tensorflow入门 Day89 - Tensorflow实战 Day90 - 推荐系统 Day91~100 - 团队项目开发 第91天：团队项目开发准备  软件过程模型\n 经典过程模型（瀑布模型）  可行性分析（研究做还是不做），输出《可行性分析报告》。 需求分析（研究做什么），输出《需求规格说明书》和产品界面原型图。 概要设计和详细设计，输出概念模型图、物理模型图、类图、时序图等。 编码 / 测试。 上线 / 维护。  敏捷开发（Scrum）- 产品所有者、Scrum Master、研发人员 - Sprint  产品的Backlog（用户故事、产品原型）。 计划会议（评估和预算）。 日常开发（站立会议、番茄工作法、结对编程、测试先行、代码重构……）。 修复bug（问题描述、重现步骤、测试人员、被指派人）。 评审会议（Showcase）。 回顾会议（当前周期做得好和不好的地方）。    补充：敏捷软件开发宣言\n 个体和互动 高于 流程和工具 工作的软件 高于 详尽的文档 客户合作 高于 合同谈判 响应变化 高于 遵循计划    角色：产品所有者（决定做什么，能对需求拍板的人）、团队负责人（解决各种问题，专注如何更好的工作，屏蔽外部对开发团队的影响）、开发团队（项目执行人员，具体指开发人员和测试人员）。\n准备工作：商业案例和资金、合同、憧憬、初始产品需求、初始发布计划、入股、组建团队。\n敏捷团队通常人数为8-10人。\n工作量估算：将开发任务量化，包括原型、Logo设计、UI设计、前端开发等，尽量把每个工作分解到最小任务量，最小任务量标准为工作时间不能超过两天，然后估算总体项目时间。把每个任务都贴在白板上面，白板上分三部分：to do（待完成）、in progress（进行中）和done（已完成）。\n 项目团队组建\n 团队的构成和角色   说明：谢谢付祥英女士绘制了下面这张精美的公司组织架构图。\n  编程规范和代码审查（flake8、pylint）   Python中的一些“惯例”（请参考《Python惯例-如何编写Pythonic的代码》）\n 影响代码可读性的原因：\n 代码注释太少或者没有注释 代码破坏了语言的最佳实践 反模式编程（意大利面代码、复制-黏贴编程、自负编程、……）   团队开发工具介绍\n 版本控制：Git、Mercury 缺陷管理：Gitlab、Redmine 敏捷闭环工具：禅道、JIRA 持续集成：Jenkins、Travis-CI   请参考《团队项目开发》。\n项目选题和理解业务  选题范围设定\n CMS（用户端）：新闻聚合网站、问答/分享社区、影评/书评网站等。 MIS（用户端+管理端）：KMS、KPI考核系统、HRS、CRM系统、供应链系统、仓储管理系统等。\n App后台（管理端+数据接口）：二手交易类、报刊杂志类、小众电商类、新闻资讯类、旅游类、社交类、阅读类等。\n 其他类型：自身行业背景和工作经验、业务容易理解和把控。\n  需求理解、模块划分和任务分配\n 需求理解：头脑风暴和竞品分析。 模块划分：画思维导图（XMind），每个模块是一个枝节点，每个具体的功能是一个叶节点（用动词表述），需要确保每个叶节点无法再生出新节点，确定每个叶子节点的重要性、优先级和工作量。 任务分配：由项目负责人根据上面的指标为每个团队成员分配任务。    制定项目进度表（每日更新）  | 模块 | 功能 | 人员 | 状态 | 完成 | 工时 | 计划开始 | 实际开始 | 计划结束 | 实际结束 | 备注 | | \u0026mdash;- | \u0026mdash;\u0026mdash;\u0026ndash; | \u0026mdash;\u0026mdash; | \u0026mdash;\u0026mdash;\u0026ndash; | \u0026mdash;- | \u0026mdash;- | \u0026mdash;\u0026mdash;\u0026ndash; | \u0026mdash;\u0026mdash;\u0026ndash; | \u0026mdash;\u0026mdash;\u0026ndash; | \u0026mdash;\u0026mdash;\u0026ndash; | \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- | | 评论 | 添加评论 | 王大锤 | 正在进行 | 50% | 4 | 2018/8/7 | | 2018/8/7 | | | | | 删除评论 | 王大锤 | 等待 | 0% | 2 | 2018/8/7 | | 2018/8/7 | | | | | 查看评论 | 白元芳 | 正在进行 | 20% | 4 | 2018/8/7 | | 2018/8/7 | | 需要进行代码审查 | | | 评论投票 | 白元芳 | 等待 | 0% | 4 | 2018/8/8 | | 2018/8/8 | | |\n OOAD和数据库设计\n UML（统一建模语言）的类图   通过模型创建表（正向工程）\npython manage.py makemigrations app python manage.py migrate 使用PowerDesigner绘制物理模型图。\n   通过数据表创建模型（反向工程）\npython manage.py inspectdb \u0026gt; app/models.py   第92天：Docker的使用 第93天：MySQL性能优化 第94天：网络API接口设计 第95天：使用Django开发商业项目 项目开发中的公共问题  数据库的配置（多数据库、主从复制、数据库路由） 缓存的配置（分区缓存、键设置、超时设置、主从复制、故障恢复（哨兵）） 日志的配置 分析和调试（Django-Debug-ToolBar） 好用的Python模块（日期计算、图像处理、数据加密、三方API）  REST API设计  RESTful架构  理解RESTful架构 RESTful API设计指南 RESTful API最佳实践  API接口文档的撰写  RAP2 YAPI  django-REST-framework的应用  项目中的重点难点剖析  使用缓存缓解数据库压力 - Redis 使用消息队列做解耦合和削峰 - Celery + RabbitMQ  第96天：软件测试和自动化测试 单元测试  测试的种类 编写单元测试（unittest、pytest、nose2、tox、ddt、……） 测试覆盖率（coverage）  项目部署  部署前的准备工作  关键设置（SECRET_KEY / DEBUG / ALLOWED_HOSTS / 缓存 / 数据库） HTTPS / CSRF_COOKIE_SECUR / SESSION_COOKIE_SECURE\n 日志相关配置  Linux常用命令回顾 Linux常用服务的安装和配置 uWSGI/Gunicorn和Nginx的使用  Gunicorn和uWSGI的比较  对于不需要大量定制化的简单应用程序，Gunicorn是一个不错的选择，uWSGI的学习曲线比Gunicorn要陡峭得多，Gunicorn的默认参数就已经能够适应大多数应用程序。 uWSGI支持异构部署。 由于Nginx本身支持uWSGI，在线上一般都将Nginx和uWSGI捆绑在一起部署，而且uWSGI属于功能齐全且高度定制的WSGI中间件。 在性能上，Gunicorn和uWSGI其实表现相当。   使用虚拟化技术（Docker）部署测试环境和生产环境  性能测试  AB的使用 SQLslap的使用 sysbench的使用  自动化测试  使用Shell和Python进行自动化测试 使用Selenium实现自动化测试  Selenium IDE Selenium WebDriver Selenium Remote Control  测试工具Robot Framework介绍  第97天：电商网站技术要点剖析 第98天：项目部署上线和性能调优  MySQL数据库调优 Web服务器性能优化  Nginx负载均衡配置 Keepalived实现高可用  代码性能调优  多线程 异步化  静态资源访问优化  云存储 CDN   第99天：面试中的公共问题 第100天：英语面试  致谢：感谢的我的同事古晔、张旭、肖世荣、王海飞、荣佳伟、路丰坤等在技术上给予的指导和帮助。\n "}];window.bookSearch={pages:pages,idx:lunr(function(){this.ref("idx");this.field("title");this.field("content");pages.forEach(this.add,this);}),}})();